
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserDetails
 * 
 */
export type UserDetails = $Result.DefaultSelection<Prisma.$UserDetailsPayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model Reaction
 * 
 */
export type Reaction = $Result.DefaultSelection<Prisma.$ReactionPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model PostTag
 * 
 */
export type PostTag = $Result.DefaultSelection<Prisma.$PostTagPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Interest
 * 
 */
export type Interest = $Result.DefaultSelection<Prisma.$InterestPayload>
/**
 * Model Match
 * 
 */
export type Match = $Result.DefaultSelection<Prisma.$MatchPayload>
/**
 * Model UserSimilarity
 * 
 */
export type UserSimilarity = $Result.DefaultSelection<Prisma.$UserSimilarityPayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model CoffeeChat
 * 
 */
export type CoffeeChat = $Result.DefaultSelection<Prisma.$CoffeeChatPayload>
/**
 * Model CoffeeChatPurpose
 * 
 */
export type CoffeeChatPurpose = $Result.DefaultSelection<Prisma.$CoffeeChatPurposePayload>
/**
 * Model CoffeeChatVenue
 * 
 */
export type CoffeeChatVenue = $Result.DefaultSelection<Prisma.$CoffeeChatVenuePayload>
/**
 * Model Chat
 * 
 */
export type Chat = $Result.DefaultSelection<Prisma.$ChatPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const NotificationType: {
  LIKE: 'LIKE',
  COMMENT: 'COMMENT',
  MATCH: 'MATCH',
  MESSAGE: 'MESSAGE',
  EVENT_REMINDER: 'EVENT_REMINDER',
  SYSTEM_MESSAGE: 'SYSTEM_MESSAGE'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const MatchStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED'
};

export type MatchStatus = (typeof MatchStatus)[keyof typeof MatchStatus]


export const CoffeeChatVenueNoiseLevel: {
  QUIET: 'QUIET',
  MODERATE: 'MODERATE',
  LIVELY: 'LIVELY'
};

export type CoffeeChatVenueNoiseLevel = (typeof CoffeeChatVenueNoiseLevel)[keyof typeof CoffeeChatVenueNoiseLevel]


export const CoffeeChatVenueTags: {
  OUTDOOR: 'OUTDOOR',
  SCENIC: 'SCENIC',
  FRESH_AIR: 'FRESH_AIR',
  WIFI: 'WIFI',
  OUTLETS: 'OUTLETS',
  WHITEBOARDS: 'WHITEBOARDS',
  PRIVATE: 'PRIVATE',
  FOOD: 'FOOD',
  COMFORTABLE_SEATING: 'COMFORTABLE_SEATING',
  BOOKS: 'BOOKS'
};

export type CoffeeChatVenueTags = (typeof CoffeeChatVenueTags)[keyof typeof CoffeeChatVenueTags]


export const CoffeeChatStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED'
};

export type CoffeeChatStatus = (typeof CoffeeChatStatus)[keyof typeof CoffeeChatStatus]

}

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type MatchStatus = $Enums.MatchStatus

export const MatchStatus: typeof $Enums.MatchStatus

export type CoffeeChatVenueNoiseLevel = $Enums.CoffeeChatVenueNoiseLevel

export const CoffeeChatVenueNoiseLevel: typeof $Enums.CoffeeChatVenueNoiseLevel

export type CoffeeChatVenueTags = $Enums.CoffeeChatVenueTags

export const CoffeeChatVenueTags: typeof $Enums.CoffeeChatVenueTags

export type CoffeeChatStatus = $Enums.CoffeeChatStatus

export const CoffeeChatStatus: typeof $Enums.CoffeeChatStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userDetails`: Exposes CRUD operations for the **UserDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserDetails
    * const userDetails = await prisma.userDetails.findMany()
    * ```
    */
  get userDetails(): Prisma.UserDetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reaction`: Exposes CRUD operations for the **Reaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reactions
    * const reactions = await prisma.reaction.findMany()
    * ```
    */
  get reaction(): Prisma.ReactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postTag`: Exposes CRUD operations for the **PostTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostTags
    * const postTags = await prisma.postTag.findMany()
    * ```
    */
  get postTag(): Prisma.PostTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interest`: Exposes CRUD operations for the **Interest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Interests
    * const interests = await prisma.interest.findMany()
    * ```
    */
  get interest(): Prisma.InterestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.match`: Exposes CRUD operations for the **Match** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Matches
    * const matches = await prisma.match.findMany()
    * ```
    */
  get match(): Prisma.MatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSimilarity`: Exposes CRUD operations for the **UserSimilarity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSimilarities
    * const userSimilarities = await prisma.userSimilarity.findMany()
    * ```
    */
  get userSimilarity(): Prisma.UserSimilarityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coffeeChat`: Exposes CRUD operations for the **CoffeeChat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoffeeChats
    * const coffeeChats = await prisma.coffeeChat.findMany()
    * ```
    */
  get coffeeChat(): Prisma.CoffeeChatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coffeeChatPurpose`: Exposes CRUD operations for the **CoffeeChatPurpose** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoffeeChatPurposes
    * const coffeeChatPurposes = await prisma.coffeeChatPurpose.findMany()
    * ```
    */
  get coffeeChatPurpose(): Prisma.CoffeeChatPurposeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coffeeChatVenue`: Exposes CRUD operations for the **CoffeeChatVenue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoffeeChatVenues
    * const coffeeChatVenues = await prisma.coffeeChatVenue.findMany()
    * ```
    */
  get coffeeChatVenue(): Prisma.CoffeeChatVenueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chat`: Exposes CRUD operations for the **Chat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chats
    * const chats = await prisma.chat.findMany()
    * ```
    */
  get chat(): Prisma.ChatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.9.0
   * Query Engine version: 81e4af48011447c3cc503a190e86995b66d2a28e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserDetails: 'UserDetails',
    Post: 'Post',
    Reaction: 'Reaction',
    Comment: 'Comment',
    PostTag: 'PostTag',
    Notification: 'Notification',
    Interest: 'Interest',
    Match: 'Match',
    UserSimilarity: 'UserSimilarity',
    Event: 'Event',
    CoffeeChat: 'CoffeeChat',
    CoffeeChatPurpose: 'CoffeeChatPurpose',
    CoffeeChatVenue: 'CoffeeChatVenue',
    Chat: 'Chat',
    Message: 'Message'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "userDetails" | "post" | "reaction" | "comment" | "postTag" | "notification" | "interest" | "match" | "userSimilarity" | "event" | "coffeeChat" | "coffeeChatPurpose" | "coffeeChatVenue" | "chat" | "message"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserDetails: {
        payload: Prisma.$UserDetailsPayload<ExtArgs>
        fields: Prisma.UserDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDetailsPayload>
          }
          findFirst: {
            args: Prisma.UserDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDetailsPayload>
          }
          findMany: {
            args: Prisma.UserDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDetailsPayload>[]
          }
          create: {
            args: Prisma.UserDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDetailsPayload>
          }
          createMany: {
            args: Prisma.UserDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDetailsPayload>[]
          }
          delete: {
            args: Prisma.UserDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDetailsPayload>
          }
          update: {
            args: Prisma.UserDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDetailsPayload>
          }
          deleteMany: {
            args: Prisma.UserDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserDetailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDetailsPayload>[]
          }
          upsert: {
            args: Prisma.UserDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDetailsPayload>
          }
          aggregate: {
            args: Prisma.UserDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserDetails>
          }
          groupBy: {
            args: Prisma.UserDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<UserDetailsCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      Reaction: {
        payload: Prisma.$ReactionPayload<ExtArgs>
        fields: Prisma.ReactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          findFirst: {
            args: Prisma.ReactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          findMany: {
            args: Prisma.ReactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>[]
          }
          create: {
            args: Prisma.ReactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          createMany: {
            args: Prisma.ReactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>[]
          }
          delete: {
            args: Prisma.ReactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          update: {
            args: Prisma.ReactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          deleteMany: {
            args: Prisma.ReactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>[]
          }
          upsert: {
            args: Prisma.ReactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          aggregate: {
            args: Prisma.ReactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReaction>
          }
          groupBy: {
            args: Prisma.ReactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReactionCountArgs<ExtArgs>
            result: $Utils.Optional<ReactionCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      PostTag: {
        payload: Prisma.$PostTagPayload<ExtArgs>
        fields: Prisma.PostTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          findFirst: {
            args: Prisma.PostTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          findMany: {
            args: Prisma.PostTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>[]
          }
          create: {
            args: Prisma.PostTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          createMany: {
            args: Prisma.PostTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>[]
          }
          delete: {
            args: Prisma.PostTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          update: {
            args: Prisma.PostTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          deleteMany: {
            args: Prisma.PostTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>[]
          }
          upsert: {
            args: Prisma.PostTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          aggregate: {
            args: Prisma.PostTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostTag>
          }
          groupBy: {
            args: Prisma.PostTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostTagCountArgs<ExtArgs>
            result: $Utils.Optional<PostTagCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Interest: {
        payload: Prisma.$InterestPayload<ExtArgs>
        fields: Prisma.InterestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          findFirst: {
            args: Prisma.InterestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          findMany: {
            args: Prisma.InterestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>[]
          }
          create: {
            args: Prisma.InterestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          createMany: {
            args: Prisma.InterestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>[]
          }
          delete: {
            args: Prisma.InterestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          update: {
            args: Prisma.InterestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          deleteMany: {
            args: Prisma.InterestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InterestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>[]
          }
          upsert: {
            args: Prisma.InterestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          aggregate: {
            args: Prisma.InterestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterest>
          }
          groupBy: {
            args: Prisma.InterestGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterestGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterestCountArgs<ExtArgs>
            result: $Utils.Optional<InterestCountAggregateOutputType> | number
          }
        }
      }
      Match: {
        payload: Prisma.$MatchPayload<ExtArgs>
        fields: Prisma.MatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          findFirst: {
            args: Prisma.MatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          findMany: {
            args: Prisma.MatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>[]
          }
          create: {
            args: Prisma.MatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          createMany: {
            args: Prisma.MatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>[]
          }
          delete: {
            args: Prisma.MatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          update: {
            args: Prisma.MatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          deleteMany: {
            args: Prisma.MatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MatchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>[]
          }
          upsert: {
            args: Prisma.MatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          aggregate: {
            args: Prisma.MatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatch>
          }
          groupBy: {
            args: Prisma.MatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchCountArgs<ExtArgs>
            result: $Utils.Optional<MatchCountAggregateOutputType> | number
          }
        }
      }
      UserSimilarity: {
        payload: Prisma.$UserSimilarityPayload<ExtArgs>
        fields: Prisma.UserSimilarityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSimilarityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSimilarityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSimilarityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSimilarityPayload>
          }
          findFirst: {
            args: Prisma.UserSimilarityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSimilarityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSimilarityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSimilarityPayload>
          }
          findMany: {
            args: Prisma.UserSimilarityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSimilarityPayload>[]
          }
          create: {
            args: Prisma.UserSimilarityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSimilarityPayload>
          }
          createMany: {
            args: Prisma.UserSimilarityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSimilarityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSimilarityPayload>[]
          }
          delete: {
            args: Prisma.UserSimilarityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSimilarityPayload>
          }
          update: {
            args: Prisma.UserSimilarityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSimilarityPayload>
          }
          deleteMany: {
            args: Prisma.UserSimilarityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSimilarityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSimilarityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSimilarityPayload>[]
          }
          upsert: {
            args: Prisma.UserSimilarityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSimilarityPayload>
          }
          aggregate: {
            args: Prisma.UserSimilarityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSimilarity>
          }
          groupBy: {
            args: Prisma.UserSimilarityGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSimilarityGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSimilarityCountArgs<ExtArgs>
            result: $Utils.Optional<UserSimilarityCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      CoffeeChat: {
        payload: Prisma.$CoffeeChatPayload<ExtArgs>
        fields: Prisma.CoffeeChatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoffeeChatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoffeeChatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatPayload>
          }
          findFirst: {
            args: Prisma.CoffeeChatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoffeeChatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatPayload>
          }
          findMany: {
            args: Prisma.CoffeeChatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatPayload>[]
          }
          create: {
            args: Prisma.CoffeeChatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatPayload>
          }
          createMany: {
            args: Prisma.CoffeeChatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CoffeeChatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatPayload>[]
          }
          delete: {
            args: Prisma.CoffeeChatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatPayload>
          }
          update: {
            args: Prisma.CoffeeChatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatPayload>
          }
          deleteMany: {
            args: Prisma.CoffeeChatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CoffeeChatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CoffeeChatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatPayload>[]
          }
          upsert: {
            args: Prisma.CoffeeChatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatPayload>
          }
          aggregate: {
            args: Prisma.CoffeeChatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoffeeChat>
          }
          groupBy: {
            args: Prisma.CoffeeChatGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoffeeChatGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoffeeChatCountArgs<ExtArgs>
            result: $Utils.Optional<CoffeeChatCountAggregateOutputType> | number
          }
        }
      }
      CoffeeChatPurpose: {
        payload: Prisma.$CoffeeChatPurposePayload<ExtArgs>
        fields: Prisma.CoffeeChatPurposeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoffeeChatPurposeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatPurposePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoffeeChatPurposeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatPurposePayload>
          }
          findFirst: {
            args: Prisma.CoffeeChatPurposeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatPurposePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoffeeChatPurposeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatPurposePayload>
          }
          findMany: {
            args: Prisma.CoffeeChatPurposeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatPurposePayload>[]
          }
          create: {
            args: Prisma.CoffeeChatPurposeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatPurposePayload>
          }
          createMany: {
            args: Prisma.CoffeeChatPurposeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CoffeeChatPurposeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatPurposePayload>[]
          }
          delete: {
            args: Prisma.CoffeeChatPurposeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatPurposePayload>
          }
          update: {
            args: Prisma.CoffeeChatPurposeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatPurposePayload>
          }
          deleteMany: {
            args: Prisma.CoffeeChatPurposeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CoffeeChatPurposeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CoffeeChatPurposeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatPurposePayload>[]
          }
          upsert: {
            args: Prisma.CoffeeChatPurposeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatPurposePayload>
          }
          aggregate: {
            args: Prisma.CoffeeChatPurposeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoffeeChatPurpose>
          }
          groupBy: {
            args: Prisma.CoffeeChatPurposeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoffeeChatPurposeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoffeeChatPurposeCountArgs<ExtArgs>
            result: $Utils.Optional<CoffeeChatPurposeCountAggregateOutputType> | number
          }
        }
      }
      CoffeeChatVenue: {
        payload: Prisma.$CoffeeChatVenuePayload<ExtArgs>
        fields: Prisma.CoffeeChatVenueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoffeeChatVenueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatVenuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoffeeChatVenueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatVenuePayload>
          }
          findFirst: {
            args: Prisma.CoffeeChatVenueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatVenuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoffeeChatVenueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatVenuePayload>
          }
          findMany: {
            args: Prisma.CoffeeChatVenueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatVenuePayload>[]
          }
          create: {
            args: Prisma.CoffeeChatVenueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatVenuePayload>
          }
          createMany: {
            args: Prisma.CoffeeChatVenueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CoffeeChatVenueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatVenuePayload>[]
          }
          delete: {
            args: Prisma.CoffeeChatVenueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatVenuePayload>
          }
          update: {
            args: Prisma.CoffeeChatVenueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatVenuePayload>
          }
          deleteMany: {
            args: Prisma.CoffeeChatVenueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CoffeeChatVenueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CoffeeChatVenueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatVenuePayload>[]
          }
          upsert: {
            args: Prisma.CoffeeChatVenueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoffeeChatVenuePayload>
          }
          aggregate: {
            args: Prisma.CoffeeChatVenueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoffeeChatVenue>
          }
          groupBy: {
            args: Prisma.CoffeeChatVenueGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoffeeChatVenueGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoffeeChatVenueCountArgs<ExtArgs>
            result: $Utils.Optional<CoffeeChatVenueCountAggregateOutputType> | number
          }
        }
      }
      Chat: {
        payload: Prisma.$ChatPayload<ExtArgs>
        fields: Prisma.ChatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findFirst: {
            args: Prisma.ChatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findMany: {
            args: Prisma.ChatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          create: {
            args: Prisma.ChatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          createMany: {
            args: Prisma.ChatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          delete: {
            args: Prisma.ChatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          update: {
            args: Prisma.ChatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          deleteMany: {
            args: Prisma.ChatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          upsert: {
            args: Prisma.ChatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          aggregate: {
            args: Prisma.ChatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat>
          }
          groupBy: {
            args: Prisma.ChatGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatCountArgs<ExtArgs>
            result: $Utils.Optional<ChatCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    userDetails?: UserDetailsOmit
    post?: PostOmit
    reaction?: ReactionOmit
    comment?: CommentOmit
    postTag?: PostTagOmit
    notification?: NotificationOmit
    interest?: InterestOmit
    match?: MatchOmit
    userSimilarity?: UserSimilarityOmit
    event?: EventOmit
    coffeeChat?: CoffeeChatOmit
    coffeeChatPurpose?: CoffeeChatPurposeOmit
    coffeeChatVenue?: CoffeeChatVenueOmit
    chat?: ChatOmit
    message?: MessageOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserDetailsCountOutputType
   */

  export type UserDetailsCountOutputType = {
    posts: number
    comments: number
    notifications: number
    interests: number
    matchesSent: number
    matchesReceived: number
    currentUserSimilarity: number
    otherUserSimilarity: number
    asEventAttendee: number
    asEventOrganizer: number
    coffeeChatsSent: number
    coffeeChatsReceived: number
    chatsAsUser1: number
    chatsAsUser2: number
    messagesSent: number
  }

  export type UserDetailsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | UserDetailsCountOutputTypeCountPostsArgs
    comments?: boolean | UserDetailsCountOutputTypeCountCommentsArgs
    notifications?: boolean | UserDetailsCountOutputTypeCountNotificationsArgs
    interests?: boolean | UserDetailsCountOutputTypeCountInterestsArgs
    matchesSent?: boolean | UserDetailsCountOutputTypeCountMatchesSentArgs
    matchesReceived?: boolean | UserDetailsCountOutputTypeCountMatchesReceivedArgs
    currentUserSimilarity?: boolean | UserDetailsCountOutputTypeCountCurrentUserSimilarityArgs
    otherUserSimilarity?: boolean | UserDetailsCountOutputTypeCountOtherUserSimilarityArgs
    asEventAttendee?: boolean | UserDetailsCountOutputTypeCountAsEventAttendeeArgs
    asEventOrganizer?: boolean | UserDetailsCountOutputTypeCountAsEventOrganizerArgs
    coffeeChatsSent?: boolean | UserDetailsCountOutputTypeCountCoffeeChatsSentArgs
    coffeeChatsReceived?: boolean | UserDetailsCountOutputTypeCountCoffeeChatsReceivedArgs
    chatsAsUser1?: boolean | UserDetailsCountOutputTypeCountChatsAsUser1Args
    chatsAsUser2?: boolean | UserDetailsCountOutputTypeCountChatsAsUser2Args
    messagesSent?: boolean | UserDetailsCountOutputTypeCountMessagesSentArgs
  }

  // Custom InputTypes
  /**
   * UserDetailsCountOutputType without action
   */
  export type UserDetailsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetailsCountOutputType
     */
    select?: UserDetailsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserDetailsCountOutputType without action
   */
  export type UserDetailsCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * UserDetailsCountOutputType without action
   */
  export type UserDetailsCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserDetailsCountOutputType without action
   */
  export type UserDetailsCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserDetailsCountOutputType without action
   */
  export type UserDetailsCountOutputTypeCountInterestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterestWhereInput
  }

  /**
   * UserDetailsCountOutputType without action
   */
  export type UserDetailsCountOutputTypeCountMatchesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
  }

  /**
   * UserDetailsCountOutputType without action
   */
  export type UserDetailsCountOutputTypeCountMatchesReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
  }

  /**
   * UserDetailsCountOutputType without action
   */
  export type UserDetailsCountOutputTypeCountCurrentUserSimilarityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSimilarityWhereInput
  }

  /**
   * UserDetailsCountOutputType without action
   */
  export type UserDetailsCountOutputTypeCountOtherUserSimilarityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSimilarityWhereInput
  }

  /**
   * UserDetailsCountOutputType without action
   */
  export type UserDetailsCountOutputTypeCountAsEventAttendeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * UserDetailsCountOutputType without action
   */
  export type UserDetailsCountOutputTypeCountAsEventOrganizerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * UserDetailsCountOutputType without action
   */
  export type UserDetailsCountOutputTypeCountCoffeeChatsSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoffeeChatWhereInput
  }

  /**
   * UserDetailsCountOutputType without action
   */
  export type UserDetailsCountOutputTypeCountCoffeeChatsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoffeeChatWhereInput
  }

  /**
   * UserDetailsCountOutputType without action
   */
  export type UserDetailsCountOutputTypeCountChatsAsUser1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
  }

  /**
   * UserDetailsCountOutputType without action
   */
  export type UserDetailsCountOutputTypeCountChatsAsUser2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
  }

  /**
   * UserDetailsCountOutputType without action
   */
  export type UserDetailsCountOutputTypeCountMessagesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type PostCountOutputType
   */

  export type PostCountOutputType = {
    postTags: number
    comments: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    postTags?: boolean | PostCountOutputTypeCountPostTagsArgs
    comments?: boolean | PostCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountPostTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostTagWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type PostTagCountOutputType
   */

  export type PostTagCountOutputType = {
    posts: number
  }

  export type PostTagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | PostTagCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * PostTagCountOutputType without action
   */
  export type PostTagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTagCountOutputType
     */
    select?: PostTagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostTagCountOutputType without action
   */
  export type PostTagCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }


  /**
   * Count Type InterestCountOutputType
   */

  export type InterestCountOutputType = {
    userDetails: number
  }

  export type InterestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userDetails?: boolean | InterestCountOutputTypeCountUserDetailsArgs
  }

  // Custom InputTypes
  /**
   * InterestCountOutputType without action
   */
  export type InterestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestCountOutputType
     */
    select?: InterestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InterestCountOutputType without action
   */
  export type InterestCountOutputTypeCountUserDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserDetailsWhereInput
  }


  /**
   * Count Type EventCountOutputType
   */

  export type EventCountOutputType = {
    organizers: number
    attendees: number
  }

  export type EventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizers?: boolean | EventCountOutputTypeCountOrganizersArgs
    attendees?: boolean | EventCountOutputTypeCountAttendeesArgs
  }

  // Custom InputTypes
  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountOrganizersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserDetailsWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountAttendeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserDetailsWhereInput
  }


  /**
   * Count Type CoffeeChatPurposeCountOutputType
   */

  export type CoffeeChatPurposeCountOutputType = {
    coffeeChats: number
  }

  export type CoffeeChatPurposeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coffeeChats?: boolean | CoffeeChatPurposeCountOutputTypeCountCoffeeChatsArgs
  }

  // Custom InputTypes
  /**
   * CoffeeChatPurposeCountOutputType without action
   */
  export type CoffeeChatPurposeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChatPurposeCountOutputType
     */
    select?: CoffeeChatPurposeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CoffeeChatPurposeCountOutputType without action
   */
  export type CoffeeChatPurposeCountOutputTypeCountCoffeeChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoffeeChatWhereInput
  }


  /**
   * Count Type CoffeeChatVenueCountOutputType
   */

  export type CoffeeChatVenueCountOutputType = {
    coffeeChats: number
  }

  export type CoffeeChatVenueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coffeeChats?: boolean | CoffeeChatVenueCountOutputTypeCountCoffeeChatsArgs
  }

  // Custom InputTypes
  /**
   * CoffeeChatVenueCountOutputType without action
   */
  export type CoffeeChatVenueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChatVenueCountOutputType
     */
    select?: CoffeeChatVenueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CoffeeChatVenueCountOutputType without action
   */
  export type CoffeeChatVenueCountOutputTypeCountCoffeeChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoffeeChatWhereInput
  }


  /**
   * Count Type ChatCountOutputType
   */

  export type ChatCountOutputType = {
    messages: number
  }

  export type ChatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ChatCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatCountOutputType
     */
    select?: ChatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    username: string
    password: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userDetails?: boolean | User$userDetailsArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "username" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userDetails?: boolean | User$userDetailsArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      userDetails: Prisma.$UserDetailsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string
      password: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userDetails<T extends User$userDetailsArgs<ExtArgs> = {}>(args?: Subset<T, User$userDetailsArgs<ExtArgs>>): Prisma__UserDetailsClient<$Result.GetResult<Prisma.$UserDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.userDetails
   */
  export type User$userDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetails
     */
    select?: UserDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDetails
     */
    omit?: UserDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDetailsInclude<ExtArgs> | null
    where?: UserDetailsWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserDetails
   */

  export type AggregateUserDetails = {
    _count: UserDetailsCountAggregateOutputType | null
    _min: UserDetailsMinAggregateOutputType | null
    _max: UserDetailsMaxAggregateOutputType | null
  }

  export type UserDetailsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    department: string | null
    year: string | null
    profilePicture: string | null
    bio: string | null
    availability: string | null
    reading: string | null
  }

  export type UserDetailsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    department: string | null
    year: string | null
    profilePicture: string | null
    bio: string | null
    availability: string | null
    reading: string | null
  }

  export type UserDetailsCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    department: number
    year: number
    profilePicture: number
    bio: number
    availability: number
    reading: number
    _all: number
  }


  export type UserDetailsMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    department?: true
    year?: true
    profilePicture?: true
    bio?: true
    availability?: true
    reading?: true
  }

  export type UserDetailsMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    department?: true
    year?: true
    profilePicture?: true
    bio?: true
    availability?: true
    reading?: true
  }

  export type UserDetailsCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    department?: true
    year?: true
    profilePicture?: true
    bio?: true
    availability?: true
    reading?: true
    _all?: true
  }

  export type UserDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserDetails to aggregate.
     */
    where?: UserDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDetails to fetch.
     */
    orderBy?: UserDetailsOrderByWithRelationInput | UserDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserDetails
    **/
    _count?: true | UserDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserDetailsMaxAggregateInputType
  }

  export type GetUserDetailsAggregateType<T extends UserDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserDetails[P]>
      : GetScalarType<T[P], AggregateUserDetails[P]>
  }




  export type UserDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserDetailsWhereInput
    orderBy?: UserDetailsOrderByWithAggregationInput | UserDetailsOrderByWithAggregationInput[]
    by: UserDetailsScalarFieldEnum[] | UserDetailsScalarFieldEnum
    having?: UserDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserDetailsCountAggregateInputType | true
    _min?: UserDetailsMinAggregateInputType
    _max?: UserDetailsMaxAggregateInputType
  }

  export type UserDetailsGroupByOutputType = {
    id: string
    userId: string
    name: string
    department: string | null
    year: string | null
    profilePicture: string | null
    bio: string | null
    availability: string | null
    reading: string | null
    _count: UserDetailsCountAggregateOutputType | null
    _min: UserDetailsMinAggregateOutputType | null
    _max: UserDetailsMaxAggregateOutputType | null
  }

  type GetUserDetailsGroupByPayload<T extends UserDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], UserDetailsGroupByOutputType[P]>
        }
      >
    >


  export type UserDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    department?: boolean
    year?: boolean
    profilePicture?: boolean
    bio?: boolean
    availability?: boolean
    reading?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    posts?: boolean | UserDetails$postsArgs<ExtArgs>
    comments?: boolean | UserDetails$commentsArgs<ExtArgs>
    notifications?: boolean | UserDetails$notificationsArgs<ExtArgs>
    interests?: boolean | UserDetails$interestsArgs<ExtArgs>
    matchesSent?: boolean | UserDetails$matchesSentArgs<ExtArgs>
    matchesReceived?: boolean | UserDetails$matchesReceivedArgs<ExtArgs>
    currentUserSimilarity?: boolean | UserDetails$currentUserSimilarityArgs<ExtArgs>
    otherUserSimilarity?: boolean | UserDetails$otherUserSimilarityArgs<ExtArgs>
    asEventAttendee?: boolean | UserDetails$asEventAttendeeArgs<ExtArgs>
    asEventOrganizer?: boolean | UserDetails$asEventOrganizerArgs<ExtArgs>
    coffeeChatsSent?: boolean | UserDetails$coffeeChatsSentArgs<ExtArgs>
    coffeeChatsReceived?: boolean | UserDetails$coffeeChatsReceivedArgs<ExtArgs>
    chatsAsUser1?: boolean | UserDetails$chatsAsUser1Args<ExtArgs>
    chatsAsUser2?: boolean | UserDetails$chatsAsUser2Args<ExtArgs>
    messagesSent?: boolean | UserDetails$messagesSentArgs<ExtArgs>
    _count?: boolean | UserDetailsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userDetails"]>

  export type UserDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    department?: boolean
    year?: boolean
    profilePicture?: boolean
    bio?: boolean
    availability?: boolean
    reading?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userDetails"]>

  export type UserDetailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    department?: boolean
    year?: boolean
    profilePicture?: boolean
    bio?: boolean
    availability?: boolean
    reading?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userDetails"]>

  export type UserDetailsSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    department?: boolean
    year?: boolean
    profilePicture?: boolean
    bio?: boolean
    availability?: boolean
    reading?: boolean
  }

  export type UserDetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "department" | "year" | "profilePicture" | "bio" | "availability" | "reading", ExtArgs["result"]["userDetails"]>
  export type UserDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    posts?: boolean | UserDetails$postsArgs<ExtArgs>
    comments?: boolean | UserDetails$commentsArgs<ExtArgs>
    notifications?: boolean | UserDetails$notificationsArgs<ExtArgs>
    interests?: boolean | UserDetails$interestsArgs<ExtArgs>
    matchesSent?: boolean | UserDetails$matchesSentArgs<ExtArgs>
    matchesReceived?: boolean | UserDetails$matchesReceivedArgs<ExtArgs>
    currentUserSimilarity?: boolean | UserDetails$currentUserSimilarityArgs<ExtArgs>
    otherUserSimilarity?: boolean | UserDetails$otherUserSimilarityArgs<ExtArgs>
    asEventAttendee?: boolean | UserDetails$asEventAttendeeArgs<ExtArgs>
    asEventOrganizer?: boolean | UserDetails$asEventOrganizerArgs<ExtArgs>
    coffeeChatsSent?: boolean | UserDetails$coffeeChatsSentArgs<ExtArgs>
    coffeeChatsReceived?: boolean | UserDetails$coffeeChatsReceivedArgs<ExtArgs>
    chatsAsUser1?: boolean | UserDetails$chatsAsUser1Args<ExtArgs>
    chatsAsUser2?: boolean | UserDetails$chatsAsUser2Args<ExtArgs>
    messagesSent?: boolean | UserDetails$messagesSentArgs<ExtArgs>
    _count?: boolean | UserDetailsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserDetailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserDetails"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      posts: Prisma.$PostPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      interests: Prisma.$InterestPayload<ExtArgs>[]
      matchesSent: Prisma.$MatchPayload<ExtArgs>[]
      matchesReceived: Prisma.$MatchPayload<ExtArgs>[]
      currentUserSimilarity: Prisma.$UserSimilarityPayload<ExtArgs>[]
      otherUserSimilarity: Prisma.$UserSimilarityPayload<ExtArgs>[]
      asEventAttendee: Prisma.$EventPayload<ExtArgs>[]
      asEventOrganizer: Prisma.$EventPayload<ExtArgs>[]
      coffeeChatsSent: Prisma.$CoffeeChatPayload<ExtArgs>[]
      coffeeChatsReceived: Prisma.$CoffeeChatPayload<ExtArgs>[]
      chatsAsUser1: Prisma.$ChatPayload<ExtArgs>[]
      chatsAsUser2: Prisma.$ChatPayload<ExtArgs>[]
      messagesSent: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      department: string | null
      year: string | null
      profilePicture: string | null
      bio: string | null
      availability: string | null
      reading: string | null
    }, ExtArgs["result"]["userDetails"]>
    composites: {}
  }

  type UserDetailsGetPayload<S extends boolean | null | undefined | UserDetailsDefaultArgs> = $Result.GetResult<Prisma.$UserDetailsPayload, S>

  type UserDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserDetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserDetailsCountAggregateInputType | true
    }

  export interface UserDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserDetails'], meta: { name: 'UserDetails' } }
    /**
     * Find zero or one UserDetails that matches the filter.
     * @param {UserDetailsFindUniqueArgs} args - Arguments to find a UserDetails
     * @example
     * // Get one UserDetails
     * const userDetails = await prisma.userDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserDetailsFindUniqueArgs>(args: SelectSubset<T, UserDetailsFindUniqueArgs<ExtArgs>>): Prisma__UserDetailsClient<$Result.GetResult<Prisma.$UserDetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserDetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserDetailsFindUniqueOrThrowArgs} args - Arguments to find a UserDetails
     * @example
     * // Get one UserDetails
     * const userDetails = await prisma.userDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserDetailsClient<$Result.GetResult<Prisma.$UserDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDetailsFindFirstArgs} args - Arguments to find a UserDetails
     * @example
     * // Get one UserDetails
     * const userDetails = await prisma.userDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserDetailsFindFirstArgs>(args?: SelectSubset<T, UserDetailsFindFirstArgs<ExtArgs>>): Prisma__UserDetailsClient<$Result.GetResult<Prisma.$UserDetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDetailsFindFirstOrThrowArgs} args - Arguments to find a UserDetails
     * @example
     * // Get one UserDetails
     * const userDetails = await prisma.userDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserDetailsClient<$Result.GetResult<Prisma.$UserDetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserDetails
     * const userDetails = await prisma.userDetails.findMany()
     * 
     * // Get first 10 UserDetails
     * const userDetails = await prisma.userDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userDetailsWithIdOnly = await prisma.userDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserDetailsFindManyArgs>(args?: SelectSubset<T, UserDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserDetails.
     * @param {UserDetailsCreateArgs} args - Arguments to create a UserDetails.
     * @example
     * // Create one UserDetails
     * const UserDetails = await prisma.userDetails.create({
     *   data: {
     *     // ... data to create a UserDetails
     *   }
     * })
     * 
     */
    create<T extends UserDetailsCreateArgs>(args: SelectSubset<T, UserDetailsCreateArgs<ExtArgs>>): Prisma__UserDetailsClient<$Result.GetResult<Prisma.$UserDetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserDetails.
     * @param {UserDetailsCreateManyArgs} args - Arguments to create many UserDetails.
     * @example
     * // Create many UserDetails
     * const userDetails = await prisma.userDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserDetailsCreateManyArgs>(args?: SelectSubset<T, UserDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserDetails and returns the data saved in the database.
     * @param {UserDetailsCreateManyAndReturnArgs} args - Arguments to create many UserDetails.
     * @example
     * // Create many UserDetails
     * const userDetails = await prisma.userDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserDetails and only return the `id`
     * const userDetailsWithIdOnly = await prisma.userDetails.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDetailsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserDetails.
     * @param {UserDetailsDeleteArgs} args - Arguments to delete one UserDetails.
     * @example
     * // Delete one UserDetails
     * const UserDetails = await prisma.userDetails.delete({
     *   where: {
     *     // ... filter to delete one UserDetails
     *   }
     * })
     * 
     */
    delete<T extends UserDetailsDeleteArgs>(args: SelectSubset<T, UserDetailsDeleteArgs<ExtArgs>>): Prisma__UserDetailsClient<$Result.GetResult<Prisma.$UserDetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserDetails.
     * @param {UserDetailsUpdateArgs} args - Arguments to update one UserDetails.
     * @example
     * // Update one UserDetails
     * const userDetails = await prisma.userDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserDetailsUpdateArgs>(args: SelectSubset<T, UserDetailsUpdateArgs<ExtArgs>>): Prisma__UserDetailsClient<$Result.GetResult<Prisma.$UserDetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserDetails.
     * @param {UserDetailsDeleteManyArgs} args - Arguments to filter UserDetails to delete.
     * @example
     * // Delete a few UserDetails
     * const { count } = await prisma.userDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDetailsDeleteManyArgs>(args?: SelectSubset<T, UserDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserDetails
     * const userDetails = await prisma.userDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserDetailsUpdateManyArgs>(args: SelectSubset<T, UserDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserDetails and returns the data updated in the database.
     * @param {UserDetailsUpdateManyAndReturnArgs} args - Arguments to update many UserDetails.
     * @example
     * // Update many UserDetails
     * const userDetails = await prisma.userDetails.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserDetails and only return the `id`
     * const userDetailsWithIdOnly = await prisma.userDetails.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserDetailsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserDetailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDetailsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserDetails.
     * @param {UserDetailsUpsertArgs} args - Arguments to update or create a UserDetails.
     * @example
     * // Update or create a UserDetails
     * const userDetails = await prisma.userDetails.upsert({
     *   create: {
     *     // ... data to create a UserDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserDetails we want to update
     *   }
     * })
     */
    upsert<T extends UserDetailsUpsertArgs>(args: SelectSubset<T, UserDetailsUpsertArgs<ExtArgs>>): Prisma__UserDetailsClient<$Result.GetResult<Prisma.$UserDetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDetailsCountArgs} args - Arguments to filter UserDetails to count.
     * @example
     * // Count the number of UserDetails
     * const count = await prisma.userDetails.count({
     *   where: {
     *     // ... the filter for the UserDetails we want to count
     *   }
     * })
    **/
    count<T extends UserDetailsCountArgs>(
      args?: Subset<T, UserDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserDetailsAggregateArgs>(args: Subset<T, UserDetailsAggregateArgs>): Prisma.PrismaPromise<GetUserDetailsAggregateType<T>>

    /**
     * Group by UserDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserDetailsGroupByArgs['orderBy'] }
        : { orderBy?: UserDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserDetails model
   */
  readonly fields: UserDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    posts<T extends UserDetails$postsArgs<ExtArgs> = {}>(args?: Subset<T, UserDetails$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends UserDetails$commentsArgs<ExtArgs> = {}>(args?: Subset<T, UserDetails$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends UserDetails$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, UserDetails$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    interests<T extends UserDetails$interestsArgs<ExtArgs> = {}>(args?: Subset<T, UserDetails$interestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    matchesSent<T extends UserDetails$matchesSentArgs<ExtArgs> = {}>(args?: Subset<T, UserDetails$matchesSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    matchesReceived<T extends UserDetails$matchesReceivedArgs<ExtArgs> = {}>(args?: Subset<T, UserDetails$matchesReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    currentUserSimilarity<T extends UserDetails$currentUserSimilarityArgs<ExtArgs> = {}>(args?: Subset<T, UserDetails$currentUserSimilarityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSimilarityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    otherUserSimilarity<T extends UserDetails$otherUserSimilarityArgs<ExtArgs> = {}>(args?: Subset<T, UserDetails$otherUserSimilarityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSimilarityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    asEventAttendee<T extends UserDetails$asEventAttendeeArgs<ExtArgs> = {}>(args?: Subset<T, UserDetails$asEventAttendeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    asEventOrganizer<T extends UserDetails$asEventOrganizerArgs<ExtArgs> = {}>(args?: Subset<T, UserDetails$asEventOrganizerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    coffeeChatsSent<T extends UserDetails$coffeeChatsSentArgs<ExtArgs> = {}>(args?: Subset<T, UserDetails$coffeeChatsSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoffeeChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    coffeeChatsReceived<T extends UserDetails$coffeeChatsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, UserDetails$coffeeChatsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoffeeChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chatsAsUser1<T extends UserDetails$chatsAsUser1Args<ExtArgs> = {}>(args?: Subset<T, UserDetails$chatsAsUser1Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chatsAsUser2<T extends UserDetails$chatsAsUser2Args<ExtArgs> = {}>(args?: Subset<T, UserDetails$chatsAsUser2Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messagesSent<T extends UserDetails$messagesSentArgs<ExtArgs> = {}>(args?: Subset<T, UserDetails$messagesSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserDetails model
   */
  interface UserDetailsFieldRefs {
    readonly id: FieldRef<"UserDetails", 'String'>
    readonly userId: FieldRef<"UserDetails", 'String'>
    readonly name: FieldRef<"UserDetails", 'String'>
    readonly department: FieldRef<"UserDetails", 'String'>
    readonly year: FieldRef<"UserDetails", 'String'>
    readonly profilePicture: FieldRef<"UserDetails", 'String'>
    readonly bio: FieldRef<"UserDetails", 'String'>
    readonly availability: FieldRef<"UserDetails", 'String'>
    readonly reading: FieldRef<"UserDetails", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserDetails findUnique
   */
  export type UserDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetails
     */
    select?: UserDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDetails
     */
    omit?: UserDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDetailsInclude<ExtArgs> | null
    /**
     * Filter, which UserDetails to fetch.
     */
    where: UserDetailsWhereUniqueInput
  }

  /**
   * UserDetails findUniqueOrThrow
   */
  export type UserDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetails
     */
    select?: UserDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDetails
     */
    omit?: UserDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDetailsInclude<ExtArgs> | null
    /**
     * Filter, which UserDetails to fetch.
     */
    where: UserDetailsWhereUniqueInput
  }

  /**
   * UserDetails findFirst
   */
  export type UserDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetails
     */
    select?: UserDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDetails
     */
    omit?: UserDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDetailsInclude<ExtArgs> | null
    /**
     * Filter, which UserDetails to fetch.
     */
    where?: UserDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDetails to fetch.
     */
    orderBy?: UserDetailsOrderByWithRelationInput | UserDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserDetails.
     */
    cursor?: UserDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserDetails.
     */
    distinct?: UserDetailsScalarFieldEnum | UserDetailsScalarFieldEnum[]
  }

  /**
   * UserDetails findFirstOrThrow
   */
  export type UserDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetails
     */
    select?: UserDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDetails
     */
    omit?: UserDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDetailsInclude<ExtArgs> | null
    /**
     * Filter, which UserDetails to fetch.
     */
    where?: UserDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDetails to fetch.
     */
    orderBy?: UserDetailsOrderByWithRelationInput | UserDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserDetails.
     */
    cursor?: UserDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserDetails.
     */
    distinct?: UserDetailsScalarFieldEnum | UserDetailsScalarFieldEnum[]
  }

  /**
   * UserDetails findMany
   */
  export type UserDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetails
     */
    select?: UserDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDetails
     */
    omit?: UserDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDetailsInclude<ExtArgs> | null
    /**
     * Filter, which UserDetails to fetch.
     */
    where?: UserDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDetails to fetch.
     */
    orderBy?: UserDetailsOrderByWithRelationInput | UserDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserDetails.
     */
    cursor?: UserDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDetails.
     */
    skip?: number
    distinct?: UserDetailsScalarFieldEnum | UserDetailsScalarFieldEnum[]
  }

  /**
   * UserDetails create
   */
  export type UserDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetails
     */
    select?: UserDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDetails
     */
    omit?: UserDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserDetails.
     */
    data: XOR<UserDetailsCreateInput, UserDetailsUncheckedCreateInput>
  }

  /**
   * UserDetails createMany
   */
  export type UserDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserDetails.
     */
    data: UserDetailsCreateManyInput | UserDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserDetails createManyAndReturn
   */
  export type UserDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetails
     */
    select?: UserDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserDetails
     */
    omit?: UserDetailsOmit<ExtArgs> | null
    /**
     * The data used to create many UserDetails.
     */
    data: UserDetailsCreateManyInput | UserDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserDetails update
   */
  export type UserDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetails
     */
    select?: UserDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDetails
     */
    omit?: UserDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserDetails.
     */
    data: XOR<UserDetailsUpdateInput, UserDetailsUncheckedUpdateInput>
    /**
     * Choose, which UserDetails to update.
     */
    where: UserDetailsWhereUniqueInput
  }

  /**
   * UserDetails updateMany
   */
  export type UserDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserDetails.
     */
    data: XOR<UserDetailsUpdateManyMutationInput, UserDetailsUncheckedUpdateManyInput>
    /**
     * Filter which UserDetails to update
     */
    where?: UserDetailsWhereInput
    /**
     * Limit how many UserDetails to update.
     */
    limit?: number
  }

  /**
   * UserDetails updateManyAndReturn
   */
  export type UserDetailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetails
     */
    select?: UserDetailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserDetails
     */
    omit?: UserDetailsOmit<ExtArgs> | null
    /**
     * The data used to update UserDetails.
     */
    data: XOR<UserDetailsUpdateManyMutationInput, UserDetailsUncheckedUpdateManyInput>
    /**
     * Filter which UserDetails to update
     */
    where?: UserDetailsWhereInput
    /**
     * Limit how many UserDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDetailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserDetails upsert
   */
  export type UserDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetails
     */
    select?: UserDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDetails
     */
    omit?: UserDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserDetails to update in case it exists.
     */
    where: UserDetailsWhereUniqueInput
    /**
     * In case the UserDetails found by the `where` argument doesn't exist, create a new UserDetails with this data.
     */
    create: XOR<UserDetailsCreateInput, UserDetailsUncheckedCreateInput>
    /**
     * In case the UserDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserDetailsUpdateInput, UserDetailsUncheckedUpdateInput>
  }

  /**
   * UserDetails delete
   */
  export type UserDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetails
     */
    select?: UserDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDetails
     */
    omit?: UserDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDetailsInclude<ExtArgs> | null
    /**
     * Filter which UserDetails to delete.
     */
    where: UserDetailsWhereUniqueInput
  }

  /**
   * UserDetails deleteMany
   */
  export type UserDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserDetails to delete
     */
    where?: UserDetailsWhereInput
    /**
     * Limit how many UserDetails to delete.
     */
    limit?: number
  }

  /**
   * UserDetails.posts
   */
  export type UserDetails$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * UserDetails.comments
   */
  export type UserDetails$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * UserDetails.notifications
   */
  export type UserDetails$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * UserDetails.interests
   */
  export type UserDetails$interestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    where?: InterestWhereInput
    orderBy?: InterestOrderByWithRelationInput | InterestOrderByWithRelationInput[]
    cursor?: InterestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterestScalarFieldEnum | InterestScalarFieldEnum[]
  }

  /**
   * UserDetails.matchesSent
   */
  export type UserDetails$matchesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    cursor?: MatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * UserDetails.matchesReceived
   */
  export type UserDetails$matchesReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    cursor?: MatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * UserDetails.currentUserSimilarity
   */
  export type UserDetails$currentUserSimilarityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSimilarity
     */
    select?: UserSimilaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSimilarity
     */
    omit?: UserSimilarityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSimilarityInclude<ExtArgs> | null
    where?: UserSimilarityWhereInput
    orderBy?: UserSimilarityOrderByWithRelationInput | UserSimilarityOrderByWithRelationInput[]
    cursor?: UserSimilarityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSimilarityScalarFieldEnum | UserSimilarityScalarFieldEnum[]
  }

  /**
   * UserDetails.otherUserSimilarity
   */
  export type UserDetails$otherUserSimilarityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSimilarity
     */
    select?: UserSimilaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSimilarity
     */
    omit?: UserSimilarityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSimilarityInclude<ExtArgs> | null
    where?: UserSimilarityWhereInput
    orderBy?: UserSimilarityOrderByWithRelationInput | UserSimilarityOrderByWithRelationInput[]
    cursor?: UserSimilarityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSimilarityScalarFieldEnum | UserSimilarityScalarFieldEnum[]
  }

  /**
   * UserDetails.asEventAttendee
   */
  export type UserDetails$asEventAttendeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * UserDetails.asEventOrganizer
   */
  export type UserDetails$asEventOrganizerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * UserDetails.coffeeChatsSent
   */
  export type UserDetails$coffeeChatsSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChat
     */
    select?: CoffeeChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChat
     */
    omit?: CoffeeChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatInclude<ExtArgs> | null
    where?: CoffeeChatWhereInput
    orderBy?: CoffeeChatOrderByWithRelationInput | CoffeeChatOrderByWithRelationInput[]
    cursor?: CoffeeChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoffeeChatScalarFieldEnum | CoffeeChatScalarFieldEnum[]
  }

  /**
   * UserDetails.coffeeChatsReceived
   */
  export type UserDetails$coffeeChatsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChat
     */
    select?: CoffeeChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChat
     */
    omit?: CoffeeChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatInclude<ExtArgs> | null
    where?: CoffeeChatWhereInput
    orderBy?: CoffeeChatOrderByWithRelationInput | CoffeeChatOrderByWithRelationInput[]
    cursor?: CoffeeChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoffeeChatScalarFieldEnum | CoffeeChatScalarFieldEnum[]
  }

  /**
   * UserDetails.chatsAsUser1
   */
  export type UserDetails$chatsAsUser1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * UserDetails.chatsAsUser2
   */
  export type UserDetails$chatsAsUser2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * UserDetails.messagesSent
   */
  export type UserDetails$messagesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * UserDetails without action
   */
  export type UserDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetails
     */
    select?: UserDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDetails
     */
    omit?: UserDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDetailsInclude<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    commentCount: number | null
  }

  export type PostSumAggregateOutputType = {
    commentCount: number | null
  }

  export type PostMinAggregateOutputType = {
    id: string | null
    authorId: string | null
    content: string | null
    commentCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostMaxAggregateOutputType = {
    id: string | null
    authorId: string | null
    content: string | null
    commentCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    authorId: number
    content: number
    commentCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    commentCount?: true
  }

  export type PostSumAggregateInputType = {
    commentCount?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    authorId?: true
    content?: true
    commentCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    authorId?: true
    content?: true
    commentCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    authorId?: true
    content?: true
    commentCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: string
    authorId: string
    content: string
    commentCount: number
    createdAt: Date
    updatedAt: Date
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    content?: boolean
    commentCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDetailsDefaultArgs<ExtArgs>
    reaction?: boolean | Post$reactionArgs<ExtArgs>
    postTags?: boolean | Post$postTagsArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    content?: boolean
    commentCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    content?: boolean
    commentCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    authorId?: boolean
    content?: boolean
    commentCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "authorId" | "content" | "commentCount" | "createdAt" | "updatedAt", ExtArgs["result"]["post"]>
  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDetailsDefaultArgs<ExtArgs>
    reaction?: boolean | Post$reactionArgs<ExtArgs>
    postTags?: boolean | Post$postTagsArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }
  export type PostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      author: Prisma.$UserDetailsPayload<ExtArgs>
      reaction: Prisma.$ReactionPayload<ExtArgs> | null
      postTags: Prisma.$PostTagPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      authorId: string
      content: string
      commentCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts and returns the data updated in the database.
     * @param {PostUpdateManyAndReturnArgs} args - Arguments to update many Posts.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostUpdateManyAndReturnArgs>(args: SelectSubset<T, PostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDetailsDefaultArgs<ExtArgs>>): Prisma__UserDetailsClient<$Result.GetResult<Prisma.$UserDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reaction<T extends Post$reactionArgs<ExtArgs> = {}>(args?: Subset<T, Post$reactionArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    postTags<T extends Post$postTagsArgs<ExtArgs> = {}>(args?: Subset<T, Post$postTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Post$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Post$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'String'>
    readonly authorId: FieldRef<"Post", 'String'>
    readonly content: FieldRef<"Post", 'String'>
    readonly commentCount: FieldRef<"Post", 'Int'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
    readonly updatedAt: FieldRef<"Post", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Post createManyAndReturn
   */
  export type PostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
  }

  /**
   * Post updateManyAndReturn
   */
  export type PostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to delete.
     */
    limit?: number
  }

  /**
   * Post.reaction
   */
  export type Post$reactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    where?: ReactionWhereInput
  }

  /**
   * Post.postTags
   */
  export type Post$postTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    where?: PostTagWhereInput
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    cursor?: PostTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostTagScalarFieldEnum | PostTagScalarFieldEnum[]
  }

  /**
   * Post.comments
   */
  export type Post$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model Reaction
   */

  export type AggregateReaction = {
    _count: ReactionCountAggregateOutputType | null
    _avg: ReactionAvgAggregateOutputType | null
    _sum: ReactionSumAggregateOutputType | null
    _min: ReactionMinAggregateOutputType | null
    _max: ReactionMaxAggregateOutputType | null
  }

  export type ReactionAvgAggregateOutputType = {
    likes: number | null
  }

  export type ReactionSumAggregateOutputType = {
    likes: number | null
  }

  export type ReactionMinAggregateOutputType = {
    id: string | null
    postId: string | null
    likes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReactionMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    likes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReactionCountAggregateOutputType = {
    id: number
    postId: number
    likes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReactionAvgAggregateInputType = {
    likes?: true
  }

  export type ReactionSumAggregateInputType = {
    likes?: true
  }

  export type ReactionMinAggregateInputType = {
    id?: true
    postId?: true
    likes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReactionMaxAggregateInputType = {
    id?: true
    postId?: true
    likes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReactionCountAggregateInputType = {
    id?: true
    postId?: true
    likes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reaction to aggregate.
     */
    where?: ReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reactions to fetch.
     */
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reactions
    **/
    _count?: true | ReactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReactionMaxAggregateInputType
  }

  export type GetReactionAggregateType<T extends ReactionAggregateArgs> = {
        [P in keyof T & keyof AggregateReaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReaction[P]>
      : GetScalarType<T[P], AggregateReaction[P]>
  }




  export type ReactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReactionWhereInput
    orderBy?: ReactionOrderByWithAggregationInput | ReactionOrderByWithAggregationInput[]
    by: ReactionScalarFieldEnum[] | ReactionScalarFieldEnum
    having?: ReactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReactionCountAggregateInputType | true
    _avg?: ReactionAvgAggregateInputType
    _sum?: ReactionSumAggregateInputType
    _min?: ReactionMinAggregateInputType
    _max?: ReactionMaxAggregateInputType
  }

  export type ReactionGroupByOutputType = {
    id: string
    postId: string
    likes: number
    createdAt: Date
    updatedAt: Date
    _count: ReactionCountAggregateOutputType | null
    _avg: ReactionAvgAggregateOutputType | null
    _sum: ReactionSumAggregateOutputType | null
    _min: ReactionMinAggregateOutputType | null
    _max: ReactionMaxAggregateOutputType | null
  }

  type GetReactionGroupByPayload<T extends ReactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReactionGroupByOutputType[P]>
            : GetScalarType<T[P], ReactionGroupByOutputType[P]>
        }
      >
    >


  export type ReactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    likes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reaction"]>

  export type ReactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    likes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reaction"]>

  export type ReactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    likes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reaction"]>

  export type ReactionSelectScalar = {
    id?: boolean
    postId?: boolean
    likes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "likes" | "createdAt" | "updatedAt", ExtArgs["result"]["reaction"]>
  export type ReactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type ReactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type ReactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }

  export type $ReactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reaction"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      likes: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reaction"]>
    composites: {}
  }

  type ReactionGetPayload<S extends boolean | null | undefined | ReactionDefaultArgs> = $Result.GetResult<Prisma.$ReactionPayload, S>

  type ReactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReactionCountAggregateInputType | true
    }

  export interface ReactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reaction'], meta: { name: 'Reaction' } }
    /**
     * Find zero or one Reaction that matches the filter.
     * @param {ReactionFindUniqueArgs} args - Arguments to find a Reaction
     * @example
     * // Get one Reaction
     * const reaction = await prisma.reaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReactionFindUniqueArgs>(args: SelectSubset<T, ReactionFindUniqueArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReactionFindUniqueOrThrowArgs} args - Arguments to find a Reaction
     * @example
     * // Get one Reaction
     * const reaction = await prisma.reaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReactionFindUniqueOrThrowArgs>(args: SelectSubset<T, ReactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionFindFirstArgs} args - Arguments to find a Reaction
     * @example
     * // Get one Reaction
     * const reaction = await prisma.reaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReactionFindFirstArgs>(args?: SelectSubset<T, ReactionFindFirstArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionFindFirstOrThrowArgs} args - Arguments to find a Reaction
     * @example
     * // Get one Reaction
     * const reaction = await prisma.reaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReactionFindFirstOrThrowArgs>(args?: SelectSubset<T, ReactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reactions
     * const reactions = await prisma.reaction.findMany()
     * 
     * // Get first 10 Reactions
     * const reactions = await prisma.reaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reactionWithIdOnly = await prisma.reaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReactionFindManyArgs>(args?: SelectSubset<T, ReactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reaction.
     * @param {ReactionCreateArgs} args - Arguments to create a Reaction.
     * @example
     * // Create one Reaction
     * const Reaction = await prisma.reaction.create({
     *   data: {
     *     // ... data to create a Reaction
     *   }
     * })
     * 
     */
    create<T extends ReactionCreateArgs>(args: SelectSubset<T, ReactionCreateArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reactions.
     * @param {ReactionCreateManyArgs} args - Arguments to create many Reactions.
     * @example
     * // Create many Reactions
     * const reaction = await prisma.reaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReactionCreateManyArgs>(args?: SelectSubset<T, ReactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reactions and returns the data saved in the database.
     * @param {ReactionCreateManyAndReturnArgs} args - Arguments to create many Reactions.
     * @example
     * // Create many Reactions
     * const reaction = await prisma.reaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reactions and only return the `id`
     * const reactionWithIdOnly = await prisma.reaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReactionCreateManyAndReturnArgs>(args?: SelectSubset<T, ReactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reaction.
     * @param {ReactionDeleteArgs} args - Arguments to delete one Reaction.
     * @example
     * // Delete one Reaction
     * const Reaction = await prisma.reaction.delete({
     *   where: {
     *     // ... filter to delete one Reaction
     *   }
     * })
     * 
     */
    delete<T extends ReactionDeleteArgs>(args: SelectSubset<T, ReactionDeleteArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reaction.
     * @param {ReactionUpdateArgs} args - Arguments to update one Reaction.
     * @example
     * // Update one Reaction
     * const reaction = await prisma.reaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReactionUpdateArgs>(args: SelectSubset<T, ReactionUpdateArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reactions.
     * @param {ReactionDeleteManyArgs} args - Arguments to filter Reactions to delete.
     * @example
     * // Delete a few Reactions
     * const { count } = await prisma.reaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReactionDeleteManyArgs>(args?: SelectSubset<T, ReactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reactions
     * const reaction = await prisma.reaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReactionUpdateManyArgs>(args: SelectSubset<T, ReactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reactions and returns the data updated in the database.
     * @param {ReactionUpdateManyAndReturnArgs} args - Arguments to update many Reactions.
     * @example
     * // Update many Reactions
     * const reaction = await prisma.reaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reactions and only return the `id`
     * const reactionWithIdOnly = await prisma.reaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReactionUpdateManyAndReturnArgs>(args: SelectSubset<T, ReactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reaction.
     * @param {ReactionUpsertArgs} args - Arguments to update or create a Reaction.
     * @example
     * // Update or create a Reaction
     * const reaction = await prisma.reaction.upsert({
     *   create: {
     *     // ... data to create a Reaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reaction we want to update
     *   }
     * })
     */
    upsert<T extends ReactionUpsertArgs>(args: SelectSubset<T, ReactionUpsertArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionCountArgs} args - Arguments to filter Reactions to count.
     * @example
     * // Count the number of Reactions
     * const count = await prisma.reaction.count({
     *   where: {
     *     // ... the filter for the Reactions we want to count
     *   }
     * })
    **/
    count<T extends ReactionCountArgs>(
      args?: Subset<T, ReactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReactionAggregateArgs>(args: Subset<T, ReactionAggregateArgs>): Prisma.PrismaPromise<GetReactionAggregateType<T>>

    /**
     * Group by Reaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReactionGroupByArgs['orderBy'] }
        : { orderBy?: ReactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reaction model
   */
  readonly fields: ReactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reaction model
   */
  interface ReactionFieldRefs {
    readonly id: FieldRef<"Reaction", 'String'>
    readonly postId: FieldRef<"Reaction", 'String'>
    readonly likes: FieldRef<"Reaction", 'Int'>
    readonly createdAt: FieldRef<"Reaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Reaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reaction findUnique
   */
  export type ReactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reaction to fetch.
     */
    where: ReactionWhereUniqueInput
  }

  /**
   * Reaction findUniqueOrThrow
   */
  export type ReactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reaction to fetch.
     */
    where: ReactionWhereUniqueInput
  }

  /**
   * Reaction findFirst
   */
  export type ReactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reaction to fetch.
     */
    where?: ReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reactions to fetch.
     */
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reactions.
     */
    cursor?: ReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reactions.
     */
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * Reaction findFirstOrThrow
   */
  export type ReactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reaction to fetch.
     */
    where?: ReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reactions to fetch.
     */
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reactions.
     */
    cursor?: ReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reactions.
     */
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * Reaction findMany
   */
  export type ReactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reactions to fetch.
     */
    where?: ReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reactions to fetch.
     */
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reactions.
     */
    cursor?: ReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reactions.
     */
    skip?: number
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * Reaction create
   */
  export type ReactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Reaction.
     */
    data: XOR<ReactionCreateInput, ReactionUncheckedCreateInput>
  }

  /**
   * Reaction createMany
   */
  export type ReactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reactions.
     */
    data: ReactionCreateManyInput | ReactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reaction createManyAndReturn
   */
  export type ReactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * The data used to create many Reactions.
     */
    data: ReactionCreateManyInput | ReactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reaction update
   */
  export type ReactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Reaction.
     */
    data: XOR<ReactionUpdateInput, ReactionUncheckedUpdateInput>
    /**
     * Choose, which Reaction to update.
     */
    where: ReactionWhereUniqueInput
  }

  /**
   * Reaction updateMany
   */
  export type ReactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reactions.
     */
    data: XOR<ReactionUpdateManyMutationInput, ReactionUncheckedUpdateManyInput>
    /**
     * Filter which Reactions to update
     */
    where?: ReactionWhereInput
    /**
     * Limit how many Reactions to update.
     */
    limit?: number
  }

  /**
   * Reaction updateManyAndReturn
   */
  export type ReactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * The data used to update Reactions.
     */
    data: XOR<ReactionUpdateManyMutationInput, ReactionUncheckedUpdateManyInput>
    /**
     * Filter which Reactions to update
     */
    where?: ReactionWhereInput
    /**
     * Limit how many Reactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reaction upsert
   */
  export type ReactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Reaction to update in case it exists.
     */
    where: ReactionWhereUniqueInput
    /**
     * In case the Reaction found by the `where` argument doesn't exist, create a new Reaction with this data.
     */
    create: XOR<ReactionCreateInput, ReactionUncheckedCreateInput>
    /**
     * In case the Reaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReactionUpdateInput, ReactionUncheckedUpdateInput>
  }

  /**
   * Reaction delete
   */
  export type ReactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter which Reaction to delete.
     */
    where: ReactionWhereUniqueInput
  }

  /**
   * Reaction deleteMany
   */
  export type ReactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reactions to delete
     */
    where?: ReactionWhereInput
    /**
     * Limit how many Reactions to delete.
     */
    limit?: number
  }

  /**
   * Reaction without action
   */
  export type ReactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    postId: string | null
    authorId: string | null
    commentContent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    authorId: string | null
    commentContent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    postId: number
    authorId: number
    commentContent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
    commentContent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
    commentContent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
    commentContent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    postId: string
    authorId: string
    commentContent: string
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    authorId?: boolean
    commentContent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    authorId?: boolean
    commentContent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    authorId?: boolean
    commentContent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    postId?: boolean
    authorId?: boolean
    commentContent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "authorId" | "commentContent" | "createdAt" | "updatedAt", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      author: Prisma.$UserDetailsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      authorId: string
      commentContent: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends UserDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDetailsDefaultArgs<ExtArgs>>): Prisma__UserDetailsClient<$Result.GetResult<Prisma.$UserDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly postId: FieldRef<"Comment", 'String'>
    readonly authorId: FieldRef<"Comment", 'String'>
    readonly commentContent: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model PostTag
   */

  export type AggregatePostTag = {
    _count: PostTagCountAggregateOutputType | null
    _min: PostTagMinAggregateOutputType | null
    _max: PostTagMaxAggregateOutputType | null
  }

  export type PostTagMinAggregateOutputType = {
    id: string | null
    tagName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostTagMaxAggregateOutputType = {
    id: string | null
    tagName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostTagCountAggregateOutputType = {
    id: number
    tagName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PostTagMinAggregateInputType = {
    id?: true
    tagName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostTagMaxAggregateInputType = {
    id?: true
    tagName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostTagCountAggregateInputType = {
    id?: true
    tagName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PostTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostTag to aggregate.
     */
    where?: PostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTags to fetch.
     */
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostTags
    **/
    _count?: true | PostTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostTagMaxAggregateInputType
  }

  export type GetPostTagAggregateType<T extends PostTagAggregateArgs> = {
        [P in keyof T & keyof AggregatePostTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostTag[P]>
      : GetScalarType<T[P], AggregatePostTag[P]>
  }




  export type PostTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostTagWhereInput
    orderBy?: PostTagOrderByWithAggregationInput | PostTagOrderByWithAggregationInput[]
    by: PostTagScalarFieldEnum[] | PostTagScalarFieldEnum
    having?: PostTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostTagCountAggregateInputType | true
    _min?: PostTagMinAggregateInputType
    _max?: PostTagMaxAggregateInputType
  }

  export type PostTagGroupByOutputType = {
    id: string
    tagName: string
    createdAt: Date
    updatedAt: Date
    _count: PostTagCountAggregateOutputType | null
    _min: PostTagMinAggregateOutputType | null
    _max: PostTagMaxAggregateOutputType | null
  }

  type GetPostTagGroupByPayload<T extends PostTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostTagGroupByOutputType[P]>
            : GetScalarType<T[P], PostTagGroupByOutputType[P]>
        }
      >
    >


  export type PostTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tagName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posts?: boolean | PostTag$postsArgs<ExtArgs>
    _count?: boolean | PostTagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postTag"]>

  export type PostTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tagName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["postTag"]>

  export type PostTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tagName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["postTag"]>

  export type PostTagSelectScalar = {
    id?: boolean
    tagName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PostTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tagName" | "createdAt" | "updatedAt", ExtArgs["result"]["postTag"]>
  export type PostTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | PostTag$postsArgs<ExtArgs>
    _count?: boolean | PostTagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PostTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PostTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PostTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostTag"
    objects: {
      posts: Prisma.$PostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tagName: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["postTag"]>
    composites: {}
  }

  type PostTagGetPayload<S extends boolean | null | undefined | PostTagDefaultArgs> = $Result.GetResult<Prisma.$PostTagPayload, S>

  type PostTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostTagCountAggregateInputType | true
    }

  export interface PostTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostTag'], meta: { name: 'PostTag' } }
    /**
     * Find zero or one PostTag that matches the filter.
     * @param {PostTagFindUniqueArgs} args - Arguments to find a PostTag
     * @example
     * // Get one PostTag
     * const postTag = await prisma.postTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostTagFindUniqueArgs>(args: SelectSubset<T, PostTagFindUniqueArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostTagFindUniqueOrThrowArgs} args - Arguments to find a PostTag
     * @example
     * // Get one PostTag
     * const postTag = await prisma.postTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostTagFindUniqueOrThrowArgs>(args: SelectSubset<T, PostTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagFindFirstArgs} args - Arguments to find a PostTag
     * @example
     * // Get one PostTag
     * const postTag = await prisma.postTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostTagFindFirstArgs>(args?: SelectSubset<T, PostTagFindFirstArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagFindFirstOrThrowArgs} args - Arguments to find a PostTag
     * @example
     * // Get one PostTag
     * const postTag = await prisma.postTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostTagFindFirstOrThrowArgs>(args?: SelectSubset<T, PostTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostTags
     * const postTags = await prisma.postTag.findMany()
     * 
     * // Get first 10 PostTags
     * const postTags = await prisma.postTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postTagWithIdOnly = await prisma.postTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostTagFindManyArgs>(args?: SelectSubset<T, PostTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostTag.
     * @param {PostTagCreateArgs} args - Arguments to create a PostTag.
     * @example
     * // Create one PostTag
     * const PostTag = await prisma.postTag.create({
     *   data: {
     *     // ... data to create a PostTag
     *   }
     * })
     * 
     */
    create<T extends PostTagCreateArgs>(args: SelectSubset<T, PostTagCreateArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostTags.
     * @param {PostTagCreateManyArgs} args - Arguments to create many PostTags.
     * @example
     * // Create many PostTags
     * const postTag = await prisma.postTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostTagCreateManyArgs>(args?: SelectSubset<T, PostTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostTags and returns the data saved in the database.
     * @param {PostTagCreateManyAndReturnArgs} args - Arguments to create many PostTags.
     * @example
     * // Create many PostTags
     * const postTag = await prisma.postTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostTags and only return the `id`
     * const postTagWithIdOnly = await prisma.postTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostTagCreateManyAndReturnArgs>(args?: SelectSubset<T, PostTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PostTag.
     * @param {PostTagDeleteArgs} args - Arguments to delete one PostTag.
     * @example
     * // Delete one PostTag
     * const PostTag = await prisma.postTag.delete({
     *   where: {
     *     // ... filter to delete one PostTag
     *   }
     * })
     * 
     */
    delete<T extends PostTagDeleteArgs>(args: SelectSubset<T, PostTagDeleteArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostTag.
     * @param {PostTagUpdateArgs} args - Arguments to update one PostTag.
     * @example
     * // Update one PostTag
     * const postTag = await prisma.postTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostTagUpdateArgs>(args: SelectSubset<T, PostTagUpdateArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostTags.
     * @param {PostTagDeleteManyArgs} args - Arguments to filter PostTags to delete.
     * @example
     * // Delete a few PostTags
     * const { count } = await prisma.postTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostTagDeleteManyArgs>(args?: SelectSubset<T, PostTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostTags
     * const postTag = await prisma.postTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostTagUpdateManyArgs>(args: SelectSubset<T, PostTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostTags and returns the data updated in the database.
     * @param {PostTagUpdateManyAndReturnArgs} args - Arguments to update many PostTags.
     * @example
     * // Update many PostTags
     * const postTag = await prisma.postTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PostTags and only return the `id`
     * const postTagWithIdOnly = await prisma.postTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostTagUpdateManyAndReturnArgs>(args: SelectSubset<T, PostTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PostTag.
     * @param {PostTagUpsertArgs} args - Arguments to update or create a PostTag.
     * @example
     * // Update or create a PostTag
     * const postTag = await prisma.postTag.upsert({
     *   create: {
     *     // ... data to create a PostTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostTag we want to update
     *   }
     * })
     */
    upsert<T extends PostTagUpsertArgs>(args: SelectSubset<T, PostTagUpsertArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagCountArgs} args - Arguments to filter PostTags to count.
     * @example
     * // Count the number of PostTags
     * const count = await prisma.postTag.count({
     *   where: {
     *     // ... the filter for the PostTags we want to count
     *   }
     * })
    **/
    count<T extends PostTagCountArgs>(
      args?: Subset<T, PostTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostTagAggregateArgs>(args: Subset<T, PostTagAggregateArgs>): Prisma.PrismaPromise<GetPostTagAggregateType<T>>

    /**
     * Group by PostTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostTagGroupByArgs['orderBy'] }
        : { orderBy?: PostTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostTag model
   */
  readonly fields: PostTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends PostTag$postsArgs<ExtArgs> = {}>(args?: Subset<T, PostTag$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostTag model
   */
  interface PostTagFieldRefs {
    readonly id: FieldRef<"PostTag", 'String'>
    readonly tagName: FieldRef<"PostTag", 'String'>
    readonly createdAt: FieldRef<"PostTag", 'DateTime'>
    readonly updatedAt: FieldRef<"PostTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostTag findUnique
   */
  export type PostTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTag to fetch.
     */
    where: PostTagWhereUniqueInput
  }

  /**
   * PostTag findUniqueOrThrow
   */
  export type PostTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTag to fetch.
     */
    where: PostTagWhereUniqueInput
  }

  /**
   * PostTag findFirst
   */
  export type PostTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTag to fetch.
     */
    where?: PostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTags to fetch.
     */
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostTags.
     */
    cursor?: PostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostTags.
     */
    distinct?: PostTagScalarFieldEnum | PostTagScalarFieldEnum[]
  }

  /**
   * PostTag findFirstOrThrow
   */
  export type PostTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTag to fetch.
     */
    where?: PostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTags to fetch.
     */
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostTags.
     */
    cursor?: PostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostTags.
     */
    distinct?: PostTagScalarFieldEnum | PostTagScalarFieldEnum[]
  }

  /**
   * PostTag findMany
   */
  export type PostTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTags to fetch.
     */
    where?: PostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTags to fetch.
     */
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostTags.
     */
    cursor?: PostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTags.
     */
    skip?: number
    distinct?: PostTagScalarFieldEnum | PostTagScalarFieldEnum[]
  }

  /**
   * PostTag create
   */
  export type PostTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * The data needed to create a PostTag.
     */
    data: XOR<PostTagCreateInput, PostTagUncheckedCreateInput>
  }

  /**
   * PostTag createMany
   */
  export type PostTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostTags.
     */
    data: PostTagCreateManyInput | PostTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostTag createManyAndReturn
   */
  export type PostTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * The data used to create many PostTags.
     */
    data: PostTagCreateManyInput | PostTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostTag update
   */
  export type PostTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * The data needed to update a PostTag.
     */
    data: XOR<PostTagUpdateInput, PostTagUncheckedUpdateInput>
    /**
     * Choose, which PostTag to update.
     */
    where: PostTagWhereUniqueInput
  }

  /**
   * PostTag updateMany
   */
  export type PostTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostTags.
     */
    data: XOR<PostTagUpdateManyMutationInput, PostTagUncheckedUpdateManyInput>
    /**
     * Filter which PostTags to update
     */
    where?: PostTagWhereInput
    /**
     * Limit how many PostTags to update.
     */
    limit?: number
  }

  /**
   * PostTag updateManyAndReturn
   */
  export type PostTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * The data used to update PostTags.
     */
    data: XOR<PostTagUpdateManyMutationInput, PostTagUncheckedUpdateManyInput>
    /**
     * Filter which PostTags to update
     */
    where?: PostTagWhereInput
    /**
     * Limit how many PostTags to update.
     */
    limit?: number
  }

  /**
   * PostTag upsert
   */
  export type PostTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * The filter to search for the PostTag to update in case it exists.
     */
    where: PostTagWhereUniqueInput
    /**
     * In case the PostTag found by the `where` argument doesn't exist, create a new PostTag with this data.
     */
    create: XOR<PostTagCreateInput, PostTagUncheckedCreateInput>
    /**
     * In case the PostTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostTagUpdateInput, PostTagUncheckedUpdateInput>
  }

  /**
   * PostTag delete
   */
  export type PostTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter which PostTag to delete.
     */
    where: PostTagWhereUniqueInput
  }

  /**
   * PostTag deleteMany
   */
  export type PostTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostTags to delete
     */
    where?: PostTagWhereInput
    /**
     * Limit how many PostTags to delete.
     */
    limit?: number
  }

  /**
   * PostTag.posts
   */
  export type PostTag$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * PostTag without action
   */
  export type PostTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userDetailsId: string | null
    notificationType: $Enums.NotificationType | null
    notificationData: string | null
    read: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userDetailsId: string | null
    notificationType: $Enums.NotificationType | null
    notificationData: string | null
    read: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userDetailsId: number
    notificationType: number
    notificationData: number
    read: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userDetailsId?: true
    notificationType?: true
    notificationData?: true
    read?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userDetailsId?: true
    notificationType?: true
    notificationData?: true
    read?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userDetailsId?: true
    notificationType?: true
    notificationData?: true
    read?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userDetailsId: string
    notificationType: $Enums.NotificationType
    notificationData: string
    read: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userDetailsId?: boolean
    notificationType?: boolean
    notificationData?: boolean
    read?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userDetails?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userDetailsId?: boolean
    notificationType?: boolean
    notificationData?: boolean
    read?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userDetails?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userDetailsId?: boolean
    notificationType?: boolean
    notificationData?: boolean
    read?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userDetails?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userDetailsId?: boolean
    notificationType?: boolean
    notificationData?: boolean
    read?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userDetailsId" | "notificationType" | "notificationData" | "read" | "createdAt" | "updatedAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userDetails?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userDetails?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userDetails?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      userDetails: Prisma.$UserDetailsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userDetailsId: string
      notificationType: $Enums.NotificationType
      notificationData: string
      read: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userDetails<T extends UserDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDetailsDefaultArgs<ExtArgs>>): Prisma__UserDetailsClient<$Result.GetResult<Prisma.$UserDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userDetailsId: FieldRef<"Notification", 'String'>
    readonly notificationType: FieldRef<"Notification", 'NotificationType'>
    readonly notificationData: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Interest
   */

  export type AggregateInterest = {
    _count: InterestCountAggregateOutputType | null
    _min: InterestMinAggregateOutputType | null
    _max: InterestMaxAggregateOutputType | null
  }

  export type InterestMinAggregateOutputType = {
    id: string | null
    interestName: string | null
  }

  export type InterestMaxAggregateOutputType = {
    id: string | null
    interestName: string | null
  }

  export type InterestCountAggregateOutputType = {
    id: number
    interestName: number
    _all: number
  }


  export type InterestMinAggregateInputType = {
    id?: true
    interestName?: true
  }

  export type InterestMaxAggregateInputType = {
    id?: true
    interestName?: true
  }

  export type InterestCountAggregateInputType = {
    id?: true
    interestName?: true
    _all?: true
  }

  export type InterestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interest to aggregate.
     */
    where?: InterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interests to fetch.
     */
    orderBy?: InterestOrderByWithRelationInput | InterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Interests
    **/
    _count?: true | InterestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterestMaxAggregateInputType
  }

  export type GetInterestAggregateType<T extends InterestAggregateArgs> = {
        [P in keyof T & keyof AggregateInterest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterest[P]>
      : GetScalarType<T[P], AggregateInterest[P]>
  }




  export type InterestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterestWhereInput
    orderBy?: InterestOrderByWithAggregationInput | InterestOrderByWithAggregationInput[]
    by: InterestScalarFieldEnum[] | InterestScalarFieldEnum
    having?: InterestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterestCountAggregateInputType | true
    _min?: InterestMinAggregateInputType
    _max?: InterestMaxAggregateInputType
  }

  export type InterestGroupByOutputType = {
    id: string
    interestName: string
    _count: InterestCountAggregateOutputType | null
    _min: InterestMinAggregateOutputType | null
    _max: InterestMaxAggregateOutputType | null
  }

  type GetInterestGroupByPayload<T extends InterestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterestGroupByOutputType[P]>
            : GetScalarType<T[P], InterestGroupByOutputType[P]>
        }
      >
    >


  export type InterestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interestName?: boolean
    userDetails?: boolean | Interest$userDetailsArgs<ExtArgs>
    _count?: boolean | InterestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interest"]>

  export type InterestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interestName?: boolean
  }, ExtArgs["result"]["interest"]>

  export type InterestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interestName?: boolean
  }, ExtArgs["result"]["interest"]>

  export type InterestSelectScalar = {
    id?: boolean
    interestName?: boolean
  }

  export type InterestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "interestName", ExtArgs["result"]["interest"]>
  export type InterestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userDetails?: boolean | Interest$userDetailsArgs<ExtArgs>
    _count?: boolean | InterestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InterestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type InterestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InterestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Interest"
    objects: {
      userDetails: Prisma.$UserDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      interestName: string
    }, ExtArgs["result"]["interest"]>
    composites: {}
  }

  type InterestGetPayload<S extends boolean | null | undefined | InterestDefaultArgs> = $Result.GetResult<Prisma.$InterestPayload, S>

  type InterestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InterestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InterestCountAggregateInputType | true
    }

  export interface InterestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Interest'], meta: { name: 'Interest' } }
    /**
     * Find zero or one Interest that matches the filter.
     * @param {InterestFindUniqueArgs} args - Arguments to find a Interest
     * @example
     * // Get one Interest
     * const interest = await prisma.interest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterestFindUniqueArgs>(args: SelectSubset<T, InterestFindUniqueArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Interest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InterestFindUniqueOrThrowArgs} args - Arguments to find a Interest
     * @example
     * // Get one Interest
     * const interest = await prisma.interest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterestFindUniqueOrThrowArgs>(args: SelectSubset<T, InterestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Interest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestFindFirstArgs} args - Arguments to find a Interest
     * @example
     * // Get one Interest
     * const interest = await prisma.interest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterestFindFirstArgs>(args?: SelectSubset<T, InterestFindFirstArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Interest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestFindFirstOrThrowArgs} args - Arguments to find a Interest
     * @example
     * // Get one Interest
     * const interest = await prisma.interest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterestFindFirstOrThrowArgs>(args?: SelectSubset<T, InterestFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Interests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Interests
     * const interests = await prisma.interest.findMany()
     * 
     * // Get first 10 Interests
     * const interests = await prisma.interest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interestWithIdOnly = await prisma.interest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterestFindManyArgs>(args?: SelectSubset<T, InterestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Interest.
     * @param {InterestCreateArgs} args - Arguments to create a Interest.
     * @example
     * // Create one Interest
     * const Interest = await prisma.interest.create({
     *   data: {
     *     // ... data to create a Interest
     *   }
     * })
     * 
     */
    create<T extends InterestCreateArgs>(args: SelectSubset<T, InterestCreateArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Interests.
     * @param {InterestCreateManyArgs} args - Arguments to create many Interests.
     * @example
     * // Create many Interests
     * const interest = await prisma.interest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterestCreateManyArgs>(args?: SelectSubset<T, InterestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Interests and returns the data saved in the database.
     * @param {InterestCreateManyAndReturnArgs} args - Arguments to create many Interests.
     * @example
     * // Create many Interests
     * const interest = await prisma.interest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Interests and only return the `id`
     * const interestWithIdOnly = await prisma.interest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterestCreateManyAndReturnArgs>(args?: SelectSubset<T, InterestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Interest.
     * @param {InterestDeleteArgs} args - Arguments to delete one Interest.
     * @example
     * // Delete one Interest
     * const Interest = await prisma.interest.delete({
     *   where: {
     *     // ... filter to delete one Interest
     *   }
     * })
     * 
     */
    delete<T extends InterestDeleteArgs>(args: SelectSubset<T, InterestDeleteArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Interest.
     * @param {InterestUpdateArgs} args - Arguments to update one Interest.
     * @example
     * // Update one Interest
     * const interest = await prisma.interest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterestUpdateArgs>(args: SelectSubset<T, InterestUpdateArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Interests.
     * @param {InterestDeleteManyArgs} args - Arguments to filter Interests to delete.
     * @example
     * // Delete a few Interests
     * const { count } = await prisma.interest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterestDeleteManyArgs>(args?: SelectSubset<T, InterestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Interests
     * const interest = await prisma.interest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterestUpdateManyArgs>(args: SelectSubset<T, InterestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interests and returns the data updated in the database.
     * @param {InterestUpdateManyAndReturnArgs} args - Arguments to update many Interests.
     * @example
     * // Update many Interests
     * const interest = await prisma.interest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Interests and only return the `id`
     * const interestWithIdOnly = await prisma.interest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InterestUpdateManyAndReturnArgs>(args: SelectSubset<T, InterestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Interest.
     * @param {InterestUpsertArgs} args - Arguments to update or create a Interest.
     * @example
     * // Update or create a Interest
     * const interest = await prisma.interest.upsert({
     *   create: {
     *     // ... data to create a Interest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Interest we want to update
     *   }
     * })
     */
    upsert<T extends InterestUpsertArgs>(args: SelectSubset<T, InterestUpsertArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Interests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestCountArgs} args - Arguments to filter Interests to count.
     * @example
     * // Count the number of Interests
     * const count = await prisma.interest.count({
     *   where: {
     *     // ... the filter for the Interests we want to count
     *   }
     * })
    **/
    count<T extends InterestCountArgs>(
      args?: Subset<T, InterestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Interest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterestAggregateArgs>(args: Subset<T, InterestAggregateArgs>): Prisma.PrismaPromise<GetInterestAggregateType<T>>

    /**
     * Group by Interest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterestGroupByArgs['orderBy'] }
        : { orderBy?: InterestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Interest model
   */
  readonly fields: InterestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Interest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userDetails<T extends Interest$userDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Interest$userDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Interest model
   */
  interface InterestFieldRefs {
    readonly id: FieldRef<"Interest", 'String'>
    readonly interestName: FieldRef<"Interest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Interest findUnique
   */
  export type InterestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter, which Interest to fetch.
     */
    where: InterestWhereUniqueInput
  }

  /**
   * Interest findUniqueOrThrow
   */
  export type InterestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter, which Interest to fetch.
     */
    where: InterestWhereUniqueInput
  }

  /**
   * Interest findFirst
   */
  export type InterestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter, which Interest to fetch.
     */
    where?: InterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interests to fetch.
     */
    orderBy?: InterestOrderByWithRelationInput | InterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interests.
     */
    cursor?: InterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interests.
     */
    distinct?: InterestScalarFieldEnum | InterestScalarFieldEnum[]
  }

  /**
   * Interest findFirstOrThrow
   */
  export type InterestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter, which Interest to fetch.
     */
    where?: InterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interests to fetch.
     */
    orderBy?: InterestOrderByWithRelationInput | InterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interests.
     */
    cursor?: InterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interests.
     */
    distinct?: InterestScalarFieldEnum | InterestScalarFieldEnum[]
  }

  /**
   * Interest findMany
   */
  export type InterestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter, which Interests to fetch.
     */
    where?: InterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interests to fetch.
     */
    orderBy?: InterestOrderByWithRelationInput | InterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Interests.
     */
    cursor?: InterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interests.
     */
    skip?: number
    distinct?: InterestScalarFieldEnum | InterestScalarFieldEnum[]
  }

  /**
   * Interest create
   */
  export type InterestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * The data needed to create a Interest.
     */
    data: XOR<InterestCreateInput, InterestUncheckedCreateInput>
  }

  /**
   * Interest createMany
   */
  export type InterestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Interests.
     */
    data: InterestCreateManyInput | InterestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Interest createManyAndReturn
   */
  export type InterestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * The data used to create many Interests.
     */
    data: InterestCreateManyInput | InterestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Interest update
   */
  export type InterestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * The data needed to update a Interest.
     */
    data: XOR<InterestUpdateInput, InterestUncheckedUpdateInput>
    /**
     * Choose, which Interest to update.
     */
    where: InterestWhereUniqueInput
  }

  /**
   * Interest updateMany
   */
  export type InterestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Interests.
     */
    data: XOR<InterestUpdateManyMutationInput, InterestUncheckedUpdateManyInput>
    /**
     * Filter which Interests to update
     */
    where?: InterestWhereInput
    /**
     * Limit how many Interests to update.
     */
    limit?: number
  }

  /**
   * Interest updateManyAndReturn
   */
  export type InterestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * The data used to update Interests.
     */
    data: XOR<InterestUpdateManyMutationInput, InterestUncheckedUpdateManyInput>
    /**
     * Filter which Interests to update
     */
    where?: InterestWhereInput
    /**
     * Limit how many Interests to update.
     */
    limit?: number
  }

  /**
   * Interest upsert
   */
  export type InterestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * The filter to search for the Interest to update in case it exists.
     */
    where: InterestWhereUniqueInput
    /**
     * In case the Interest found by the `where` argument doesn't exist, create a new Interest with this data.
     */
    create: XOR<InterestCreateInput, InterestUncheckedCreateInput>
    /**
     * In case the Interest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterestUpdateInput, InterestUncheckedUpdateInput>
  }

  /**
   * Interest delete
   */
  export type InterestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter which Interest to delete.
     */
    where: InterestWhereUniqueInput
  }

  /**
   * Interest deleteMany
   */
  export type InterestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interests to delete
     */
    where?: InterestWhereInput
    /**
     * Limit how many Interests to delete.
     */
    limit?: number
  }

  /**
   * Interest.userDetails
   */
  export type Interest$userDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetails
     */
    select?: UserDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDetails
     */
    omit?: UserDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDetailsInclude<ExtArgs> | null
    where?: UserDetailsWhereInput
    orderBy?: UserDetailsOrderByWithRelationInput | UserDetailsOrderByWithRelationInput[]
    cursor?: UserDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserDetailsScalarFieldEnum | UserDetailsScalarFieldEnum[]
  }

  /**
   * Interest without action
   */
  export type InterestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
  }


  /**
   * Model Match
   */

  export type AggregateMatch = {
    _count: MatchCountAggregateOutputType | null
    _avg: MatchAvgAggregateOutputType | null
    _sum: MatchSumAggregateOutputType | null
    _min: MatchMinAggregateOutputType | null
    _max: MatchMaxAggregateOutputType | null
  }

  export type MatchAvgAggregateOutputType = {
    matchScore: number | null
  }

  export type MatchSumAggregateOutputType = {
    matchScore: number | null
  }

  export type MatchMinAggregateOutputType = {
    id: string | null
    inviterId: string | null
    inviteeId: string | null
    matchScore: number | null
    matchStatus: $Enums.MatchStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchMaxAggregateOutputType = {
    id: string | null
    inviterId: string | null
    inviteeId: string | null
    matchScore: number | null
    matchStatus: $Enums.MatchStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchCountAggregateOutputType = {
    id: number
    inviterId: number
    inviteeId: number
    matchScore: number
    matchStatus: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MatchAvgAggregateInputType = {
    matchScore?: true
  }

  export type MatchSumAggregateInputType = {
    matchScore?: true
  }

  export type MatchMinAggregateInputType = {
    id?: true
    inviterId?: true
    inviteeId?: true
    matchScore?: true
    matchStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchMaxAggregateInputType = {
    id?: true
    inviterId?: true
    inviteeId?: true
    matchScore?: true
    matchStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchCountAggregateInputType = {
    id?: true
    inviterId?: true
    inviteeId?: true
    matchScore?: true
    matchStatus?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Match to aggregate.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Matches
    **/
    _count?: true | MatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchMaxAggregateInputType
  }

  export type GetMatchAggregateType<T extends MatchAggregateArgs> = {
        [P in keyof T & keyof AggregateMatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatch[P]>
      : GetScalarType<T[P], AggregateMatch[P]>
  }




  export type MatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithAggregationInput | MatchOrderByWithAggregationInput[]
    by: MatchScalarFieldEnum[] | MatchScalarFieldEnum
    having?: MatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchCountAggregateInputType | true
    _avg?: MatchAvgAggregateInputType
    _sum?: MatchSumAggregateInputType
    _min?: MatchMinAggregateInputType
    _max?: MatchMaxAggregateInputType
  }

  export type MatchGroupByOutputType = {
    id: string
    inviterId: string
    inviteeId: string
    matchScore: number
    matchStatus: $Enums.MatchStatus
    createdAt: Date
    updatedAt: Date
    _count: MatchCountAggregateOutputType | null
    _avg: MatchAvgAggregateOutputType | null
    _sum: MatchSumAggregateOutputType | null
    _min: MatchMinAggregateOutputType | null
    _max: MatchMaxAggregateOutputType | null
  }

  type GetMatchGroupByPayload<T extends MatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchGroupByOutputType[P]>
            : GetScalarType<T[P], MatchGroupByOutputType[P]>
        }
      >
    >


  export type MatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inviterId?: boolean
    inviteeId?: boolean
    matchScore?: boolean
    matchStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inviter?: boolean | UserDetailsDefaultArgs<ExtArgs>
    invitee?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["match"]>

  export type MatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inviterId?: boolean
    inviteeId?: boolean
    matchScore?: boolean
    matchStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inviter?: boolean | UserDetailsDefaultArgs<ExtArgs>
    invitee?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["match"]>

  export type MatchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inviterId?: boolean
    inviteeId?: boolean
    matchScore?: boolean
    matchStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inviter?: boolean | UserDetailsDefaultArgs<ExtArgs>
    invitee?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["match"]>

  export type MatchSelectScalar = {
    id?: boolean
    inviterId?: boolean
    inviteeId?: boolean
    matchScore?: boolean
    matchStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "inviterId" | "inviteeId" | "matchScore" | "matchStatus" | "createdAt" | "updatedAt", ExtArgs["result"]["match"]>
  export type MatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inviter?: boolean | UserDetailsDefaultArgs<ExtArgs>
    invitee?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }
  export type MatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inviter?: boolean | UserDetailsDefaultArgs<ExtArgs>
    invitee?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }
  export type MatchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inviter?: boolean | UserDetailsDefaultArgs<ExtArgs>
    invitee?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }

  export type $MatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Match"
    objects: {
      inviter: Prisma.$UserDetailsPayload<ExtArgs>
      invitee: Prisma.$UserDetailsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      inviterId: string
      inviteeId: string
      matchScore: number
      matchStatus: $Enums.MatchStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["match"]>
    composites: {}
  }

  type MatchGetPayload<S extends boolean | null | undefined | MatchDefaultArgs> = $Result.GetResult<Prisma.$MatchPayload, S>

  type MatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatchCountAggregateInputType | true
    }

  export interface MatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Match'], meta: { name: 'Match' } }
    /**
     * Find zero or one Match that matches the filter.
     * @param {MatchFindUniqueArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchFindUniqueArgs>(args: SelectSubset<T, MatchFindUniqueArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Match that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatchFindUniqueOrThrowArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Match that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindFirstArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchFindFirstArgs>(args?: SelectSubset<T, MatchFindFirstArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Match that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindFirstOrThrowArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Matches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Matches
     * const matches = await prisma.match.findMany()
     * 
     * // Get first 10 Matches
     * const matches = await prisma.match.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchWithIdOnly = await prisma.match.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatchFindManyArgs>(args?: SelectSubset<T, MatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Match.
     * @param {MatchCreateArgs} args - Arguments to create a Match.
     * @example
     * // Create one Match
     * const Match = await prisma.match.create({
     *   data: {
     *     // ... data to create a Match
     *   }
     * })
     * 
     */
    create<T extends MatchCreateArgs>(args: SelectSubset<T, MatchCreateArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Matches.
     * @param {MatchCreateManyArgs} args - Arguments to create many Matches.
     * @example
     * // Create many Matches
     * const match = await prisma.match.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchCreateManyArgs>(args?: SelectSubset<T, MatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Matches and returns the data saved in the database.
     * @param {MatchCreateManyAndReturnArgs} args - Arguments to create many Matches.
     * @example
     * // Create many Matches
     * const match = await prisma.match.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Matches and only return the `id`
     * const matchWithIdOnly = await prisma.match.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatchCreateManyAndReturnArgs>(args?: SelectSubset<T, MatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Match.
     * @param {MatchDeleteArgs} args - Arguments to delete one Match.
     * @example
     * // Delete one Match
     * const Match = await prisma.match.delete({
     *   where: {
     *     // ... filter to delete one Match
     *   }
     * })
     * 
     */
    delete<T extends MatchDeleteArgs>(args: SelectSubset<T, MatchDeleteArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Match.
     * @param {MatchUpdateArgs} args - Arguments to update one Match.
     * @example
     * // Update one Match
     * const match = await prisma.match.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchUpdateArgs>(args: SelectSubset<T, MatchUpdateArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Matches.
     * @param {MatchDeleteManyArgs} args - Arguments to filter Matches to delete.
     * @example
     * // Delete a few Matches
     * const { count } = await prisma.match.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchDeleteManyArgs>(args?: SelectSubset<T, MatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Matches
     * const match = await prisma.match.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchUpdateManyArgs>(args: SelectSubset<T, MatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Matches and returns the data updated in the database.
     * @param {MatchUpdateManyAndReturnArgs} args - Arguments to update many Matches.
     * @example
     * // Update many Matches
     * const match = await prisma.match.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Matches and only return the `id`
     * const matchWithIdOnly = await prisma.match.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MatchUpdateManyAndReturnArgs>(args: SelectSubset<T, MatchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Match.
     * @param {MatchUpsertArgs} args - Arguments to update or create a Match.
     * @example
     * // Update or create a Match
     * const match = await prisma.match.upsert({
     *   create: {
     *     // ... data to create a Match
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Match we want to update
     *   }
     * })
     */
    upsert<T extends MatchUpsertArgs>(args: SelectSubset<T, MatchUpsertArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchCountArgs} args - Arguments to filter Matches to count.
     * @example
     * // Count the number of Matches
     * const count = await prisma.match.count({
     *   where: {
     *     // ... the filter for the Matches we want to count
     *   }
     * })
    **/
    count<T extends MatchCountArgs>(
      args?: Subset<T, MatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Match.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchAggregateArgs>(args: Subset<T, MatchAggregateArgs>): Prisma.PrismaPromise<GetMatchAggregateType<T>>

    /**
     * Group by Match.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchGroupByArgs['orderBy'] }
        : { orderBy?: MatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Match model
   */
  readonly fields: MatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Match.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inviter<T extends UserDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDetailsDefaultArgs<ExtArgs>>): Prisma__UserDetailsClient<$Result.GetResult<Prisma.$UserDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invitee<T extends UserDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDetailsDefaultArgs<ExtArgs>>): Prisma__UserDetailsClient<$Result.GetResult<Prisma.$UserDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Match model
   */
  interface MatchFieldRefs {
    readonly id: FieldRef<"Match", 'String'>
    readonly inviterId: FieldRef<"Match", 'String'>
    readonly inviteeId: FieldRef<"Match", 'String'>
    readonly matchScore: FieldRef<"Match", 'Int'>
    readonly matchStatus: FieldRef<"Match", 'MatchStatus'>
    readonly createdAt: FieldRef<"Match", 'DateTime'>
    readonly updatedAt: FieldRef<"Match", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Match findUnique
   */
  export type MatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match findUniqueOrThrow
   */
  export type MatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match findFirst
   */
  export type MatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matches.
     */
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Match findFirstOrThrow
   */
  export type MatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matches.
     */
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Match findMany
   */
  export type MatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Matches to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Match create
   */
  export type MatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The data needed to create a Match.
     */
    data: XOR<MatchCreateInput, MatchUncheckedCreateInput>
  }

  /**
   * Match createMany
   */
  export type MatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Matches.
     */
    data: MatchCreateManyInput | MatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Match createManyAndReturn
   */
  export type MatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * The data used to create many Matches.
     */
    data: MatchCreateManyInput | MatchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Match update
   */
  export type MatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The data needed to update a Match.
     */
    data: XOR<MatchUpdateInput, MatchUncheckedUpdateInput>
    /**
     * Choose, which Match to update.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match updateMany
   */
  export type MatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Matches.
     */
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyInput>
    /**
     * Filter which Matches to update
     */
    where?: MatchWhereInput
    /**
     * Limit how many Matches to update.
     */
    limit?: number
  }

  /**
   * Match updateManyAndReturn
   */
  export type MatchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * The data used to update Matches.
     */
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyInput>
    /**
     * Filter which Matches to update
     */
    where?: MatchWhereInput
    /**
     * Limit how many Matches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Match upsert
   */
  export type MatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The filter to search for the Match to update in case it exists.
     */
    where: MatchWhereUniqueInput
    /**
     * In case the Match found by the `where` argument doesn't exist, create a new Match with this data.
     */
    create: XOR<MatchCreateInput, MatchUncheckedCreateInput>
    /**
     * In case the Match was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchUpdateInput, MatchUncheckedUpdateInput>
  }

  /**
   * Match delete
   */
  export type MatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter which Match to delete.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match deleteMany
   */
  export type MatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Matches to delete
     */
    where?: MatchWhereInput
    /**
     * Limit how many Matches to delete.
     */
    limit?: number
  }

  /**
   * Match without action
   */
  export type MatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
  }


  /**
   * Model UserSimilarity
   */

  export type AggregateUserSimilarity = {
    _count: UserSimilarityCountAggregateOutputType | null
    _avg: UserSimilarityAvgAggregateOutputType | null
    _sum: UserSimilaritySumAggregateOutputType | null
    _min: UserSimilarityMinAggregateOutputType | null
    _max: UserSimilarityMaxAggregateOutputType | null
  }

  export type UserSimilarityAvgAggregateOutputType = {
    similarityScore: number | null
  }

  export type UserSimilaritySumAggregateOutputType = {
    similarityScore: number | null
  }

  export type UserSimilarityMinAggregateOutputType = {
    id: string | null
    currentUserId: string | null
    otherUserId: string | null
    similarityScore: number | null
    createdAt: Date | null
  }

  export type UserSimilarityMaxAggregateOutputType = {
    id: string | null
    currentUserId: string | null
    otherUserId: string | null
    similarityScore: number | null
    createdAt: Date | null
  }

  export type UserSimilarityCountAggregateOutputType = {
    id: number
    currentUserId: number
    otherUserId: number
    similarityScore: number
    factors: number
    createdAt: number
    _all: number
  }


  export type UserSimilarityAvgAggregateInputType = {
    similarityScore?: true
  }

  export type UserSimilaritySumAggregateInputType = {
    similarityScore?: true
  }

  export type UserSimilarityMinAggregateInputType = {
    id?: true
    currentUserId?: true
    otherUserId?: true
    similarityScore?: true
    createdAt?: true
  }

  export type UserSimilarityMaxAggregateInputType = {
    id?: true
    currentUserId?: true
    otherUserId?: true
    similarityScore?: true
    createdAt?: true
  }

  export type UserSimilarityCountAggregateInputType = {
    id?: true
    currentUserId?: true
    otherUserId?: true
    similarityScore?: true
    factors?: true
    createdAt?: true
    _all?: true
  }

  export type UserSimilarityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSimilarity to aggregate.
     */
    where?: UserSimilarityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSimilarities to fetch.
     */
    orderBy?: UserSimilarityOrderByWithRelationInput | UserSimilarityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSimilarityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSimilarities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSimilarities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSimilarities
    **/
    _count?: true | UserSimilarityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSimilarityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSimilaritySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSimilarityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSimilarityMaxAggregateInputType
  }

  export type GetUserSimilarityAggregateType<T extends UserSimilarityAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSimilarity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSimilarity[P]>
      : GetScalarType<T[P], AggregateUserSimilarity[P]>
  }




  export type UserSimilarityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSimilarityWhereInput
    orderBy?: UserSimilarityOrderByWithAggregationInput | UserSimilarityOrderByWithAggregationInput[]
    by: UserSimilarityScalarFieldEnum[] | UserSimilarityScalarFieldEnum
    having?: UserSimilarityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSimilarityCountAggregateInputType | true
    _avg?: UserSimilarityAvgAggregateInputType
    _sum?: UserSimilaritySumAggregateInputType
    _min?: UserSimilarityMinAggregateInputType
    _max?: UserSimilarityMaxAggregateInputType
  }

  export type UserSimilarityGroupByOutputType = {
    id: string
    currentUserId: string
    otherUserId: string
    similarityScore: number
    factors: JsonValue | null
    createdAt: Date
    _count: UserSimilarityCountAggregateOutputType | null
    _avg: UserSimilarityAvgAggregateOutputType | null
    _sum: UserSimilaritySumAggregateOutputType | null
    _min: UserSimilarityMinAggregateOutputType | null
    _max: UserSimilarityMaxAggregateOutputType | null
  }

  type GetUserSimilarityGroupByPayload<T extends UserSimilarityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSimilarityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSimilarityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSimilarityGroupByOutputType[P]>
            : GetScalarType<T[P], UserSimilarityGroupByOutputType[P]>
        }
      >
    >


  export type UserSimilaritySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currentUserId?: boolean
    otherUserId?: boolean
    similarityScore?: boolean
    factors?: boolean
    createdAt?: boolean
    currentUser?: boolean | UserDetailsDefaultArgs<ExtArgs>
    otherUser?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSimilarity"]>

  export type UserSimilaritySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currentUserId?: boolean
    otherUserId?: boolean
    similarityScore?: boolean
    factors?: boolean
    createdAt?: boolean
    currentUser?: boolean | UserDetailsDefaultArgs<ExtArgs>
    otherUser?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSimilarity"]>

  export type UserSimilaritySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currentUserId?: boolean
    otherUserId?: boolean
    similarityScore?: boolean
    factors?: boolean
    createdAt?: boolean
    currentUser?: boolean | UserDetailsDefaultArgs<ExtArgs>
    otherUser?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSimilarity"]>

  export type UserSimilaritySelectScalar = {
    id?: boolean
    currentUserId?: boolean
    otherUserId?: boolean
    similarityScore?: boolean
    factors?: boolean
    createdAt?: boolean
  }

  export type UserSimilarityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "currentUserId" | "otherUserId" | "similarityScore" | "factors" | "createdAt", ExtArgs["result"]["userSimilarity"]>
  export type UserSimilarityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currentUser?: boolean | UserDetailsDefaultArgs<ExtArgs>
    otherUser?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }
  export type UserSimilarityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currentUser?: boolean | UserDetailsDefaultArgs<ExtArgs>
    otherUser?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }
  export type UserSimilarityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currentUser?: boolean | UserDetailsDefaultArgs<ExtArgs>
    otherUser?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }

  export type $UserSimilarityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSimilarity"
    objects: {
      currentUser: Prisma.$UserDetailsPayload<ExtArgs>
      otherUser: Prisma.$UserDetailsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      currentUserId: string
      otherUserId: string
      similarityScore: number
      factors: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["userSimilarity"]>
    composites: {}
  }

  type UserSimilarityGetPayload<S extends boolean | null | undefined | UserSimilarityDefaultArgs> = $Result.GetResult<Prisma.$UserSimilarityPayload, S>

  type UserSimilarityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSimilarityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSimilarityCountAggregateInputType | true
    }

  export interface UserSimilarityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSimilarity'], meta: { name: 'UserSimilarity' } }
    /**
     * Find zero or one UserSimilarity that matches the filter.
     * @param {UserSimilarityFindUniqueArgs} args - Arguments to find a UserSimilarity
     * @example
     * // Get one UserSimilarity
     * const userSimilarity = await prisma.userSimilarity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSimilarityFindUniqueArgs>(args: SelectSubset<T, UserSimilarityFindUniqueArgs<ExtArgs>>): Prisma__UserSimilarityClient<$Result.GetResult<Prisma.$UserSimilarityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSimilarity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSimilarityFindUniqueOrThrowArgs} args - Arguments to find a UserSimilarity
     * @example
     * // Get one UserSimilarity
     * const userSimilarity = await prisma.userSimilarity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSimilarityFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSimilarityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSimilarityClient<$Result.GetResult<Prisma.$UserSimilarityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSimilarity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSimilarityFindFirstArgs} args - Arguments to find a UserSimilarity
     * @example
     * // Get one UserSimilarity
     * const userSimilarity = await prisma.userSimilarity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSimilarityFindFirstArgs>(args?: SelectSubset<T, UserSimilarityFindFirstArgs<ExtArgs>>): Prisma__UserSimilarityClient<$Result.GetResult<Prisma.$UserSimilarityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSimilarity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSimilarityFindFirstOrThrowArgs} args - Arguments to find a UserSimilarity
     * @example
     * // Get one UserSimilarity
     * const userSimilarity = await prisma.userSimilarity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSimilarityFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSimilarityFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSimilarityClient<$Result.GetResult<Prisma.$UserSimilarityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSimilarities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSimilarityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSimilarities
     * const userSimilarities = await prisma.userSimilarity.findMany()
     * 
     * // Get first 10 UserSimilarities
     * const userSimilarities = await prisma.userSimilarity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSimilarityWithIdOnly = await prisma.userSimilarity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSimilarityFindManyArgs>(args?: SelectSubset<T, UserSimilarityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSimilarityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSimilarity.
     * @param {UserSimilarityCreateArgs} args - Arguments to create a UserSimilarity.
     * @example
     * // Create one UserSimilarity
     * const UserSimilarity = await prisma.userSimilarity.create({
     *   data: {
     *     // ... data to create a UserSimilarity
     *   }
     * })
     * 
     */
    create<T extends UserSimilarityCreateArgs>(args: SelectSubset<T, UserSimilarityCreateArgs<ExtArgs>>): Prisma__UserSimilarityClient<$Result.GetResult<Prisma.$UserSimilarityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSimilarities.
     * @param {UserSimilarityCreateManyArgs} args - Arguments to create many UserSimilarities.
     * @example
     * // Create many UserSimilarities
     * const userSimilarity = await prisma.userSimilarity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSimilarityCreateManyArgs>(args?: SelectSubset<T, UserSimilarityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSimilarities and returns the data saved in the database.
     * @param {UserSimilarityCreateManyAndReturnArgs} args - Arguments to create many UserSimilarities.
     * @example
     * // Create many UserSimilarities
     * const userSimilarity = await prisma.userSimilarity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSimilarities and only return the `id`
     * const userSimilarityWithIdOnly = await prisma.userSimilarity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSimilarityCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSimilarityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSimilarityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSimilarity.
     * @param {UserSimilarityDeleteArgs} args - Arguments to delete one UserSimilarity.
     * @example
     * // Delete one UserSimilarity
     * const UserSimilarity = await prisma.userSimilarity.delete({
     *   where: {
     *     // ... filter to delete one UserSimilarity
     *   }
     * })
     * 
     */
    delete<T extends UserSimilarityDeleteArgs>(args: SelectSubset<T, UserSimilarityDeleteArgs<ExtArgs>>): Prisma__UserSimilarityClient<$Result.GetResult<Prisma.$UserSimilarityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSimilarity.
     * @param {UserSimilarityUpdateArgs} args - Arguments to update one UserSimilarity.
     * @example
     * // Update one UserSimilarity
     * const userSimilarity = await prisma.userSimilarity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSimilarityUpdateArgs>(args: SelectSubset<T, UserSimilarityUpdateArgs<ExtArgs>>): Prisma__UserSimilarityClient<$Result.GetResult<Prisma.$UserSimilarityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSimilarities.
     * @param {UserSimilarityDeleteManyArgs} args - Arguments to filter UserSimilarities to delete.
     * @example
     * // Delete a few UserSimilarities
     * const { count } = await prisma.userSimilarity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSimilarityDeleteManyArgs>(args?: SelectSubset<T, UserSimilarityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSimilarities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSimilarityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSimilarities
     * const userSimilarity = await prisma.userSimilarity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSimilarityUpdateManyArgs>(args: SelectSubset<T, UserSimilarityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSimilarities and returns the data updated in the database.
     * @param {UserSimilarityUpdateManyAndReturnArgs} args - Arguments to update many UserSimilarities.
     * @example
     * // Update many UserSimilarities
     * const userSimilarity = await prisma.userSimilarity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSimilarities and only return the `id`
     * const userSimilarityWithIdOnly = await prisma.userSimilarity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSimilarityUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSimilarityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSimilarityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSimilarity.
     * @param {UserSimilarityUpsertArgs} args - Arguments to update or create a UserSimilarity.
     * @example
     * // Update or create a UserSimilarity
     * const userSimilarity = await prisma.userSimilarity.upsert({
     *   create: {
     *     // ... data to create a UserSimilarity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSimilarity we want to update
     *   }
     * })
     */
    upsert<T extends UserSimilarityUpsertArgs>(args: SelectSubset<T, UserSimilarityUpsertArgs<ExtArgs>>): Prisma__UserSimilarityClient<$Result.GetResult<Prisma.$UserSimilarityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSimilarities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSimilarityCountArgs} args - Arguments to filter UserSimilarities to count.
     * @example
     * // Count the number of UserSimilarities
     * const count = await prisma.userSimilarity.count({
     *   where: {
     *     // ... the filter for the UserSimilarities we want to count
     *   }
     * })
    **/
    count<T extends UserSimilarityCountArgs>(
      args?: Subset<T, UserSimilarityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSimilarityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSimilarity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSimilarityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSimilarityAggregateArgs>(args: Subset<T, UserSimilarityAggregateArgs>): Prisma.PrismaPromise<GetUserSimilarityAggregateType<T>>

    /**
     * Group by UserSimilarity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSimilarityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSimilarityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSimilarityGroupByArgs['orderBy'] }
        : { orderBy?: UserSimilarityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSimilarityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSimilarityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSimilarity model
   */
  readonly fields: UserSimilarityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSimilarity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSimilarityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    currentUser<T extends UserDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDetailsDefaultArgs<ExtArgs>>): Prisma__UserDetailsClient<$Result.GetResult<Prisma.$UserDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    otherUser<T extends UserDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDetailsDefaultArgs<ExtArgs>>): Prisma__UserDetailsClient<$Result.GetResult<Prisma.$UserDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSimilarity model
   */
  interface UserSimilarityFieldRefs {
    readonly id: FieldRef<"UserSimilarity", 'String'>
    readonly currentUserId: FieldRef<"UserSimilarity", 'String'>
    readonly otherUserId: FieldRef<"UserSimilarity", 'String'>
    readonly similarityScore: FieldRef<"UserSimilarity", 'Int'>
    readonly factors: FieldRef<"UserSimilarity", 'Json'>
    readonly createdAt: FieldRef<"UserSimilarity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSimilarity findUnique
   */
  export type UserSimilarityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSimilarity
     */
    select?: UserSimilaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSimilarity
     */
    omit?: UserSimilarityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSimilarityInclude<ExtArgs> | null
    /**
     * Filter, which UserSimilarity to fetch.
     */
    where: UserSimilarityWhereUniqueInput
  }

  /**
   * UserSimilarity findUniqueOrThrow
   */
  export type UserSimilarityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSimilarity
     */
    select?: UserSimilaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSimilarity
     */
    omit?: UserSimilarityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSimilarityInclude<ExtArgs> | null
    /**
     * Filter, which UserSimilarity to fetch.
     */
    where: UserSimilarityWhereUniqueInput
  }

  /**
   * UserSimilarity findFirst
   */
  export type UserSimilarityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSimilarity
     */
    select?: UserSimilaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSimilarity
     */
    omit?: UserSimilarityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSimilarityInclude<ExtArgs> | null
    /**
     * Filter, which UserSimilarity to fetch.
     */
    where?: UserSimilarityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSimilarities to fetch.
     */
    orderBy?: UserSimilarityOrderByWithRelationInput | UserSimilarityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSimilarities.
     */
    cursor?: UserSimilarityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSimilarities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSimilarities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSimilarities.
     */
    distinct?: UserSimilarityScalarFieldEnum | UserSimilarityScalarFieldEnum[]
  }

  /**
   * UserSimilarity findFirstOrThrow
   */
  export type UserSimilarityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSimilarity
     */
    select?: UserSimilaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSimilarity
     */
    omit?: UserSimilarityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSimilarityInclude<ExtArgs> | null
    /**
     * Filter, which UserSimilarity to fetch.
     */
    where?: UserSimilarityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSimilarities to fetch.
     */
    orderBy?: UserSimilarityOrderByWithRelationInput | UserSimilarityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSimilarities.
     */
    cursor?: UserSimilarityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSimilarities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSimilarities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSimilarities.
     */
    distinct?: UserSimilarityScalarFieldEnum | UserSimilarityScalarFieldEnum[]
  }

  /**
   * UserSimilarity findMany
   */
  export type UserSimilarityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSimilarity
     */
    select?: UserSimilaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSimilarity
     */
    omit?: UserSimilarityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSimilarityInclude<ExtArgs> | null
    /**
     * Filter, which UserSimilarities to fetch.
     */
    where?: UserSimilarityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSimilarities to fetch.
     */
    orderBy?: UserSimilarityOrderByWithRelationInput | UserSimilarityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSimilarities.
     */
    cursor?: UserSimilarityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSimilarities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSimilarities.
     */
    skip?: number
    distinct?: UserSimilarityScalarFieldEnum | UserSimilarityScalarFieldEnum[]
  }

  /**
   * UserSimilarity create
   */
  export type UserSimilarityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSimilarity
     */
    select?: UserSimilaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSimilarity
     */
    omit?: UserSimilarityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSimilarityInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSimilarity.
     */
    data: XOR<UserSimilarityCreateInput, UserSimilarityUncheckedCreateInput>
  }

  /**
   * UserSimilarity createMany
   */
  export type UserSimilarityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSimilarities.
     */
    data: UserSimilarityCreateManyInput | UserSimilarityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSimilarity createManyAndReturn
   */
  export type UserSimilarityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSimilarity
     */
    select?: UserSimilaritySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSimilarity
     */
    omit?: UserSimilarityOmit<ExtArgs> | null
    /**
     * The data used to create many UserSimilarities.
     */
    data: UserSimilarityCreateManyInput | UserSimilarityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSimilarityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSimilarity update
   */
  export type UserSimilarityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSimilarity
     */
    select?: UserSimilaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSimilarity
     */
    omit?: UserSimilarityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSimilarityInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSimilarity.
     */
    data: XOR<UserSimilarityUpdateInput, UserSimilarityUncheckedUpdateInput>
    /**
     * Choose, which UserSimilarity to update.
     */
    where: UserSimilarityWhereUniqueInput
  }

  /**
   * UserSimilarity updateMany
   */
  export type UserSimilarityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSimilarities.
     */
    data: XOR<UserSimilarityUpdateManyMutationInput, UserSimilarityUncheckedUpdateManyInput>
    /**
     * Filter which UserSimilarities to update
     */
    where?: UserSimilarityWhereInput
    /**
     * Limit how many UserSimilarities to update.
     */
    limit?: number
  }

  /**
   * UserSimilarity updateManyAndReturn
   */
  export type UserSimilarityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSimilarity
     */
    select?: UserSimilaritySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSimilarity
     */
    omit?: UserSimilarityOmit<ExtArgs> | null
    /**
     * The data used to update UserSimilarities.
     */
    data: XOR<UserSimilarityUpdateManyMutationInput, UserSimilarityUncheckedUpdateManyInput>
    /**
     * Filter which UserSimilarities to update
     */
    where?: UserSimilarityWhereInput
    /**
     * Limit how many UserSimilarities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSimilarityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSimilarity upsert
   */
  export type UserSimilarityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSimilarity
     */
    select?: UserSimilaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSimilarity
     */
    omit?: UserSimilarityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSimilarityInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSimilarity to update in case it exists.
     */
    where: UserSimilarityWhereUniqueInput
    /**
     * In case the UserSimilarity found by the `where` argument doesn't exist, create a new UserSimilarity with this data.
     */
    create: XOR<UserSimilarityCreateInput, UserSimilarityUncheckedCreateInput>
    /**
     * In case the UserSimilarity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSimilarityUpdateInput, UserSimilarityUncheckedUpdateInput>
  }

  /**
   * UserSimilarity delete
   */
  export type UserSimilarityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSimilarity
     */
    select?: UserSimilaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSimilarity
     */
    omit?: UserSimilarityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSimilarityInclude<ExtArgs> | null
    /**
     * Filter which UserSimilarity to delete.
     */
    where: UserSimilarityWhereUniqueInput
  }

  /**
   * UserSimilarity deleteMany
   */
  export type UserSimilarityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSimilarities to delete
     */
    where?: UserSimilarityWhereInput
    /**
     * Limit how many UserSimilarities to delete.
     */
    limit?: number
  }

  /**
   * UserSimilarity without action
   */
  export type UserSimilarityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSimilarity
     */
    select?: UserSimilaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSimilarity
     */
    omit?: UserSimilarityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSimilarityInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    location: string | null
    date: Date | null
    time: Date | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    location: string | null
    date: Date | null
    time: Date | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    title: number
    description: number
    location: number
    date: number
    time: number
    category: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    location?: true
    date?: true
    time?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    location?: true
    date?: true
    time?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    location?: true
    date?: true
    time?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    title: string
    description: string
    location: string | null
    date: Date
    time: Date | null
    category: string | null
    createdAt: Date
    updatedAt: Date
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    date?: boolean
    time?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizers?: boolean | Event$organizersArgs<ExtArgs>
    attendees?: boolean | Event$attendeesArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    date?: boolean
    time?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["event"]>

  export type EventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    date?: boolean
    time?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    date?: boolean
    time?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "location" | "date" | "time" | "category" | "createdAt" | "updatedAt", ExtArgs["result"]["event"]>
  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizers?: boolean | Event$organizersArgs<ExtArgs>
    attendees?: boolean | Event$attendeesArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      organizers: Prisma.$UserDetailsPayload<ExtArgs>[]
      attendees: Prisma.$UserDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      location: string | null
      date: Date
      time: Date | null
      category: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events and returns the data updated in the database.
     * @param {EventUpdateManyAndReturnArgs} args - Arguments to update many Events.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventUpdateManyAndReturnArgs>(args: SelectSubset<T, EventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organizers<T extends Event$organizersArgs<ExtArgs> = {}>(args?: Subset<T, Event$organizersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendees<T extends Event$attendeesArgs<ExtArgs> = {}>(args?: Subset<T, Event$attendeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly title: FieldRef<"Event", 'String'>
    readonly description: FieldRef<"Event", 'String'>
    readonly location: FieldRef<"Event", 'String'>
    readonly date: FieldRef<"Event", 'DateTime'>
    readonly time: FieldRef<"Event", 'DateTime'>
    readonly category: FieldRef<"Event", 'String'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
    readonly updatedAt: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event updateManyAndReturn
   */
  export type EventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to delete.
     */
    limit?: number
  }

  /**
   * Event.organizers
   */
  export type Event$organizersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetails
     */
    select?: UserDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDetails
     */
    omit?: UserDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDetailsInclude<ExtArgs> | null
    where?: UserDetailsWhereInput
    orderBy?: UserDetailsOrderByWithRelationInput | UserDetailsOrderByWithRelationInput[]
    cursor?: UserDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserDetailsScalarFieldEnum | UserDetailsScalarFieldEnum[]
  }

  /**
   * Event.attendees
   */
  export type Event$attendeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetails
     */
    select?: UserDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDetails
     */
    omit?: UserDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDetailsInclude<ExtArgs> | null
    where?: UserDetailsWhereInput
    orderBy?: UserDetailsOrderByWithRelationInput | UserDetailsOrderByWithRelationInput[]
    cursor?: UserDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserDetailsScalarFieldEnum | UserDetailsScalarFieldEnum[]
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model CoffeeChat
   */

  export type AggregateCoffeeChat = {
    _count: CoffeeChatCountAggregateOutputType | null
    _avg: CoffeeChatAvgAggregateOutputType | null
    _sum: CoffeeChatSumAggregateOutputType | null
    _min: CoffeeChatMinAggregateOutputType | null
    _max: CoffeeChatMaxAggregateOutputType | null
  }

  export type CoffeeChatAvgAggregateOutputType = {
    duration: number | null
  }

  export type CoffeeChatSumAggregateOutputType = {
    duration: number | null
  }

  export type CoffeeChatMinAggregateOutputType = {
    id: string | null
    inviterId: string | null
    inviteeId: string | null
    purposeId: string | null
    venueId: string | null
    scheduledAt: Date | null
    duration: number | null
    personalMessage: string | null
    status: $Enums.CoffeeChatStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoffeeChatMaxAggregateOutputType = {
    id: string | null
    inviterId: string | null
    inviteeId: string | null
    purposeId: string | null
    venueId: string | null
    scheduledAt: Date | null
    duration: number | null
    personalMessage: string | null
    status: $Enums.CoffeeChatStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoffeeChatCountAggregateOutputType = {
    id: number
    inviterId: number
    inviteeId: number
    purposeId: number
    venueId: number
    scheduledAt: number
    duration: number
    personalMessage: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CoffeeChatAvgAggregateInputType = {
    duration?: true
  }

  export type CoffeeChatSumAggregateInputType = {
    duration?: true
  }

  export type CoffeeChatMinAggregateInputType = {
    id?: true
    inviterId?: true
    inviteeId?: true
    purposeId?: true
    venueId?: true
    scheduledAt?: true
    duration?: true
    personalMessage?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoffeeChatMaxAggregateInputType = {
    id?: true
    inviterId?: true
    inviteeId?: true
    purposeId?: true
    venueId?: true
    scheduledAt?: true
    duration?: true
    personalMessage?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoffeeChatCountAggregateInputType = {
    id?: true
    inviterId?: true
    inviteeId?: true
    purposeId?: true
    venueId?: true
    scheduledAt?: true
    duration?: true
    personalMessage?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CoffeeChatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoffeeChat to aggregate.
     */
    where?: CoffeeChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoffeeChats to fetch.
     */
    orderBy?: CoffeeChatOrderByWithRelationInput | CoffeeChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoffeeChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoffeeChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoffeeChats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoffeeChats
    **/
    _count?: true | CoffeeChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CoffeeChatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CoffeeChatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoffeeChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoffeeChatMaxAggregateInputType
  }

  export type GetCoffeeChatAggregateType<T extends CoffeeChatAggregateArgs> = {
        [P in keyof T & keyof AggregateCoffeeChat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoffeeChat[P]>
      : GetScalarType<T[P], AggregateCoffeeChat[P]>
  }




  export type CoffeeChatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoffeeChatWhereInput
    orderBy?: CoffeeChatOrderByWithAggregationInput | CoffeeChatOrderByWithAggregationInput[]
    by: CoffeeChatScalarFieldEnum[] | CoffeeChatScalarFieldEnum
    having?: CoffeeChatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoffeeChatCountAggregateInputType | true
    _avg?: CoffeeChatAvgAggregateInputType
    _sum?: CoffeeChatSumAggregateInputType
    _min?: CoffeeChatMinAggregateInputType
    _max?: CoffeeChatMaxAggregateInputType
  }

  export type CoffeeChatGroupByOutputType = {
    id: string
    inviterId: string
    inviteeId: string
    purposeId: string
    venueId: string
    scheduledAt: Date | null
    duration: number
    personalMessage: string | null
    status: $Enums.CoffeeChatStatus
    createdAt: Date
    updatedAt: Date
    _count: CoffeeChatCountAggregateOutputType | null
    _avg: CoffeeChatAvgAggregateOutputType | null
    _sum: CoffeeChatSumAggregateOutputType | null
    _min: CoffeeChatMinAggregateOutputType | null
    _max: CoffeeChatMaxAggregateOutputType | null
  }

  type GetCoffeeChatGroupByPayload<T extends CoffeeChatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoffeeChatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoffeeChatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoffeeChatGroupByOutputType[P]>
            : GetScalarType<T[P], CoffeeChatGroupByOutputType[P]>
        }
      >
    >


  export type CoffeeChatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inviterId?: boolean
    inviteeId?: boolean
    purposeId?: boolean
    venueId?: boolean
    scheduledAt?: boolean
    duration?: boolean
    personalMessage?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inviter?: boolean | UserDetailsDefaultArgs<ExtArgs>
    invitee?: boolean | UserDetailsDefaultArgs<ExtArgs>
    purpose?: boolean | CoffeeChatPurposeDefaultArgs<ExtArgs>
    venue?: boolean | CoffeeChatVenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coffeeChat"]>

  export type CoffeeChatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inviterId?: boolean
    inviteeId?: boolean
    purposeId?: boolean
    venueId?: boolean
    scheduledAt?: boolean
    duration?: boolean
    personalMessage?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inviter?: boolean | UserDetailsDefaultArgs<ExtArgs>
    invitee?: boolean | UserDetailsDefaultArgs<ExtArgs>
    purpose?: boolean | CoffeeChatPurposeDefaultArgs<ExtArgs>
    venue?: boolean | CoffeeChatVenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coffeeChat"]>

  export type CoffeeChatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inviterId?: boolean
    inviteeId?: boolean
    purposeId?: boolean
    venueId?: boolean
    scheduledAt?: boolean
    duration?: boolean
    personalMessage?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inviter?: boolean | UserDetailsDefaultArgs<ExtArgs>
    invitee?: boolean | UserDetailsDefaultArgs<ExtArgs>
    purpose?: boolean | CoffeeChatPurposeDefaultArgs<ExtArgs>
    venue?: boolean | CoffeeChatVenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coffeeChat"]>

  export type CoffeeChatSelectScalar = {
    id?: boolean
    inviterId?: boolean
    inviteeId?: boolean
    purposeId?: boolean
    venueId?: boolean
    scheduledAt?: boolean
    duration?: boolean
    personalMessage?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CoffeeChatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "inviterId" | "inviteeId" | "purposeId" | "venueId" | "scheduledAt" | "duration" | "personalMessage" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["coffeeChat"]>
  export type CoffeeChatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inviter?: boolean | UserDetailsDefaultArgs<ExtArgs>
    invitee?: boolean | UserDetailsDefaultArgs<ExtArgs>
    purpose?: boolean | CoffeeChatPurposeDefaultArgs<ExtArgs>
    venue?: boolean | CoffeeChatVenueDefaultArgs<ExtArgs>
  }
  export type CoffeeChatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inviter?: boolean | UserDetailsDefaultArgs<ExtArgs>
    invitee?: boolean | UserDetailsDefaultArgs<ExtArgs>
    purpose?: boolean | CoffeeChatPurposeDefaultArgs<ExtArgs>
    venue?: boolean | CoffeeChatVenueDefaultArgs<ExtArgs>
  }
  export type CoffeeChatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inviter?: boolean | UserDetailsDefaultArgs<ExtArgs>
    invitee?: boolean | UserDetailsDefaultArgs<ExtArgs>
    purpose?: boolean | CoffeeChatPurposeDefaultArgs<ExtArgs>
    venue?: boolean | CoffeeChatVenueDefaultArgs<ExtArgs>
  }

  export type $CoffeeChatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CoffeeChat"
    objects: {
      inviter: Prisma.$UserDetailsPayload<ExtArgs>
      invitee: Prisma.$UserDetailsPayload<ExtArgs>
      purpose: Prisma.$CoffeeChatPurposePayload<ExtArgs>
      venue: Prisma.$CoffeeChatVenuePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      inviterId: string
      inviteeId: string
      purposeId: string
      venueId: string
      scheduledAt: Date | null
      duration: number
      personalMessage: string | null
      status: $Enums.CoffeeChatStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["coffeeChat"]>
    composites: {}
  }

  type CoffeeChatGetPayload<S extends boolean | null | undefined | CoffeeChatDefaultArgs> = $Result.GetResult<Prisma.$CoffeeChatPayload, S>

  type CoffeeChatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CoffeeChatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CoffeeChatCountAggregateInputType | true
    }

  export interface CoffeeChatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CoffeeChat'], meta: { name: 'CoffeeChat' } }
    /**
     * Find zero or one CoffeeChat that matches the filter.
     * @param {CoffeeChatFindUniqueArgs} args - Arguments to find a CoffeeChat
     * @example
     * // Get one CoffeeChat
     * const coffeeChat = await prisma.coffeeChat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CoffeeChatFindUniqueArgs>(args: SelectSubset<T, CoffeeChatFindUniqueArgs<ExtArgs>>): Prisma__CoffeeChatClient<$Result.GetResult<Prisma.$CoffeeChatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CoffeeChat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CoffeeChatFindUniqueOrThrowArgs} args - Arguments to find a CoffeeChat
     * @example
     * // Get one CoffeeChat
     * const coffeeChat = await prisma.coffeeChat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CoffeeChatFindUniqueOrThrowArgs>(args: SelectSubset<T, CoffeeChatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CoffeeChatClient<$Result.GetResult<Prisma.$CoffeeChatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CoffeeChat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoffeeChatFindFirstArgs} args - Arguments to find a CoffeeChat
     * @example
     * // Get one CoffeeChat
     * const coffeeChat = await prisma.coffeeChat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CoffeeChatFindFirstArgs>(args?: SelectSubset<T, CoffeeChatFindFirstArgs<ExtArgs>>): Prisma__CoffeeChatClient<$Result.GetResult<Prisma.$CoffeeChatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CoffeeChat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoffeeChatFindFirstOrThrowArgs} args - Arguments to find a CoffeeChat
     * @example
     * // Get one CoffeeChat
     * const coffeeChat = await prisma.coffeeChat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CoffeeChatFindFirstOrThrowArgs>(args?: SelectSubset<T, CoffeeChatFindFirstOrThrowArgs<ExtArgs>>): Prisma__CoffeeChatClient<$Result.GetResult<Prisma.$CoffeeChatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CoffeeChats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoffeeChatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoffeeChats
     * const coffeeChats = await prisma.coffeeChat.findMany()
     * 
     * // Get first 10 CoffeeChats
     * const coffeeChats = await prisma.coffeeChat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coffeeChatWithIdOnly = await prisma.coffeeChat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CoffeeChatFindManyArgs>(args?: SelectSubset<T, CoffeeChatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoffeeChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CoffeeChat.
     * @param {CoffeeChatCreateArgs} args - Arguments to create a CoffeeChat.
     * @example
     * // Create one CoffeeChat
     * const CoffeeChat = await prisma.coffeeChat.create({
     *   data: {
     *     // ... data to create a CoffeeChat
     *   }
     * })
     * 
     */
    create<T extends CoffeeChatCreateArgs>(args: SelectSubset<T, CoffeeChatCreateArgs<ExtArgs>>): Prisma__CoffeeChatClient<$Result.GetResult<Prisma.$CoffeeChatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CoffeeChats.
     * @param {CoffeeChatCreateManyArgs} args - Arguments to create many CoffeeChats.
     * @example
     * // Create many CoffeeChats
     * const coffeeChat = await prisma.coffeeChat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CoffeeChatCreateManyArgs>(args?: SelectSubset<T, CoffeeChatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CoffeeChats and returns the data saved in the database.
     * @param {CoffeeChatCreateManyAndReturnArgs} args - Arguments to create many CoffeeChats.
     * @example
     * // Create many CoffeeChats
     * const coffeeChat = await prisma.coffeeChat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CoffeeChats and only return the `id`
     * const coffeeChatWithIdOnly = await prisma.coffeeChat.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CoffeeChatCreateManyAndReturnArgs>(args?: SelectSubset<T, CoffeeChatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoffeeChatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CoffeeChat.
     * @param {CoffeeChatDeleteArgs} args - Arguments to delete one CoffeeChat.
     * @example
     * // Delete one CoffeeChat
     * const CoffeeChat = await prisma.coffeeChat.delete({
     *   where: {
     *     // ... filter to delete one CoffeeChat
     *   }
     * })
     * 
     */
    delete<T extends CoffeeChatDeleteArgs>(args: SelectSubset<T, CoffeeChatDeleteArgs<ExtArgs>>): Prisma__CoffeeChatClient<$Result.GetResult<Prisma.$CoffeeChatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CoffeeChat.
     * @param {CoffeeChatUpdateArgs} args - Arguments to update one CoffeeChat.
     * @example
     * // Update one CoffeeChat
     * const coffeeChat = await prisma.coffeeChat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CoffeeChatUpdateArgs>(args: SelectSubset<T, CoffeeChatUpdateArgs<ExtArgs>>): Prisma__CoffeeChatClient<$Result.GetResult<Prisma.$CoffeeChatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CoffeeChats.
     * @param {CoffeeChatDeleteManyArgs} args - Arguments to filter CoffeeChats to delete.
     * @example
     * // Delete a few CoffeeChats
     * const { count } = await prisma.coffeeChat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CoffeeChatDeleteManyArgs>(args?: SelectSubset<T, CoffeeChatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoffeeChats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoffeeChatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoffeeChats
     * const coffeeChat = await prisma.coffeeChat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CoffeeChatUpdateManyArgs>(args: SelectSubset<T, CoffeeChatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoffeeChats and returns the data updated in the database.
     * @param {CoffeeChatUpdateManyAndReturnArgs} args - Arguments to update many CoffeeChats.
     * @example
     * // Update many CoffeeChats
     * const coffeeChat = await prisma.coffeeChat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CoffeeChats and only return the `id`
     * const coffeeChatWithIdOnly = await prisma.coffeeChat.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CoffeeChatUpdateManyAndReturnArgs>(args: SelectSubset<T, CoffeeChatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoffeeChatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CoffeeChat.
     * @param {CoffeeChatUpsertArgs} args - Arguments to update or create a CoffeeChat.
     * @example
     * // Update or create a CoffeeChat
     * const coffeeChat = await prisma.coffeeChat.upsert({
     *   create: {
     *     // ... data to create a CoffeeChat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoffeeChat we want to update
     *   }
     * })
     */
    upsert<T extends CoffeeChatUpsertArgs>(args: SelectSubset<T, CoffeeChatUpsertArgs<ExtArgs>>): Prisma__CoffeeChatClient<$Result.GetResult<Prisma.$CoffeeChatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CoffeeChats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoffeeChatCountArgs} args - Arguments to filter CoffeeChats to count.
     * @example
     * // Count the number of CoffeeChats
     * const count = await prisma.coffeeChat.count({
     *   where: {
     *     // ... the filter for the CoffeeChats we want to count
     *   }
     * })
    **/
    count<T extends CoffeeChatCountArgs>(
      args?: Subset<T, CoffeeChatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoffeeChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoffeeChat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoffeeChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoffeeChatAggregateArgs>(args: Subset<T, CoffeeChatAggregateArgs>): Prisma.PrismaPromise<GetCoffeeChatAggregateType<T>>

    /**
     * Group by CoffeeChat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoffeeChatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoffeeChatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoffeeChatGroupByArgs['orderBy'] }
        : { orderBy?: CoffeeChatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoffeeChatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoffeeChatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CoffeeChat model
   */
  readonly fields: CoffeeChatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CoffeeChat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoffeeChatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inviter<T extends UserDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDetailsDefaultArgs<ExtArgs>>): Prisma__UserDetailsClient<$Result.GetResult<Prisma.$UserDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invitee<T extends UserDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDetailsDefaultArgs<ExtArgs>>): Prisma__UserDetailsClient<$Result.GetResult<Prisma.$UserDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purpose<T extends CoffeeChatPurposeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoffeeChatPurposeDefaultArgs<ExtArgs>>): Prisma__CoffeeChatPurposeClient<$Result.GetResult<Prisma.$CoffeeChatPurposePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    venue<T extends CoffeeChatVenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoffeeChatVenueDefaultArgs<ExtArgs>>): Prisma__CoffeeChatVenueClient<$Result.GetResult<Prisma.$CoffeeChatVenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CoffeeChat model
   */
  interface CoffeeChatFieldRefs {
    readonly id: FieldRef<"CoffeeChat", 'String'>
    readonly inviterId: FieldRef<"CoffeeChat", 'String'>
    readonly inviteeId: FieldRef<"CoffeeChat", 'String'>
    readonly purposeId: FieldRef<"CoffeeChat", 'String'>
    readonly venueId: FieldRef<"CoffeeChat", 'String'>
    readonly scheduledAt: FieldRef<"CoffeeChat", 'DateTime'>
    readonly duration: FieldRef<"CoffeeChat", 'Int'>
    readonly personalMessage: FieldRef<"CoffeeChat", 'String'>
    readonly status: FieldRef<"CoffeeChat", 'CoffeeChatStatus'>
    readonly createdAt: FieldRef<"CoffeeChat", 'DateTime'>
    readonly updatedAt: FieldRef<"CoffeeChat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CoffeeChat findUnique
   */
  export type CoffeeChatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChat
     */
    select?: CoffeeChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChat
     */
    omit?: CoffeeChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatInclude<ExtArgs> | null
    /**
     * Filter, which CoffeeChat to fetch.
     */
    where: CoffeeChatWhereUniqueInput
  }

  /**
   * CoffeeChat findUniqueOrThrow
   */
  export type CoffeeChatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChat
     */
    select?: CoffeeChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChat
     */
    omit?: CoffeeChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatInclude<ExtArgs> | null
    /**
     * Filter, which CoffeeChat to fetch.
     */
    where: CoffeeChatWhereUniqueInput
  }

  /**
   * CoffeeChat findFirst
   */
  export type CoffeeChatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChat
     */
    select?: CoffeeChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChat
     */
    omit?: CoffeeChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatInclude<ExtArgs> | null
    /**
     * Filter, which CoffeeChat to fetch.
     */
    where?: CoffeeChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoffeeChats to fetch.
     */
    orderBy?: CoffeeChatOrderByWithRelationInput | CoffeeChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoffeeChats.
     */
    cursor?: CoffeeChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoffeeChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoffeeChats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoffeeChats.
     */
    distinct?: CoffeeChatScalarFieldEnum | CoffeeChatScalarFieldEnum[]
  }

  /**
   * CoffeeChat findFirstOrThrow
   */
  export type CoffeeChatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChat
     */
    select?: CoffeeChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChat
     */
    omit?: CoffeeChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatInclude<ExtArgs> | null
    /**
     * Filter, which CoffeeChat to fetch.
     */
    where?: CoffeeChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoffeeChats to fetch.
     */
    orderBy?: CoffeeChatOrderByWithRelationInput | CoffeeChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoffeeChats.
     */
    cursor?: CoffeeChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoffeeChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoffeeChats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoffeeChats.
     */
    distinct?: CoffeeChatScalarFieldEnum | CoffeeChatScalarFieldEnum[]
  }

  /**
   * CoffeeChat findMany
   */
  export type CoffeeChatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChat
     */
    select?: CoffeeChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChat
     */
    omit?: CoffeeChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatInclude<ExtArgs> | null
    /**
     * Filter, which CoffeeChats to fetch.
     */
    where?: CoffeeChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoffeeChats to fetch.
     */
    orderBy?: CoffeeChatOrderByWithRelationInput | CoffeeChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoffeeChats.
     */
    cursor?: CoffeeChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoffeeChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoffeeChats.
     */
    skip?: number
    distinct?: CoffeeChatScalarFieldEnum | CoffeeChatScalarFieldEnum[]
  }

  /**
   * CoffeeChat create
   */
  export type CoffeeChatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChat
     */
    select?: CoffeeChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChat
     */
    omit?: CoffeeChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatInclude<ExtArgs> | null
    /**
     * The data needed to create a CoffeeChat.
     */
    data: XOR<CoffeeChatCreateInput, CoffeeChatUncheckedCreateInput>
  }

  /**
   * CoffeeChat createMany
   */
  export type CoffeeChatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CoffeeChats.
     */
    data: CoffeeChatCreateManyInput | CoffeeChatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CoffeeChat createManyAndReturn
   */
  export type CoffeeChatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChat
     */
    select?: CoffeeChatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChat
     */
    omit?: CoffeeChatOmit<ExtArgs> | null
    /**
     * The data used to create many CoffeeChats.
     */
    data: CoffeeChatCreateManyInput | CoffeeChatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoffeeChat update
   */
  export type CoffeeChatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChat
     */
    select?: CoffeeChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChat
     */
    omit?: CoffeeChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatInclude<ExtArgs> | null
    /**
     * The data needed to update a CoffeeChat.
     */
    data: XOR<CoffeeChatUpdateInput, CoffeeChatUncheckedUpdateInput>
    /**
     * Choose, which CoffeeChat to update.
     */
    where: CoffeeChatWhereUniqueInput
  }

  /**
   * CoffeeChat updateMany
   */
  export type CoffeeChatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CoffeeChats.
     */
    data: XOR<CoffeeChatUpdateManyMutationInput, CoffeeChatUncheckedUpdateManyInput>
    /**
     * Filter which CoffeeChats to update
     */
    where?: CoffeeChatWhereInput
    /**
     * Limit how many CoffeeChats to update.
     */
    limit?: number
  }

  /**
   * CoffeeChat updateManyAndReturn
   */
  export type CoffeeChatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChat
     */
    select?: CoffeeChatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChat
     */
    omit?: CoffeeChatOmit<ExtArgs> | null
    /**
     * The data used to update CoffeeChats.
     */
    data: XOR<CoffeeChatUpdateManyMutationInput, CoffeeChatUncheckedUpdateManyInput>
    /**
     * Filter which CoffeeChats to update
     */
    where?: CoffeeChatWhereInput
    /**
     * Limit how many CoffeeChats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoffeeChat upsert
   */
  export type CoffeeChatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChat
     */
    select?: CoffeeChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChat
     */
    omit?: CoffeeChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatInclude<ExtArgs> | null
    /**
     * The filter to search for the CoffeeChat to update in case it exists.
     */
    where: CoffeeChatWhereUniqueInput
    /**
     * In case the CoffeeChat found by the `where` argument doesn't exist, create a new CoffeeChat with this data.
     */
    create: XOR<CoffeeChatCreateInput, CoffeeChatUncheckedCreateInput>
    /**
     * In case the CoffeeChat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoffeeChatUpdateInput, CoffeeChatUncheckedUpdateInput>
  }

  /**
   * CoffeeChat delete
   */
  export type CoffeeChatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChat
     */
    select?: CoffeeChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChat
     */
    omit?: CoffeeChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatInclude<ExtArgs> | null
    /**
     * Filter which CoffeeChat to delete.
     */
    where: CoffeeChatWhereUniqueInput
  }

  /**
   * CoffeeChat deleteMany
   */
  export type CoffeeChatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoffeeChats to delete
     */
    where?: CoffeeChatWhereInput
    /**
     * Limit how many CoffeeChats to delete.
     */
    limit?: number
  }

  /**
   * CoffeeChat without action
   */
  export type CoffeeChatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChat
     */
    select?: CoffeeChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChat
     */
    omit?: CoffeeChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatInclude<ExtArgs> | null
  }


  /**
   * Model CoffeeChatPurpose
   */

  export type AggregateCoffeeChatPurpose = {
    _count: CoffeeChatPurposeCountAggregateOutputType | null
    _avg: CoffeeChatPurposeAvgAggregateOutputType | null
    _sum: CoffeeChatPurposeSumAggregateOutputType | null
    _min: CoffeeChatPurposeMinAggregateOutputType | null
    _max: CoffeeChatPurposeMaxAggregateOutputType | null
  }

  export type CoffeeChatPurposeAvgAggregateOutputType = {
    timeLimit: number | null
  }

  export type CoffeeChatPurposeSumAggregateOutputType = {
    timeLimit: number | null
  }

  export type CoffeeChatPurposeMinAggregateOutputType = {
    id: string | null
    purposeName: string | null
    description: string | null
    timeLimit: number | null
  }

  export type CoffeeChatPurposeMaxAggregateOutputType = {
    id: string | null
    purposeName: string | null
    description: string | null
    timeLimit: number | null
  }

  export type CoffeeChatPurposeCountAggregateOutputType = {
    id: number
    purposeName: number
    description: number
    timeLimit: number
    _all: number
  }


  export type CoffeeChatPurposeAvgAggregateInputType = {
    timeLimit?: true
  }

  export type CoffeeChatPurposeSumAggregateInputType = {
    timeLimit?: true
  }

  export type CoffeeChatPurposeMinAggregateInputType = {
    id?: true
    purposeName?: true
    description?: true
    timeLimit?: true
  }

  export type CoffeeChatPurposeMaxAggregateInputType = {
    id?: true
    purposeName?: true
    description?: true
    timeLimit?: true
  }

  export type CoffeeChatPurposeCountAggregateInputType = {
    id?: true
    purposeName?: true
    description?: true
    timeLimit?: true
    _all?: true
  }

  export type CoffeeChatPurposeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoffeeChatPurpose to aggregate.
     */
    where?: CoffeeChatPurposeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoffeeChatPurposes to fetch.
     */
    orderBy?: CoffeeChatPurposeOrderByWithRelationInput | CoffeeChatPurposeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoffeeChatPurposeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoffeeChatPurposes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoffeeChatPurposes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoffeeChatPurposes
    **/
    _count?: true | CoffeeChatPurposeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CoffeeChatPurposeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CoffeeChatPurposeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoffeeChatPurposeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoffeeChatPurposeMaxAggregateInputType
  }

  export type GetCoffeeChatPurposeAggregateType<T extends CoffeeChatPurposeAggregateArgs> = {
        [P in keyof T & keyof AggregateCoffeeChatPurpose]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoffeeChatPurpose[P]>
      : GetScalarType<T[P], AggregateCoffeeChatPurpose[P]>
  }




  export type CoffeeChatPurposeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoffeeChatPurposeWhereInput
    orderBy?: CoffeeChatPurposeOrderByWithAggregationInput | CoffeeChatPurposeOrderByWithAggregationInput[]
    by: CoffeeChatPurposeScalarFieldEnum[] | CoffeeChatPurposeScalarFieldEnum
    having?: CoffeeChatPurposeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoffeeChatPurposeCountAggregateInputType | true
    _avg?: CoffeeChatPurposeAvgAggregateInputType
    _sum?: CoffeeChatPurposeSumAggregateInputType
    _min?: CoffeeChatPurposeMinAggregateInputType
    _max?: CoffeeChatPurposeMaxAggregateInputType
  }

  export type CoffeeChatPurposeGroupByOutputType = {
    id: string
    purposeName: string
    description: string
    timeLimit: number
    _count: CoffeeChatPurposeCountAggregateOutputType | null
    _avg: CoffeeChatPurposeAvgAggregateOutputType | null
    _sum: CoffeeChatPurposeSumAggregateOutputType | null
    _min: CoffeeChatPurposeMinAggregateOutputType | null
    _max: CoffeeChatPurposeMaxAggregateOutputType | null
  }

  type GetCoffeeChatPurposeGroupByPayload<T extends CoffeeChatPurposeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoffeeChatPurposeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoffeeChatPurposeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoffeeChatPurposeGroupByOutputType[P]>
            : GetScalarType<T[P], CoffeeChatPurposeGroupByOutputType[P]>
        }
      >
    >


  export type CoffeeChatPurposeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purposeName?: boolean
    description?: boolean
    timeLimit?: boolean
    coffeeChats?: boolean | CoffeeChatPurpose$coffeeChatsArgs<ExtArgs>
    _count?: boolean | CoffeeChatPurposeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coffeeChatPurpose"]>

  export type CoffeeChatPurposeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purposeName?: boolean
    description?: boolean
    timeLimit?: boolean
  }, ExtArgs["result"]["coffeeChatPurpose"]>

  export type CoffeeChatPurposeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purposeName?: boolean
    description?: boolean
    timeLimit?: boolean
  }, ExtArgs["result"]["coffeeChatPurpose"]>

  export type CoffeeChatPurposeSelectScalar = {
    id?: boolean
    purposeName?: boolean
    description?: boolean
    timeLimit?: boolean
  }

  export type CoffeeChatPurposeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "purposeName" | "description" | "timeLimit", ExtArgs["result"]["coffeeChatPurpose"]>
  export type CoffeeChatPurposeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coffeeChats?: boolean | CoffeeChatPurpose$coffeeChatsArgs<ExtArgs>
    _count?: boolean | CoffeeChatPurposeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CoffeeChatPurposeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CoffeeChatPurposeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CoffeeChatPurposePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CoffeeChatPurpose"
    objects: {
      coffeeChats: Prisma.$CoffeeChatPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      purposeName: string
      description: string
      timeLimit: number
    }, ExtArgs["result"]["coffeeChatPurpose"]>
    composites: {}
  }

  type CoffeeChatPurposeGetPayload<S extends boolean | null | undefined | CoffeeChatPurposeDefaultArgs> = $Result.GetResult<Prisma.$CoffeeChatPurposePayload, S>

  type CoffeeChatPurposeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CoffeeChatPurposeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CoffeeChatPurposeCountAggregateInputType | true
    }

  export interface CoffeeChatPurposeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CoffeeChatPurpose'], meta: { name: 'CoffeeChatPurpose' } }
    /**
     * Find zero or one CoffeeChatPurpose that matches the filter.
     * @param {CoffeeChatPurposeFindUniqueArgs} args - Arguments to find a CoffeeChatPurpose
     * @example
     * // Get one CoffeeChatPurpose
     * const coffeeChatPurpose = await prisma.coffeeChatPurpose.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CoffeeChatPurposeFindUniqueArgs>(args: SelectSubset<T, CoffeeChatPurposeFindUniqueArgs<ExtArgs>>): Prisma__CoffeeChatPurposeClient<$Result.GetResult<Prisma.$CoffeeChatPurposePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CoffeeChatPurpose that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CoffeeChatPurposeFindUniqueOrThrowArgs} args - Arguments to find a CoffeeChatPurpose
     * @example
     * // Get one CoffeeChatPurpose
     * const coffeeChatPurpose = await prisma.coffeeChatPurpose.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CoffeeChatPurposeFindUniqueOrThrowArgs>(args: SelectSubset<T, CoffeeChatPurposeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CoffeeChatPurposeClient<$Result.GetResult<Prisma.$CoffeeChatPurposePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CoffeeChatPurpose that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoffeeChatPurposeFindFirstArgs} args - Arguments to find a CoffeeChatPurpose
     * @example
     * // Get one CoffeeChatPurpose
     * const coffeeChatPurpose = await prisma.coffeeChatPurpose.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CoffeeChatPurposeFindFirstArgs>(args?: SelectSubset<T, CoffeeChatPurposeFindFirstArgs<ExtArgs>>): Prisma__CoffeeChatPurposeClient<$Result.GetResult<Prisma.$CoffeeChatPurposePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CoffeeChatPurpose that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoffeeChatPurposeFindFirstOrThrowArgs} args - Arguments to find a CoffeeChatPurpose
     * @example
     * // Get one CoffeeChatPurpose
     * const coffeeChatPurpose = await prisma.coffeeChatPurpose.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CoffeeChatPurposeFindFirstOrThrowArgs>(args?: SelectSubset<T, CoffeeChatPurposeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CoffeeChatPurposeClient<$Result.GetResult<Prisma.$CoffeeChatPurposePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CoffeeChatPurposes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoffeeChatPurposeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoffeeChatPurposes
     * const coffeeChatPurposes = await prisma.coffeeChatPurpose.findMany()
     * 
     * // Get first 10 CoffeeChatPurposes
     * const coffeeChatPurposes = await prisma.coffeeChatPurpose.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coffeeChatPurposeWithIdOnly = await prisma.coffeeChatPurpose.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CoffeeChatPurposeFindManyArgs>(args?: SelectSubset<T, CoffeeChatPurposeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoffeeChatPurposePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CoffeeChatPurpose.
     * @param {CoffeeChatPurposeCreateArgs} args - Arguments to create a CoffeeChatPurpose.
     * @example
     * // Create one CoffeeChatPurpose
     * const CoffeeChatPurpose = await prisma.coffeeChatPurpose.create({
     *   data: {
     *     // ... data to create a CoffeeChatPurpose
     *   }
     * })
     * 
     */
    create<T extends CoffeeChatPurposeCreateArgs>(args: SelectSubset<T, CoffeeChatPurposeCreateArgs<ExtArgs>>): Prisma__CoffeeChatPurposeClient<$Result.GetResult<Prisma.$CoffeeChatPurposePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CoffeeChatPurposes.
     * @param {CoffeeChatPurposeCreateManyArgs} args - Arguments to create many CoffeeChatPurposes.
     * @example
     * // Create many CoffeeChatPurposes
     * const coffeeChatPurpose = await prisma.coffeeChatPurpose.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CoffeeChatPurposeCreateManyArgs>(args?: SelectSubset<T, CoffeeChatPurposeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CoffeeChatPurposes and returns the data saved in the database.
     * @param {CoffeeChatPurposeCreateManyAndReturnArgs} args - Arguments to create many CoffeeChatPurposes.
     * @example
     * // Create many CoffeeChatPurposes
     * const coffeeChatPurpose = await prisma.coffeeChatPurpose.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CoffeeChatPurposes and only return the `id`
     * const coffeeChatPurposeWithIdOnly = await prisma.coffeeChatPurpose.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CoffeeChatPurposeCreateManyAndReturnArgs>(args?: SelectSubset<T, CoffeeChatPurposeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoffeeChatPurposePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CoffeeChatPurpose.
     * @param {CoffeeChatPurposeDeleteArgs} args - Arguments to delete one CoffeeChatPurpose.
     * @example
     * // Delete one CoffeeChatPurpose
     * const CoffeeChatPurpose = await prisma.coffeeChatPurpose.delete({
     *   where: {
     *     // ... filter to delete one CoffeeChatPurpose
     *   }
     * })
     * 
     */
    delete<T extends CoffeeChatPurposeDeleteArgs>(args: SelectSubset<T, CoffeeChatPurposeDeleteArgs<ExtArgs>>): Prisma__CoffeeChatPurposeClient<$Result.GetResult<Prisma.$CoffeeChatPurposePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CoffeeChatPurpose.
     * @param {CoffeeChatPurposeUpdateArgs} args - Arguments to update one CoffeeChatPurpose.
     * @example
     * // Update one CoffeeChatPurpose
     * const coffeeChatPurpose = await prisma.coffeeChatPurpose.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CoffeeChatPurposeUpdateArgs>(args: SelectSubset<T, CoffeeChatPurposeUpdateArgs<ExtArgs>>): Prisma__CoffeeChatPurposeClient<$Result.GetResult<Prisma.$CoffeeChatPurposePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CoffeeChatPurposes.
     * @param {CoffeeChatPurposeDeleteManyArgs} args - Arguments to filter CoffeeChatPurposes to delete.
     * @example
     * // Delete a few CoffeeChatPurposes
     * const { count } = await prisma.coffeeChatPurpose.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CoffeeChatPurposeDeleteManyArgs>(args?: SelectSubset<T, CoffeeChatPurposeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoffeeChatPurposes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoffeeChatPurposeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoffeeChatPurposes
     * const coffeeChatPurpose = await prisma.coffeeChatPurpose.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CoffeeChatPurposeUpdateManyArgs>(args: SelectSubset<T, CoffeeChatPurposeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoffeeChatPurposes and returns the data updated in the database.
     * @param {CoffeeChatPurposeUpdateManyAndReturnArgs} args - Arguments to update many CoffeeChatPurposes.
     * @example
     * // Update many CoffeeChatPurposes
     * const coffeeChatPurpose = await prisma.coffeeChatPurpose.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CoffeeChatPurposes and only return the `id`
     * const coffeeChatPurposeWithIdOnly = await prisma.coffeeChatPurpose.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CoffeeChatPurposeUpdateManyAndReturnArgs>(args: SelectSubset<T, CoffeeChatPurposeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoffeeChatPurposePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CoffeeChatPurpose.
     * @param {CoffeeChatPurposeUpsertArgs} args - Arguments to update or create a CoffeeChatPurpose.
     * @example
     * // Update or create a CoffeeChatPurpose
     * const coffeeChatPurpose = await prisma.coffeeChatPurpose.upsert({
     *   create: {
     *     // ... data to create a CoffeeChatPurpose
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoffeeChatPurpose we want to update
     *   }
     * })
     */
    upsert<T extends CoffeeChatPurposeUpsertArgs>(args: SelectSubset<T, CoffeeChatPurposeUpsertArgs<ExtArgs>>): Prisma__CoffeeChatPurposeClient<$Result.GetResult<Prisma.$CoffeeChatPurposePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CoffeeChatPurposes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoffeeChatPurposeCountArgs} args - Arguments to filter CoffeeChatPurposes to count.
     * @example
     * // Count the number of CoffeeChatPurposes
     * const count = await prisma.coffeeChatPurpose.count({
     *   where: {
     *     // ... the filter for the CoffeeChatPurposes we want to count
     *   }
     * })
    **/
    count<T extends CoffeeChatPurposeCountArgs>(
      args?: Subset<T, CoffeeChatPurposeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoffeeChatPurposeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoffeeChatPurpose.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoffeeChatPurposeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoffeeChatPurposeAggregateArgs>(args: Subset<T, CoffeeChatPurposeAggregateArgs>): Prisma.PrismaPromise<GetCoffeeChatPurposeAggregateType<T>>

    /**
     * Group by CoffeeChatPurpose.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoffeeChatPurposeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoffeeChatPurposeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoffeeChatPurposeGroupByArgs['orderBy'] }
        : { orderBy?: CoffeeChatPurposeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoffeeChatPurposeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoffeeChatPurposeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CoffeeChatPurpose model
   */
  readonly fields: CoffeeChatPurposeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CoffeeChatPurpose.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoffeeChatPurposeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coffeeChats<T extends CoffeeChatPurpose$coffeeChatsArgs<ExtArgs> = {}>(args?: Subset<T, CoffeeChatPurpose$coffeeChatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoffeeChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CoffeeChatPurpose model
   */
  interface CoffeeChatPurposeFieldRefs {
    readonly id: FieldRef<"CoffeeChatPurpose", 'String'>
    readonly purposeName: FieldRef<"CoffeeChatPurpose", 'String'>
    readonly description: FieldRef<"CoffeeChatPurpose", 'String'>
    readonly timeLimit: FieldRef<"CoffeeChatPurpose", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CoffeeChatPurpose findUnique
   */
  export type CoffeeChatPurposeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChatPurpose
     */
    select?: CoffeeChatPurposeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChatPurpose
     */
    omit?: CoffeeChatPurposeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatPurposeInclude<ExtArgs> | null
    /**
     * Filter, which CoffeeChatPurpose to fetch.
     */
    where: CoffeeChatPurposeWhereUniqueInput
  }

  /**
   * CoffeeChatPurpose findUniqueOrThrow
   */
  export type CoffeeChatPurposeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChatPurpose
     */
    select?: CoffeeChatPurposeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChatPurpose
     */
    omit?: CoffeeChatPurposeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatPurposeInclude<ExtArgs> | null
    /**
     * Filter, which CoffeeChatPurpose to fetch.
     */
    where: CoffeeChatPurposeWhereUniqueInput
  }

  /**
   * CoffeeChatPurpose findFirst
   */
  export type CoffeeChatPurposeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChatPurpose
     */
    select?: CoffeeChatPurposeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChatPurpose
     */
    omit?: CoffeeChatPurposeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatPurposeInclude<ExtArgs> | null
    /**
     * Filter, which CoffeeChatPurpose to fetch.
     */
    where?: CoffeeChatPurposeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoffeeChatPurposes to fetch.
     */
    orderBy?: CoffeeChatPurposeOrderByWithRelationInput | CoffeeChatPurposeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoffeeChatPurposes.
     */
    cursor?: CoffeeChatPurposeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoffeeChatPurposes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoffeeChatPurposes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoffeeChatPurposes.
     */
    distinct?: CoffeeChatPurposeScalarFieldEnum | CoffeeChatPurposeScalarFieldEnum[]
  }

  /**
   * CoffeeChatPurpose findFirstOrThrow
   */
  export type CoffeeChatPurposeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChatPurpose
     */
    select?: CoffeeChatPurposeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChatPurpose
     */
    omit?: CoffeeChatPurposeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatPurposeInclude<ExtArgs> | null
    /**
     * Filter, which CoffeeChatPurpose to fetch.
     */
    where?: CoffeeChatPurposeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoffeeChatPurposes to fetch.
     */
    orderBy?: CoffeeChatPurposeOrderByWithRelationInput | CoffeeChatPurposeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoffeeChatPurposes.
     */
    cursor?: CoffeeChatPurposeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoffeeChatPurposes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoffeeChatPurposes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoffeeChatPurposes.
     */
    distinct?: CoffeeChatPurposeScalarFieldEnum | CoffeeChatPurposeScalarFieldEnum[]
  }

  /**
   * CoffeeChatPurpose findMany
   */
  export type CoffeeChatPurposeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChatPurpose
     */
    select?: CoffeeChatPurposeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChatPurpose
     */
    omit?: CoffeeChatPurposeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatPurposeInclude<ExtArgs> | null
    /**
     * Filter, which CoffeeChatPurposes to fetch.
     */
    where?: CoffeeChatPurposeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoffeeChatPurposes to fetch.
     */
    orderBy?: CoffeeChatPurposeOrderByWithRelationInput | CoffeeChatPurposeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoffeeChatPurposes.
     */
    cursor?: CoffeeChatPurposeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoffeeChatPurposes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoffeeChatPurposes.
     */
    skip?: number
    distinct?: CoffeeChatPurposeScalarFieldEnum | CoffeeChatPurposeScalarFieldEnum[]
  }

  /**
   * CoffeeChatPurpose create
   */
  export type CoffeeChatPurposeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChatPurpose
     */
    select?: CoffeeChatPurposeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChatPurpose
     */
    omit?: CoffeeChatPurposeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatPurposeInclude<ExtArgs> | null
    /**
     * The data needed to create a CoffeeChatPurpose.
     */
    data: XOR<CoffeeChatPurposeCreateInput, CoffeeChatPurposeUncheckedCreateInput>
  }

  /**
   * CoffeeChatPurpose createMany
   */
  export type CoffeeChatPurposeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CoffeeChatPurposes.
     */
    data: CoffeeChatPurposeCreateManyInput | CoffeeChatPurposeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CoffeeChatPurpose createManyAndReturn
   */
  export type CoffeeChatPurposeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChatPurpose
     */
    select?: CoffeeChatPurposeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChatPurpose
     */
    omit?: CoffeeChatPurposeOmit<ExtArgs> | null
    /**
     * The data used to create many CoffeeChatPurposes.
     */
    data: CoffeeChatPurposeCreateManyInput | CoffeeChatPurposeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CoffeeChatPurpose update
   */
  export type CoffeeChatPurposeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChatPurpose
     */
    select?: CoffeeChatPurposeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChatPurpose
     */
    omit?: CoffeeChatPurposeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatPurposeInclude<ExtArgs> | null
    /**
     * The data needed to update a CoffeeChatPurpose.
     */
    data: XOR<CoffeeChatPurposeUpdateInput, CoffeeChatPurposeUncheckedUpdateInput>
    /**
     * Choose, which CoffeeChatPurpose to update.
     */
    where: CoffeeChatPurposeWhereUniqueInput
  }

  /**
   * CoffeeChatPurpose updateMany
   */
  export type CoffeeChatPurposeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CoffeeChatPurposes.
     */
    data: XOR<CoffeeChatPurposeUpdateManyMutationInput, CoffeeChatPurposeUncheckedUpdateManyInput>
    /**
     * Filter which CoffeeChatPurposes to update
     */
    where?: CoffeeChatPurposeWhereInput
    /**
     * Limit how many CoffeeChatPurposes to update.
     */
    limit?: number
  }

  /**
   * CoffeeChatPurpose updateManyAndReturn
   */
  export type CoffeeChatPurposeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChatPurpose
     */
    select?: CoffeeChatPurposeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChatPurpose
     */
    omit?: CoffeeChatPurposeOmit<ExtArgs> | null
    /**
     * The data used to update CoffeeChatPurposes.
     */
    data: XOR<CoffeeChatPurposeUpdateManyMutationInput, CoffeeChatPurposeUncheckedUpdateManyInput>
    /**
     * Filter which CoffeeChatPurposes to update
     */
    where?: CoffeeChatPurposeWhereInput
    /**
     * Limit how many CoffeeChatPurposes to update.
     */
    limit?: number
  }

  /**
   * CoffeeChatPurpose upsert
   */
  export type CoffeeChatPurposeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChatPurpose
     */
    select?: CoffeeChatPurposeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChatPurpose
     */
    omit?: CoffeeChatPurposeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatPurposeInclude<ExtArgs> | null
    /**
     * The filter to search for the CoffeeChatPurpose to update in case it exists.
     */
    where: CoffeeChatPurposeWhereUniqueInput
    /**
     * In case the CoffeeChatPurpose found by the `where` argument doesn't exist, create a new CoffeeChatPurpose with this data.
     */
    create: XOR<CoffeeChatPurposeCreateInput, CoffeeChatPurposeUncheckedCreateInput>
    /**
     * In case the CoffeeChatPurpose was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoffeeChatPurposeUpdateInput, CoffeeChatPurposeUncheckedUpdateInput>
  }

  /**
   * CoffeeChatPurpose delete
   */
  export type CoffeeChatPurposeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChatPurpose
     */
    select?: CoffeeChatPurposeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChatPurpose
     */
    omit?: CoffeeChatPurposeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatPurposeInclude<ExtArgs> | null
    /**
     * Filter which CoffeeChatPurpose to delete.
     */
    where: CoffeeChatPurposeWhereUniqueInput
  }

  /**
   * CoffeeChatPurpose deleteMany
   */
  export type CoffeeChatPurposeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoffeeChatPurposes to delete
     */
    where?: CoffeeChatPurposeWhereInput
    /**
     * Limit how many CoffeeChatPurposes to delete.
     */
    limit?: number
  }

  /**
   * CoffeeChatPurpose.coffeeChats
   */
  export type CoffeeChatPurpose$coffeeChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChat
     */
    select?: CoffeeChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChat
     */
    omit?: CoffeeChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatInclude<ExtArgs> | null
    where?: CoffeeChatWhereInput
    orderBy?: CoffeeChatOrderByWithRelationInput | CoffeeChatOrderByWithRelationInput[]
    cursor?: CoffeeChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoffeeChatScalarFieldEnum | CoffeeChatScalarFieldEnum[]
  }

  /**
   * CoffeeChatPurpose without action
   */
  export type CoffeeChatPurposeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChatPurpose
     */
    select?: CoffeeChatPurposeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChatPurpose
     */
    omit?: CoffeeChatPurposeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatPurposeInclude<ExtArgs> | null
  }


  /**
   * Model CoffeeChatVenue
   */

  export type AggregateCoffeeChatVenue = {
    _count: CoffeeChatVenueCountAggregateOutputType | null
    _avg: CoffeeChatVenueAvgAggregateOutputType | null
    _sum: CoffeeChatVenueSumAggregateOutputType | null
    _min: CoffeeChatVenueMinAggregateOutputType | null
    _max: CoffeeChatVenueMaxAggregateOutputType | null
  }

  export type CoffeeChatVenueAvgAggregateOutputType = {
    rating: number | null
  }

  export type CoffeeChatVenueSumAggregateOutputType = {
    rating: number | null
  }

  export type CoffeeChatVenueMinAggregateOutputType = {
    id: string | null
    venueName: string | null
    noiseLevel: $Enums.CoffeeChatVenueNoiseLevel | null
    description: string | null
    location: string | null
    rating: number | null
  }

  export type CoffeeChatVenueMaxAggregateOutputType = {
    id: string | null
    venueName: string | null
    noiseLevel: $Enums.CoffeeChatVenueNoiseLevel | null
    description: string | null
    location: string | null
    rating: number | null
  }

  export type CoffeeChatVenueCountAggregateOutputType = {
    id: number
    venueName: number
    noiseLevel: number
    description: number
    location: number
    rating: number
    tags: number
    _all: number
  }


  export type CoffeeChatVenueAvgAggregateInputType = {
    rating?: true
  }

  export type CoffeeChatVenueSumAggregateInputType = {
    rating?: true
  }

  export type CoffeeChatVenueMinAggregateInputType = {
    id?: true
    venueName?: true
    noiseLevel?: true
    description?: true
    location?: true
    rating?: true
  }

  export type CoffeeChatVenueMaxAggregateInputType = {
    id?: true
    venueName?: true
    noiseLevel?: true
    description?: true
    location?: true
    rating?: true
  }

  export type CoffeeChatVenueCountAggregateInputType = {
    id?: true
    venueName?: true
    noiseLevel?: true
    description?: true
    location?: true
    rating?: true
    tags?: true
    _all?: true
  }

  export type CoffeeChatVenueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoffeeChatVenue to aggregate.
     */
    where?: CoffeeChatVenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoffeeChatVenues to fetch.
     */
    orderBy?: CoffeeChatVenueOrderByWithRelationInput | CoffeeChatVenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoffeeChatVenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoffeeChatVenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoffeeChatVenues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoffeeChatVenues
    **/
    _count?: true | CoffeeChatVenueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CoffeeChatVenueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CoffeeChatVenueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoffeeChatVenueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoffeeChatVenueMaxAggregateInputType
  }

  export type GetCoffeeChatVenueAggregateType<T extends CoffeeChatVenueAggregateArgs> = {
        [P in keyof T & keyof AggregateCoffeeChatVenue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoffeeChatVenue[P]>
      : GetScalarType<T[P], AggregateCoffeeChatVenue[P]>
  }




  export type CoffeeChatVenueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoffeeChatVenueWhereInput
    orderBy?: CoffeeChatVenueOrderByWithAggregationInput | CoffeeChatVenueOrderByWithAggregationInput[]
    by: CoffeeChatVenueScalarFieldEnum[] | CoffeeChatVenueScalarFieldEnum
    having?: CoffeeChatVenueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoffeeChatVenueCountAggregateInputType | true
    _avg?: CoffeeChatVenueAvgAggregateInputType
    _sum?: CoffeeChatVenueSumAggregateInputType
    _min?: CoffeeChatVenueMinAggregateInputType
    _max?: CoffeeChatVenueMaxAggregateInputType
  }

  export type CoffeeChatVenueGroupByOutputType = {
    id: string
    venueName: string
    noiseLevel: $Enums.CoffeeChatVenueNoiseLevel
    description: string
    location: string
    rating: number
    tags: $Enums.CoffeeChatVenueTags[]
    _count: CoffeeChatVenueCountAggregateOutputType | null
    _avg: CoffeeChatVenueAvgAggregateOutputType | null
    _sum: CoffeeChatVenueSumAggregateOutputType | null
    _min: CoffeeChatVenueMinAggregateOutputType | null
    _max: CoffeeChatVenueMaxAggregateOutputType | null
  }

  type GetCoffeeChatVenueGroupByPayload<T extends CoffeeChatVenueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoffeeChatVenueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoffeeChatVenueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoffeeChatVenueGroupByOutputType[P]>
            : GetScalarType<T[P], CoffeeChatVenueGroupByOutputType[P]>
        }
      >
    >


  export type CoffeeChatVenueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    venueName?: boolean
    noiseLevel?: boolean
    description?: boolean
    location?: boolean
    rating?: boolean
    tags?: boolean
    coffeeChats?: boolean | CoffeeChatVenue$coffeeChatsArgs<ExtArgs>
    _count?: boolean | CoffeeChatVenueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coffeeChatVenue"]>

  export type CoffeeChatVenueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    venueName?: boolean
    noiseLevel?: boolean
    description?: boolean
    location?: boolean
    rating?: boolean
    tags?: boolean
  }, ExtArgs["result"]["coffeeChatVenue"]>

  export type CoffeeChatVenueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    venueName?: boolean
    noiseLevel?: boolean
    description?: boolean
    location?: boolean
    rating?: boolean
    tags?: boolean
  }, ExtArgs["result"]["coffeeChatVenue"]>

  export type CoffeeChatVenueSelectScalar = {
    id?: boolean
    venueName?: boolean
    noiseLevel?: boolean
    description?: boolean
    location?: boolean
    rating?: boolean
    tags?: boolean
  }

  export type CoffeeChatVenueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "venueName" | "noiseLevel" | "description" | "location" | "rating" | "tags", ExtArgs["result"]["coffeeChatVenue"]>
  export type CoffeeChatVenueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coffeeChats?: boolean | CoffeeChatVenue$coffeeChatsArgs<ExtArgs>
    _count?: boolean | CoffeeChatVenueCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CoffeeChatVenueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CoffeeChatVenueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CoffeeChatVenuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CoffeeChatVenue"
    objects: {
      coffeeChats: Prisma.$CoffeeChatPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      venueName: string
      noiseLevel: $Enums.CoffeeChatVenueNoiseLevel
      description: string
      location: string
      rating: number
      tags: $Enums.CoffeeChatVenueTags[]
    }, ExtArgs["result"]["coffeeChatVenue"]>
    composites: {}
  }

  type CoffeeChatVenueGetPayload<S extends boolean | null | undefined | CoffeeChatVenueDefaultArgs> = $Result.GetResult<Prisma.$CoffeeChatVenuePayload, S>

  type CoffeeChatVenueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CoffeeChatVenueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CoffeeChatVenueCountAggregateInputType | true
    }

  export interface CoffeeChatVenueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CoffeeChatVenue'], meta: { name: 'CoffeeChatVenue' } }
    /**
     * Find zero or one CoffeeChatVenue that matches the filter.
     * @param {CoffeeChatVenueFindUniqueArgs} args - Arguments to find a CoffeeChatVenue
     * @example
     * // Get one CoffeeChatVenue
     * const coffeeChatVenue = await prisma.coffeeChatVenue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CoffeeChatVenueFindUniqueArgs>(args: SelectSubset<T, CoffeeChatVenueFindUniqueArgs<ExtArgs>>): Prisma__CoffeeChatVenueClient<$Result.GetResult<Prisma.$CoffeeChatVenuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CoffeeChatVenue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CoffeeChatVenueFindUniqueOrThrowArgs} args - Arguments to find a CoffeeChatVenue
     * @example
     * // Get one CoffeeChatVenue
     * const coffeeChatVenue = await prisma.coffeeChatVenue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CoffeeChatVenueFindUniqueOrThrowArgs>(args: SelectSubset<T, CoffeeChatVenueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CoffeeChatVenueClient<$Result.GetResult<Prisma.$CoffeeChatVenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CoffeeChatVenue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoffeeChatVenueFindFirstArgs} args - Arguments to find a CoffeeChatVenue
     * @example
     * // Get one CoffeeChatVenue
     * const coffeeChatVenue = await prisma.coffeeChatVenue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CoffeeChatVenueFindFirstArgs>(args?: SelectSubset<T, CoffeeChatVenueFindFirstArgs<ExtArgs>>): Prisma__CoffeeChatVenueClient<$Result.GetResult<Prisma.$CoffeeChatVenuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CoffeeChatVenue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoffeeChatVenueFindFirstOrThrowArgs} args - Arguments to find a CoffeeChatVenue
     * @example
     * // Get one CoffeeChatVenue
     * const coffeeChatVenue = await prisma.coffeeChatVenue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CoffeeChatVenueFindFirstOrThrowArgs>(args?: SelectSubset<T, CoffeeChatVenueFindFirstOrThrowArgs<ExtArgs>>): Prisma__CoffeeChatVenueClient<$Result.GetResult<Prisma.$CoffeeChatVenuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CoffeeChatVenues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoffeeChatVenueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoffeeChatVenues
     * const coffeeChatVenues = await prisma.coffeeChatVenue.findMany()
     * 
     * // Get first 10 CoffeeChatVenues
     * const coffeeChatVenues = await prisma.coffeeChatVenue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coffeeChatVenueWithIdOnly = await prisma.coffeeChatVenue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CoffeeChatVenueFindManyArgs>(args?: SelectSubset<T, CoffeeChatVenueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoffeeChatVenuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CoffeeChatVenue.
     * @param {CoffeeChatVenueCreateArgs} args - Arguments to create a CoffeeChatVenue.
     * @example
     * // Create one CoffeeChatVenue
     * const CoffeeChatVenue = await prisma.coffeeChatVenue.create({
     *   data: {
     *     // ... data to create a CoffeeChatVenue
     *   }
     * })
     * 
     */
    create<T extends CoffeeChatVenueCreateArgs>(args: SelectSubset<T, CoffeeChatVenueCreateArgs<ExtArgs>>): Prisma__CoffeeChatVenueClient<$Result.GetResult<Prisma.$CoffeeChatVenuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CoffeeChatVenues.
     * @param {CoffeeChatVenueCreateManyArgs} args - Arguments to create many CoffeeChatVenues.
     * @example
     * // Create many CoffeeChatVenues
     * const coffeeChatVenue = await prisma.coffeeChatVenue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CoffeeChatVenueCreateManyArgs>(args?: SelectSubset<T, CoffeeChatVenueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CoffeeChatVenues and returns the data saved in the database.
     * @param {CoffeeChatVenueCreateManyAndReturnArgs} args - Arguments to create many CoffeeChatVenues.
     * @example
     * // Create many CoffeeChatVenues
     * const coffeeChatVenue = await prisma.coffeeChatVenue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CoffeeChatVenues and only return the `id`
     * const coffeeChatVenueWithIdOnly = await prisma.coffeeChatVenue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CoffeeChatVenueCreateManyAndReturnArgs>(args?: SelectSubset<T, CoffeeChatVenueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoffeeChatVenuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CoffeeChatVenue.
     * @param {CoffeeChatVenueDeleteArgs} args - Arguments to delete one CoffeeChatVenue.
     * @example
     * // Delete one CoffeeChatVenue
     * const CoffeeChatVenue = await prisma.coffeeChatVenue.delete({
     *   where: {
     *     // ... filter to delete one CoffeeChatVenue
     *   }
     * })
     * 
     */
    delete<T extends CoffeeChatVenueDeleteArgs>(args: SelectSubset<T, CoffeeChatVenueDeleteArgs<ExtArgs>>): Prisma__CoffeeChatVenueClient<$Result.GetResult<Prisma.$CoffeeChatVenuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CoffeeChatVenue.
     * @param {CoffeeChatVenueUpdateArgs} args - Arguments to update one CoffeeChatVenue.
     * @example
     * // Update one CoffeeChatVenue
     * const coffeeChatVenue = await prisma.coffeeChatVenue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CoffeeChatVenueUpdateArgs>(args: SelectSubset<T, CoffeeChatVenueUpdateArgs<ExtArgs>>): Prisma__CoffeeChatVenueClient<$Result.GetResult<Prisma.$CoffeeChatVenuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CoffeeChatVenues.
     * @param {CoffeeChatVenueDeleteManyArgs} args - Arguments to filter CoffeeChatVenues to delete.
     * @example
     * // Delete a few CoffeeChatVenues
     * const { count } = await prisma.coffeeChatVenue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CoffeeChatVenueDeleteManyArgs>(args?: SelectSubset<T, CoffeeChatVenueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoffeeChatVenues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoffeeChatVenueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoffeeChatVenues
     * const coffeeChatVenue = await prisma.coffeeChatVenue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CoffeeChatVenueUpdateManyArgs>(args: SelectSubset<T, CoffeeChatVenueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoffeeChatVenues and returns the data updated in the database.
     * @param {CoffeeChatVenueUpdateManyAndReturnArgs} args - Arguments to update many CoffeeChatVenues.
     * @example
     * // Update many CoffeeChatVenues
     * const coffeeChatVenue = await prisma.coffeeChatVenue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CoffeeChatVenues and only return the `id`
     * const coffeeChatVenueWithIdOnly = await prisma.coffeeChatVenue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CoffeeChatVenueUpdateManyAndReturnArgs>(args: SelectSubset<T, CoffeeChatVenueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoffeeChatVenuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CoffeeChatVenue.
     * @param {CoffeeChatVenueUpsertArgs} args - Arguments to update or create a CoffeeChatVenue.
     * @example
     * // Update or create a CoffeeChatVenue
     * const coffeeChatVenue = await prisma.coffeeChatVenue.upsert({
     *   create: {
     *     // ... data to create a CoffeeChatVenue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoffeeChatVenue we want to update
     *   }
     * })
     */
    upsert<T extends CoffeeChatVenueUpsertArgs>(args: SelectSubset<T, CoffeeChatVenueUpsertArgs<ExtArgs>>): Prisma__CoffeeChatVenueClient<$Result.GetResult<Prisma.$CoffeeChatVenuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CoffeeChatVenues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoffeeChatVenueCountArgs} args - Arguments to filter CoffeeChatVenues to count.
     * @example
     * // Count the number of CoffeeChatVenues
     * const count = await prisma.coffeeChatVenue.count({
     *   where: {
     *     // ... the filter for the CoffeeChatVenues we want to count
     *   }
     * })
    **/
    count<T extends CoffeeChatVenueCountArgs>(
      args?: Subset<T, CoffeeChatVenueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoffeeChatVenueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoffeeChatVenue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoffeeChatVenueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoffeeChatVenueAggregateArgs>(args: Subset<T, CoffeeChatVenueAggregateArgs>): Prisma.PrismaPromise<GetCoffeeChatVenueAggregateType<T>>

    /**
     * Group by CoffeeChatVenue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoffeeChatVenueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoffeeChatVenueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoffeeChatVenueGroupByArgs['orderBy'] }
        : { orderBy?: CoffeeChatVenueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoffeeChatVenueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoffeeChatVenueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CoffeeChatVenue model
   */
  readonly fields: CoffeeChatVenueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CoffeeChatVenue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoffeeChatVenueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coffeeChats<T extends CoffeeChatVenue$coffeeChatsArgs<ExtArgs> = {}>(args?: Subset<T, CoffeeChatVenue$coffeeChatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoffeeChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CoffeeChatVenue model
   */
  interface CoffeeChatVenueFieldRefs {
    readonly id: FieldRef<"CoffeeChatVenue", 'String'>
    readonly venueName: FieldRef<"CoffeeChatVenue", 'String'>
    readonly noiseLevel: FieldRef<"CoffeeChatVenue", 'CoffeeChatVenueNoiseLevel'>
    readonly description: FieldRef<"CoffeeChatVenue", 'String'>
    readonly location: FieldRef<"CoffeeChatVenue", 'String'>
    readonly rating: FieldRef<"CoffeeChatVenue", 'Int'>
    readonly tags: FieldRef<"CoffeeChatVenue", 'CoffeeChatVenueTags[]'>
  }
    

  // Custom InputTypes
  /**
   * CoffeeChatVenue findUnique
   */
  export type CoffeeChatVenueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChatVenue
     */
    select?: CoffeeChatVenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChatVenue
     */
    omit?: CoffeeChatVenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatVenueInclude<ExtArgs> | null
    /**
     * Filter, which CoffeeChatVenue to fetch.
     */
    where: CoffeeChatVenueWhereUniqueInput
  }

  /**
   * CoffeeChatVenue findUniqueOrThrow
   */
  export type CoffeeChatVenueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChatVenue
     */
    select?: CoffeeChatVenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChatVenue
     */
    omit?: CoffeeChatVenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatVenueInclude<ExtArgs> | null
    /**
     * Filter, which CoffeeChatVenue to fetch.
     */
    where: CoffeeChatVenueWhereUniqueInput
  }

  /**
   * CoffeeChatVenue findFirst
   */
  export type CoffeeChatVenueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChatVenue
     */
    select?: CoffeeChatVenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChatVenue
     */
    omit?: CoffeeChatVenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatVenueInclude<ExtArgs> | null
    /**
     * Filter, which CoffeeChatVenue to fetch.
     */
    where?: CoffeeChatVenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoffeeChatVenues to fetch.
     */
    orderBy?: CoffeeChatVenueOrderByWithRelationInput | CoffeeChatVenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoffeeChatVenues.
     */
    cursor?: CoffeeChatVenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoffeeChatVenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoffeeChatVenues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoffeeChatVenues.
     */
    distinct?: CoffeeChatVenueScalarFieldEnum | CoffeeChatVenueScalarFieldEnum[]
  }

  /**
   * CoffeeChatVenue findFirstOrThrow
   */
  export type CoffeeChatVenueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChatVenue
     */
    select?: CoffeeChatVenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChatVenue
     */
    omit?: CoffeeChatVenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatVenueInclude<ExtArgs> | null
    /**
     * Filter, which CoffeeChatVenue to fetch.
     */
    where?: CoffeeChatVenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoffeeChatVenues to fetch.
     */
    orderBy?: CoffeeChatVenueOrderByWithRelationInput | CoffeeChatVenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoffeeChatVenues.
     */
    cursor?: CoffeeChatVenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoffeeChatVenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoffeeChatVenues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoffeeChatVenues.
     */
    distinct?: CoffeeChatVenueScalarFieldEnum | CoffeeChatVenueScalarFieldEnum[]
  }

  /**
   * CoffeeChatVenue findMany
   */
  export type CoffeeChatVenueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChatVenue
     */
    select?: CoffeeChatVenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChatVenue
     */
    omit?: CoffeeChatVenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatVenueInclude<ExtArgs> | null
    /**
     * Filter, which CoffeeChatVenues to fetch.
     */
    where?: CoffeeChatVenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoffeeChatVenues to fetch.
     */
    orderBy?: CoffeeChatVenueOrderByWithRelationInput | CoffeeChatVenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoffeeChatVenues.
     */
    cursor?: CoffeeChatVenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoffeeChatVenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoffeeChatVenues.
     */
    skip?: number
    distinct?: CoffeeChatVenueScalarFieldEnum | CoffeeChatVenueScalarFieldEnum[]
  }

  /**
   * CoffeeChatVenue create
   */
  export type CoffeeChatVenueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChatVenue
     */
    select?: CoffeeChatVenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChatVenue
     */
    omit?: CoffeeChatVenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatVenueInclude<ExtArgs> | null
    /**
     * The data needed to create a CoffeeChatVenue.
     */
    data: XOR<CoffeeChatVenueCreateInput, CoffeeChatVenueUncheckedCreateInput>
  }

  /**
   * CoffeeChatVenue createMany
   */
  export type CoffeeChatVenueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CoffeeChatVenues.
     */
    data: CoffeeChatVenueCreateManyInput | CoffeeChatVenueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CoffeeChatVenue createManyAndReturn
   */
  export type CoffeeChatVenueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChatVenue
     */
    select?: CoffeeChatVenueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChatVenue
     */
    omit?: CoffeeChatVenueOmit<ExtArgs> | null
    /**
     * The data used to create many CoffeeChatVenues.
     */
    data: CoffeeChatVenueCreateManyInput | CoffeeChatVenueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CoffeeChatVenue update
   */
  export type CoffeeChatVenueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChatVenue
     */
    select?: CoffeeChatVenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChatVenue
     */
    omit?: CoffeeChatVenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatVenueInclude<ExtArgs> | null
    /**
     * The data needed to update a CoffeeChatVenue.
     */
    data: XOR<CoffeeChatVenueUpdateInput, CoffeeChatVenueUncheckedUpdateInput>
    /**
     * Choose, which CoffeeChatVenue to update.
     */
    where: CoffeeChatVenueWhereUniqueInput
  }

  /**
   * CoffeeChatVenue updateMany
   */
  export type CoffeeChatVenueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CoffeeChatVenues.
     */
    data: XOR<CoffeeChatVenueUpdateManyMutationInput, CoffeeChatVenueUncheckedUpdateManyInput>
    /**
     * Filter which CoffeeChatVenues to update
     */
    where?: CoffeeChatVenueWhereInput
    /**
     * Limit how many CoffeeChatVenues to update.
     */
    limit?: number
  }

  /**
   * CoffeeChatVenue updateManyAndReturn
   */
  export type CoffeeChatVenueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChatVenue
     */
    select?: CoffeeChatVenueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChatVenue
     */
    omit?: CoffeeChatVenueOmit<ExtArgs> | null
    /**
     * The data used to update CoffeeChatVenues.
     */
    data: XOR<CoffeeChatVenueUpdateManyMutationInput, CoffeeChatVenueUncheckedUpdateManyInput>
    /**
     * Filter which CoffeeChatVenues to update
     */
    where?: CoffeeChatVenueWhereInput
    /**
     * Limit how many CoffeeChatVenues to update.
     */
    limit?: number
  }

  /**
   * CoffeeChatVenue upsert
   */
  export type CoffeeChatVenueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChatVenue
     */
    select?: CoffeeChatVenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChatVenue
     */
    omit?: CoffeeChatVenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatVenueInclude<ExtArgs> | null
    /**
     * The filter to search for the CoffeeChatVenue to update in case it exists.
     */
    where: CoffeeChatVenueWhereUniqueInput
    /**
     * In case the CoffeeChatVenue found by the `where` argument doesn't exist, create a new CoffeeChatVenue with this data.
     */
    create: XOR<CoffeeChatVenueCreateInput, CoffeeChatVenueUncheckedCreateInput>
    /**
     * In case the CoffeeChatVenue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoffeeChatVenueUpdateInput, CoffeeChatVenueUncheckedUpdateInput>
  }

  /**
   * CoffeeChatVenue delete
   */
  export type CoffeeChatVenueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChatVenue
     */
    select?: CoffeeChatVenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChatVenue
     */
    omit?: CoffeeChatVenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatVenueInclude<ExtArgs> | null
    /**
     * Filter which CoffeeChatVenue to delete.
     */
    where: CoffeeChatVenueWhereUniqueInput
  }

  /**
   * CoffeeChatVenue deleteMany
   */
  export type CoffeeChatVenueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoffeeChatVenues to delete
     */
    where?: CoffeeChatVenueWhereInput
    /**
     * Limit how many CoffeeChatVenues to delete.
     */
    limit?: number
  }

  /**
   * CoffeeChatVenue.coffeeChats
   */
  export type CoffeeChatVenue$coffeeChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChat
     */
    select?: CoffeeChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChat
     */
    omit?: CoffeeChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatInclude<ExtArgs> | null
    where?: CoffeeChatWhereInput
    orderBy?: CoffeeChatOrderByWithRelationInput | CoffeeChatOrderByWithRelationInput[]
    cursor?: CoffeeChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoffeeChatScalarFieldEnum | CoffeeChatScalarFieldEnum[]
  }

  /**
   * CoffeeChatVenue without action
   */
  export type CoffeeChatVenueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoffeeChatVenue
     */
    select?: CoffeeChatVenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoffeeChatVenue
     */
    omit?: CoffeeChatVenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoffeeChatVenueInclude<ExtArgs> | null
  }


  /**
   * Model Chat
   */

  export type AggregateChat = {
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  export type ChatMinAggregateOutputType = {
    id: string | null
    user1Id: string | null
    user2Id: string | null
    name: string | null
  }

  export type ChatMaxAggregateOutputType = {
    id: string | null
    user1Id: string | null
    user2Id: string | null
    name: string | null
  }

  export type ChatCountAggregateOutputType = {
    id: number
    user1Id: number
    user2Id: number
    name: number
    _all: number
  }


  export type ChatMinAggregateInputType = {
    id?: true
    user1Id?: true
    user2Id?: true
    name?: true
  }

  export type ChatMaxAggregateInputType = {
    id?: true
    user1Id?: true
    user2Id?: true
    name?: true
  }

  export type ChatCountAggregateInputType = {
    id?: true
    user1Id?: true
    user2Id?: true
    name?: true
    _all?: true
  }

  export type ChatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chat to aggregate.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chats
    **/
    _count?: true | ChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMaxAggregateInputType
  }

  export type GetChatAggregateType<T extends ChatAggregateArgs> = {
        [P in keyof T & keyof AggregateChat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat[P]>
      : GetScalarType<T[P], AggregateChat[P]>
  }




  export type ChatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithAggregationInput | ChatOrderByWithAggregationInput[]
    by: ChatScalarFieldEnum[] | ChatScalarFieldEnum
    having?: ChatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatCountAggregateInputType | true
    _min?: ChatMinAggregateInputType
    _max?: ChatMaxAggregateInputType
  }

  export type ChatGroupByOutputType = {
    id: string
    user1Id: string
    user2Id: string
    name: string | null
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  type GetChatGroupByPayload<T extends ChatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatGroupByOutputType[P]>
            : GetScalarType<T[P], ChatGroupByOutputType[P]>
        }
      >
    >


  export type ChatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user1Id?: boolean
    user2Id?: boolean
    name?: boolean
    user1?: boolean | UserDetailsDefaultArgs<ExtArgs>
    user2?: boolean | UserDetailsDefaultArgs<ExtArgs>
    messages?: boolean | Chat$messagesArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user1Id?: boolean
    user2Id?: boolean
    name?: boolean
    user1?: boolean | UserDetailsDefaultArgs<ExtArgs>
    user2?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user1Id?: boolean
    user2Id?: boolean
    name?: boolean
    user1?: boolean | UserDetailsDefaultArgs<ExtArgs>
    user2?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectScalar = {
    id?: boolean
    user1Id?: boolean
    user2Id?: boolean
    name?: boolean
  }

  export type ChatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user1Id" | "user2Id" | "name", ExtArgs["result"]["chat"]>
  export type ChatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user1?: boolean | UserDetailsDefaultArgs<ExtArgs>
    user2?: boolean | UserDetailsDefaultArgs<ExtArgs>
    messages?: boolean | Chat$messagesArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user1?: boolean | UserDetailsDefaultArgs<ExtArgs>
    user2?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }
  export type ChatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user1?: boolean | UserDetailsDefaultArgs<ExtArgs>
    user2?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }

  export type $ChatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chat"
    objects: {
      user1: Prisma.$UserDetailsPayload<ExtArgs>
      user2: Prisma.$UserDetailsPayload<ExtArgs>
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user1Id: string
      user2Id: string
      name: string | null
    }, ExtArgs["result"]["chat"]>
    composites: {}
  }

  type ChatGetPayload<S extends boolean | null | undefined | ChatDefaultArgs> = $Result.GetResult<Prisma.$ChatPayload, S>

  type ChatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatCountAggregateInputType | true
    }

  export interface ChatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chat'], meta: { name: 'Chat' } }
    /**
     * Find zero or one Chat that matches the filter.
     * @param {ChatFindUniqueArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatFindUniqueArgs>(args: SelectSubset<T, ChatFindUniqueArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatFindUniqueOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatFindFirstArgs>(args?: SelectSubset<T, ChatFindFirstArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chats
     * const chats = await prisma.chat.findMany()
     * 
     * // Get first 10 Chats
     * const chats = await prisma.chat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatWithIdOnly = await prisma.chat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatFindManyArgs>(args?: SelectSubset<T, ChatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chat.
     * @param {ChatCreateArgs} args - Arguments to create a Chat.
     * @example
     * // Create one Chat
     * const Chat = await prisma.chat.create({
     *   data: {
     *     // ... data to create a Chat
     *   }
     * })
     * 
     */
    create<T extends ChatCreateArgs>(args: SelectSubset<T, ChatCreateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chats.
     * @param {ChatCreateManyArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatCreateManyArgs>(args?: SelectSubset<T, ChatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chats and returns the data saved in the database.
     * @param {ChatCreateManyAndReturnArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chats and only return the `id`
     * const chatWithIdOnly = await prisma.chat.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chat.
     * @param {ChatDeleteArgs} args - Arguments to delete one Chat.
     * @example
     * // Delete one Chat
     * const Chat = await prisma.chat.delete({
     *   where: {
     *     // ... filter to delete one Chat
     *   }
     * })
     * 
     */
    delete<T extends ChatDeleteArgs>(args: SelectSubset<T, ChatDeleteArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chat.
     * @param {ChatUpdateArgs} args - Arguments to update one Chat.
     * @example
     * // Update one Chat
     * const chat = await prisma.chat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatUpdateArgs>(args: SelectSubset<T, ChatUpdateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chats.
     * @param {ChatDeleteManyArgs} args - Arguments to filter Chats to delete.
     * @example
     * // Delete a few Chats
     * const { count } = await prisma.chat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatDeleteManyArgs>(args?: SelectSubset<T, ChatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatUpdateManyArgs>(args: SelectSubset<T, ChatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats and returns the data updated in the database.
     * @param {ChatUpdateManyAndReturnArgs} args - Arguments to update many Chats.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chats and only return the `id`
     * const chatWithIdOnly = await prisma.chat.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chat.
     * @param {ChatUpsertArgs} args - Arguments to update or create a Chat.
     * @example
     * // Update or create a Chat
     * const chat = await prisma.chat.upsert({
     *   create: {
     *     // ... data to create a Chat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat we want to update
     *   }
     * })
     */
    upsert<T extends ChatUpsertArgs>(args: SelectSubset<T, ChatUpsertArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatCountArgs} args - Arguments to filter Chats to count.
     * @example
     * // Count the number of Chats
     * const count = await prisma.chat.count({
     *   where: {
     *     // ... the filter for the Chats we want to count
     *   }
     * })
    **/
    count<T extends ChatCountArgs>(
      args?: Subset<T, ChatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatAggregateArgs>(args: Subset<T, ChatAggregateArgs>): Prisma.PrismaPromise<GetChatAggregateType<T>>

    /**
     * Group by Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatGroupByArgs['orderBy'] }
        : { orderBy?: ChatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chat model
   */
  readonly fields: ChatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user1<T extends UserDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDetailsDefaultArgs<ExtArgs>>): Prisma__UserDetailsClient<$Result.GetResult<Prisma.$UserDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user2<T extends UserDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDetailsDefaultArgs<ExtArgs>>): Prisma__UserDetailsClient<$Result.GetResult<Prisma.$UserDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends Chat$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Chat$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chat model
   */
  interface ChatFieldRefs {
    readonly id: FieldRef<"Chat", 'String'>
    readonly user1Id: FieldRef<"Chat", 'String'>
    readonly user2Id: FieldRef<"Chat", 'String'>
    readonly name: FieldRef<"Chat", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Chat findUnique
   */
  export type ChatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findUniqueOrThrow
   */
  export type ChatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findFirst
   */
  export type ChatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findFirstOrThrow
   */
  export type ChatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findMany
   */
  export type ChatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chats to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat create
   */
  export type ChatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to create a Chat.
     */
    data: XOR<ChatCreateInput, ChatUncheckedCreateInput>
  }

  /**
   * Chat createMany
   */
  export type ChatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chat createManyAndReturn
   */
  export type ChatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chat update
   */
  export type ChatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to update a Chat.
     */
    data: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
    /**
     * Choose, which Chat to update.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat updateMany
   */
  export type ChatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chats.
     */
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyInput>
    /**
     * Filter which Chats to update
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to update.
     */
    limit?: number
  }

  /**
   * Chat updateManyAndReturn
   */
  export type ChatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * The data used to update Chats.
     */
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyInput>
    /**
     * Filter which Chats to update
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chat upsert
   */
  export type ChatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The filter to search for the Chat to update in case it exists.
     */
    where: ChatWhereUniqueInput
    /**
     * In case the Chat found by the `where` argument doesn't exist, create a new Chat with this data.
     */
    create: XOR<ChatCreateInput, ChatUncheckedCreateInput>
    /**
     * In case the Chat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
  }

  /**
   * Chat delete
   */
  export type ChatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter which Chat to delete.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat deleteMany
   */
  export type ChatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chats to delete
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to delete.
     */
    limit?: number
  }

  /**
   * Chat.messages
   */
  export type Chat$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Chat without action
   */
  export type ChatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    chatId: string | null
    senderId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    chatId: string | null
    senderId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    chatId: number
    senderId: number
    content: number
    createdAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    chatId?: true
    senderId?: true
    content?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    chatId?: true
    senderId?: true
    content?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    chatId?: true
    senderId?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    chatId: string
    senderId: string
    content: string
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    senderId?: boolean
    content?: boolean
    createdAt?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    sender?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    senderId?: boolean
    content?: boolean
    createdAt?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    sender?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    senderId?: boolean
    content?: boolean
    createdAt?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    sender?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    chatId?: boolean
    senderId?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chatId" | "senderId" | "content" | "createdAt", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    sender?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    sender?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    sender?: boolean | UserDetailsDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      chat: Prisma.$ChatPayload<ExtArgs>
      sender: Prisma.$UserDetailsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chatId: string
      senderId: string
      content: string
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chat<T extends ChatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatDefaultArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends UserDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDetailsDefaultArgs<ExtArgs>>): Prisma__UserDetailsClient<$Result.GetResult<Prisma.$UserDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly chatId: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserDetailsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    department: 'department',
    year: 'year',
    profilePicture: 'profilePicture',
    bio: 'bio',
    availability: 'availability',
    reading: 'reading'
  };

  export type UserDetailsScalarFieldEnum = (typeof UserDetailsScalarFieldEnum)[keyof typeof UserDetailsScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    authorId: 'authorId',
    content: 'content',
    commentCount: 'commentCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const ReactionScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    likes: 'likes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReactionScalarFieldEnum = (typeof ReactionScalarFieldEnum)[keyof typeof ReactionScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    authorId: 'authorId',
    commentContent: 'commentContent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const PostTagScalarFieldEnum: {
    id: 'id',
    tagName: 'tagName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PostTagScalarFieldEnum = (typeof PostTagScalarFieldEnum)[keyof typeof PostTagScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userDetailsId: 'userDetailsId',
    notificationType: 'notificationType',
    notificationData: 'notificationData',
    read: 'read',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const InterestScalarFieldEnum: {
    id: 'id',
    interestName: 'interestName'
  };

  export type InterestScalarFieldEnum = (typeof InterestScalarFieldEnum)[keyof typeof InterestScalarFieldEnum]


  export const MatchScalarFieldEnum: {
    id: 'id',
    inviterId: 'inviterId',
    inviteeId: 'inviteeId',
    matchScore: 'matchScore',
    matchStatus: 'matchStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MatchScalarFieldEnum = (typeof MatchScalarFieldEnum)[keyof typeof MatchScalarFieldEnum]


  export const UserSimilarityScalarFieldEnum: {
    id: 'id',
    currentUserId: 'currentUserId',
    otherUserId: 'otherUserId',
    similarityScore: 'similarityScore',
    factors: 'factors',
    createdAt: 'createdAt'
  };

  export type UserSimilarityScalarFieldEnum = (typeof UserSimilarityScalarFieldEnum)[keyof typeof UserSimilarityScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    location: 'location',
    date: 'date',
    time: 'time',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const CoffeeChatScalarFieldEnum: {
    id: 'id',
    inviterId: 'inviterId',
    inviteeId: 'inviteeId',
    purposeId: 'purposeId',
    venueId: 'venueId',
    scheduledAt: 'scheduledAt',
    duration: 'duration',
    personalMessage: 'personalMessage',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CoffeeChatScalarFieldEnum = (typeof CoffeeChatScalarFieldEnum)[keyof typeof CoffeeChatScalarFieldEnum]


  export const CoffeeChatPurposeScalarFieldEnum: {
    id: 'id',
    purposeName: 'purposeName',
    description: 'description',
    timeLimit: 'timeLimit'
  };

  export type CoffeeChatPurposeScalarFieldEnum = (typeof CoffeeChatPurposeScalarFieldEnum)[keyof typeof CoffeeChatPurposeScalarFieldEnum]


  export const CoffeeChatVenueScalarFieldEnum: {
    id: 'id',
    venueName: 'venueName',
    noiseLevel: 'noiseLevel',
    description: 'description',
    location: 'location',
    rating: 'rating',
    tags: 'tags'
  };

  export type CoffeeChatVenueScalarFieldEnum = (typeof CoffeeChatVenueScalarFieldEnum)[keyof typeof CoffeeChatVenueScalarFieldEnum]


  export const ChatScalarFieldEnum: {
    id: 'id',
    user1Id: 'user1Id',
    user2Id: 'user2Id',
    name: 'name'
  };

  export type ChatScalarFieldEnum = (typeof ChatScalarFieldEnum)[keyof typeof ChatScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    chatId: 'chatId',
    senderId: 'senderId',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'MatchStatus'
   */
  export type EnumMatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchStatus'>
    


  /**
   * Reference to a field of type 'MatchStatus[]'
   */
  export type ListEnumMatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'CoffeeChatStatus'
   */
  export type EnumCoffeeChatStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CoffeeChatStatus'>
    


  /**
   * Reference to a field of type 'CoffeeChatStatus[]'
   */
  export type ListEnumCoffeeChatStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CoffeeChatStatus[]'>
    


  /**
   * Reference to a field of type 'CoffeeChatVenueNoiseLevel'
   */
  export type EnumCoffeeChatVenueNoiseLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CoffeeChatVenueNoiseLevel'>
    


  /**
   * Reference to a field of type 'CoffeeChatVenueNoiseLevel[]'
   */
  export type ListEnumCoffeeChatVenueNoiseLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CoffeeChatVenueNoiseLevel[]'>
    


  /**
   * Reference to a field of type 'CoffeeChatVenueTags[]'
   */
  export type ListEnumCoffeeChatVenueTagsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CoffeeChatVenueTags[]'>
    


  /**
   * Reference to a field of type 'CoffeeChatVenueTags'
   */
  export type EnumCoffeeChatVenueTagsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CoffeeChatVenueTags'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    userDetails?: XOR<UserDetailsNullableScalarRelationFilter, UserDetailsWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userDetails?: UserDetailsOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    userDetails?: XOR<UserDetailsNullableScalarRelationFilter, UserDetailsWhereInput> | null
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserDetailsWhereInput = {
    AND?: UserDetailsWhereInput | UserDetailsWhereInput[]
    OR?: UserDetailsWhereInput[]
    NOT?: UserDetailsWhereInput | UserDetailsWhereInput[]
    id?: StringFilter<"UserDetails"> | string
    userId?: StringFilter<"UserDetails"> | string
    name?: StringFilter<"UserDetails"> | string
    department?: StringNullableFilter<"UserDetails"> | string | null
    year?: StringNullableFilter<"UserDetails"> | string | null
    profilePicture?: StringNullableFilter<"UserDetails"> | string | null
    bio?: StringNullableFilter<"UserDetails"> | string | null
    availability?: StringNullableFilter<"UserDetails"> | string | null
    reading?: StringNullableFilter<"UserDetails"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    posts?: PostListRelationFilter
    comments?: CommentListRelationFilter
    notifications?: NotificationListRelationFilter
    interests?: InterestListRelationFilter
    matchesSent?: MatchListRelationFilter
    matchesReceived?: MatchListRelationFilter
    currentUserSimilarity?: UserSimilarityListRelationFilter
    otherUserSimilarity?: UserSimilarityListRelationFilter
    asEventAttendee?: EventListRelationFilter
    asEventOrganizer?: EventListRelationFilter
    coffeeChatsSent?: CoffeeChatListRelationFilter
    coffeeChatsReceived?: CoffeeChatListRelationFilter
    chatsAsUser1?: ChatListRelationFilter
    chatsAsUser2?: ChatListRelationFilter
    messagesSent?: MessageListRelationFilter
  }

  export type UserDetailsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    department?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    availability?: SortOrderInput | SortOrder
    reading?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    posts?: PostOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    interests?: InterestOrderByRelationAggregateInput
    matchesSent?: MatchOrderByRelationAggregateInput
    matchesReceived?: MatchOrderByRelationAggregateInput
    currentUserSimilarity?: UserSimilarityOrderByRelationAggregateInput
    otherUserSimilarity?: UserSimilarityOrderByRelationAggregateInput
    asEventAttendee?: EventOrderByRelationAggregateInput
    asEventOrganizer?: EventOrderByRelationAggregateInput
    coffeeChatsSent?: CoffeeChatOrderByRelationAggregateInput
    coffeeChatsReceived?: CoffeeChatOrderByRelationAggregateInput
    chatsAsUser1?: ChatOrderByRelationAggregateInput
    chatsAsUser2?: ChatOrderByRelationAggregateInput
    messagesSent?: MessageOrderByRelationAggregateInput
  }

  export type UserDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserDetailsWhereInput | UserDetailsWhereInput[]
    OR?: UserDetailsWhereInput[]
    NOT?: UserDetailsWhereInput | UserDetailsWhereInput[]
    name?: StringFilter<"UserDetails"> | string
    department?: StringNullableFilter<"UserDetails"> | string | null
    year?: StringNullableFilter<"UserDetails"> | string | null
    profilePicture?: StringNullableFilter<"UserDetails"> | string | null
    bio?: StringNullableFilter<"UserDetails"> | string | null
    availability?: StringNullableFilter<"UserDetails"> | string | null
    reading?: StringNullableFilter<"UserDetails"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    posts?: PostListRelationFilter
    comments?: CommentListRelationFilter
    notifications?: NotificationListRelationFilter
    interests?: InterestListRelationFilter
    matchesSent?: MatchListRelationFilter
    matchesReceived?: MatchListRelationFilter
    currentUserSimilarity?: UserSimilarityListRelationFilter
    otherUserSimilarity?: UserSimilarityListRelationFilter
    asEventAttendee?: EventListRelationFilter
    asEventOrganizer?: EventListRelationFilter
    coffeeChatsSent?: CoffeeChatListRelationFilter
    coffeeChatsReceived?: CoffeeChatListRelationFilter
    chatsAsUser1?: ChatListRelationFilter
    chatsAsUser2?: ChatListRelationFilter
    messagesSent?: MessageListRelationFilter
  }, "id" | "userId">

  export type UserDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    department?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    availability?: SortOrderInput | SortOrder
    reading?: SortOrderInput | SortOrder
    _count?: UserDetailsCountOrderByAggregateInput
    _max?: UserDetailsMaxOrderByAggregateInput
    _min?: UserDetailsMinOrderByAggregateInput
  }

  export type UserDetailsScalarWhereWithAggregatesInput = {
    AND?: UserDetailsScalarWhereWithAggregatesInput | UserDetailsScalarWhereWithAggregatesInput[]
    OR?: UserDetailsScalarWhereWithAggregatesInput[]
    NOT?: UserDetailsScalarWhereWithAggregatesInput | UserDetailsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserDetails"> | string
    userId?: StringWithAggregatesFilter<"UserDetails"> | string
    name?: StringWithAggregatesFilter<"UserDetails"> | string
    department?: StringNullableWithAggregatesFilter<"UserDetails"> | string | null
    year?: StringNullableWithAggregatesFilter<"UserDetails"> | string | null
    profilePicture?: StringNullableWithAggregatesFilter<"UserDetails"> | string | null
    bio?: StringNullableWithAggregatesFilter<"UserDetails"> | string | null
    availability?: StringNullableWithAggregatesFilter<"UserDetails"> | string | null
    reading?: StringNullableWithAggregatesFilter<"UserDetails"> | string | null
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: StringFilter<"Post"> | string
    authorId?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    commentCount?: IntFilter<"Post"> | number
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    author?: XOR<UserDetailsScalarRelationFilter, UserDetailsWhereInput>
    reaction?: XOR<ReactionNullableScalarRelationFilter, ReactionWhereInput> | null
    postTags?: PostTagListRelationFilter
    comments?: CommentListRelationFilter
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    commentCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserDetailsOrderByWithRelationInput
    reaction?: ReactionOrderByWithRelationInput
    postTags?: PostTagOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    authorId?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    commentCount?: IntFilter<"Post"> | number
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    author?: XOR<UserDetailsScalarRelationFilter, UserDetailsWhereInput>
    reaction?: XOR<ReactionNullableScalarRelationFilter, ReactionWhereInput> | null
    postTags?: PostTagListRelationFilter
    comments?: CommentListRelationFilter
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    commentCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Post"> | string
    authorId?: StringWithAggregatesFilter<"Post"> | string
    content?: StringWithAggregatesFilter<"Post"> | string
    commentCount?: IntWithAggregatesFilter<"Post"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
  }

  export type ReactionWhereInput = {
    AND?: ReactionWhereInput | ReactionWhereInput[]
    OR?: ReactionWhereInput[]
    NOT?: ReactionWhereInput | ReactionWhereInput[]
    id?: StringFilter<"Reaction"> | string
    postId?: StringFilter<"Reaction"> | string
    likes?: IntFilter<"Reaction"> | number
    createdAt?: DateTimeFilter<"Reaction"> | Date | string
    updatedAt?: DateTimeFilter<"Reaction"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
  }

  export type ReactionOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    post?: PostOrderByWithRelationInput
  }

  export type ReactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    postId?: string
    AND?: ReactionWhereInput | ReactionWhereInput[]
    OR?: ReactionWhereInput[]
    NOT?: ReactionWhereInput | ReactionWhereInput[]
    likes?: IntFilter<"Reaction"> | number
    createdAt?: DateTimeFilter<"Reaction"> | Date | string
    updatedAt?: DateTimeFilter<"Reaction"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
  }, "id" | "postId">

  export type ReactionOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReactionCountOrderByAggregateInput
    _avg?: ReactionAvgOrderByAggregateInput
    _max?: ReactionMaxOrderByAggregateInput
    _min?: ReactionMinOrderByAggregateInput
    _sum?: ReactionSumOrderByAggregateInput
  }

  export type ReactionScalarWhereWithAggregatesInput = {
    AND?: ReactionScalarWhereWithAggregatesInput | ReactionScalarWhereWithAggregatesInput[]
    OR?: ReactionScalarWhereWithAggregatesInput[]
    NOT?: ReactionScalarWhereWithAggregatesInput | ReactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reaction"> | string
    postId?: StringWithAggregatesFilter<"Reaction"> | string
    likes?: IntWithAggregatesFilter<"Reaction"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Reaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Reaction"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    commentContent?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    author?: XOR<UserDetailsScalarRelationFilter, UserDetailsWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    commentContent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    post?: PostOrderByWithRelationInput
    author?: UserDetailsOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    postId?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    commentContent?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    author?: XOR<UserDetailsScalarRelationFilter, UserDetailsWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    commentContent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    postId?: StringWithAggregatesFilter<"Comment"> | string
    authorId?: StringWithAggregatesFilter<"Comment"> | string
    commentContent?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type PostTagWhereInput = {
    AND?: PostTagWhereInput | PostTagWhereInput[]
    OR?: PostTagWhereInput[]
    NOT?: PostTagWhereInput | PostTagWhereInput[]
    id?: StringFilter<"PostTag"> | string
    tagName?: StringFilter<"PostTag"> | string
    createdAt?: DateTimeFilter<"PostTag"> | Date | string
    updatedAt?: DateTimeFilter<"PostTag"> | Date | string
    posts?: PostListRelationFilter
  }

  export type PostTagOrderByWithRelationInput = {
    id?: SortOrder
    tagName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    posts?: PostOrderByRelationAggregateInput
  }

  export type PostTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tagName?: string
    AND?: PostTagWhereInput | PostTagWhereInput[]
    OR?: PostTagWhereInput[]
    NOT?: PostTagWhereInput | PostTagWhereInput[]
    createdAt?: DateTimeFilter<"PostTag"> | Date | string
    updatedAt?: DateTimeFilter<"PostTag"> | Date | string
    posts?: PostListRelationFilter
  }, "id" | "tagName">

  export type PostTagOrderByWithAggregationInput = {
    id?: SortOrder
    tagName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PostTagCountOrderByAggregateInput
    _max?: PostTagMaxOrderByAggregateInput
    _min?: PostTagMinOrderByAggregateInput
  }

  export type PostTagScalarWhereWithAggregatesInput = {
    AND?: PostTagScalarWhereWithAggregatesInput | PostTagScalarWhereWithAggregatesInput[]
    OR?: PostTagScalarWhereWithAggregatesInput[]
    NOT?: PostTagScalarWhereWithAggregatesInput | PostTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostTag"> | string
    tagName?: StringWithAggregatesFilter<"PostTag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PostTag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PostTag"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userDetailsId?: StringFilter<"Notification"> | string
    notificationType?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    notificationData?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    userDetails?: XOR<UserDetailsScalarRelationFilter, UserDetailsWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userDetailsId?: SortOrder
    notificationType?: SortOrder
    notificationData?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userDetails?: UserDetailsOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userDetailsId?: StringFilter<"Notification"> | string
    notificationType?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    notificationData?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    userDetails?: XOR<UserDetailsScalarRelationFilter, UserDetailsWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userDetailsId?: SortOrder
    notificationType?: SortOrder
    notificationData?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userDetailsId?: StringWithAggregatesFilter<"Notification"> | string
    notificationType?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    notificationData?: StringWithAggregatesFilter<"Notification"> | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type InterestWhereInput = {
    AND?: InterestWhereInput | InterestWhereInput[]
    OR?: InterestWhereInput[]
    NOT?: InterestWhereInput | InterestWhereInput[]
    id?: StringFilter<"Interest"> | string
    interestName?: StringFilter<"Interest"> | string
    userDetails?: UserDetailsListRelationFilter
  }

  export type InterestOrderByWithRelationInput = {
    id?: SortOrder
    interestName?: SortOrder
    userDetails?: UserDetailsOrderByRelationAggregateInput
  }

  export type InterestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    interestName?: string
    AND?: InterestWhereInput | InterestWhereInput[]
    OR?: InterestWhereInput[]
    NOT?: InterestWhereInput | InterestWhereInput[]
    userDetails?: UserDetailsListRelationFilter
  }, "id" | "interestName">

  export type InterestOrderByWithAggregationInput = {
    id?: SortOrder
    interestName?: SortOrder
    _count?: InterestCountOrderByAggregateInput
    _max?: InterestMaxOrderByAggregateInput
    _min?: InterestMinOrderByAggregateInput
  }

  export type InterestScalarWhereWithAggregatesInput = {
    AND?: InterestScalarWhereWithAggregatesInput | InterestScalarWhereWithAggregatesInput[]
    OR?: InterestScalarWhereWithAggregatesInput[]
    NOT?: InterestScalarWhereWithAggregatesInput | InterestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Interest"> | string
    interestName?: StringWithAggregatesFilter<"Interest"> | string
  }

  export type MatchWhereInput = {
    AND?: MatchWhereInput | MatchWhereInput[]
    OR?: MatchWhereInput[]
    NOT?: MatchWhereInput | MatchWhereInput[]
    id?: StringFilter<"Match"> | string
    inviterId?: StringFilter<"Match"> | string
    inviteeId?: StringFilter<"Match"> | string
    matchScore?: IntFilter<"Match"> | number
    matchStatus?: EnumMatchStatusFilter<"Match"> | $Enums.MatchStatus
    createdAt?: DateTimeFilter<"Match"> | Date | string
    updatedAt?: DateTimeFilter<"Match"> | Date | string
    inviter?: XOR<UserDetailsScalarRelationFilter, UserDetailsWhereInput>
    invitee?: XOR<UserDetailsScalarRelationFilter, UserDetailsWhereInput>
  }

  export type MatchOrderByWithRelationInput = {
    id?: SortOrder
    inviterId?: SortOrder
    inviteeId?: SortOrder
    matchScore?: SortOrder
    matchStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inviter?: UserDetailsOrderByWithRelationInput
    invitee?: UserDetailsOrderByWithRelationInput
  }

  export type MatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    inviterId_inviteeId?: MatchInviterIdInviteeIdCompoundUniqueInput
    AND?: MatchWhereInput | MatchWhereInput[]
    OR?: MatchWhereInput[]
    NOT?: MatchWhereInput | MatchWhereInput[]
    inviterId?: StringFilter<"Match"> | string
    inviteeId?: StringFilter<"Match"> | string
    matchScore?: IntFilter<"Match"> | number
    matchStatus?: EnumMatchStatusFilter<"Match"> | $Enums.MatchStatus
    createdAt?: DateTimeFilter<"Match"> | Date | string
    updatedAt?: DateTimeFilter<"Match"> | Date | string
    inviter?: XOR<UserDetailsScalarRelationFilter, UserDetailsWhereInput>
    invitee?: XOR<UserDetailsScalarRelationFilter, UserDetailsWhereInput>
  }, "id" | "inviterId_inviteeId">

  export type MatchOrderByWithAggregationInput = {
    id?: SortOrder
    inviterId?: SortOrder
    inviteeId?: SortOrder
    matchScore?: SortOrder
    matchStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MatchCountOrderByAggregateInput
    _avg?: MatchAvgOrderByAggregateInput
    _max?: MatchMaxOrderByAggregateInput
    _min?: MatchMinOrderByAggregateInput
    _sum?: MatchSumOrderByAggregateInput
  }

  export type MatchScalarWhereWithAggregatesInput = {
    AND?: MatchScalarWhereWithAggregatesInput | MatchScalarWhereWithAggregatesInput[]
    OR?: MatchScalarWhereWithAggregatesInput[]
    NOT?: MatchScalarWhereWithAggregatesInput | MatchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Match"> | string
    inviterId?: StringWithAggregatesFilter<"Match"> | string
    inviteeId?: StringWithAggregatesFilter<"Match"> | string
    matchScore?: IntWithAggregatesFilter<"Match"> | number
    matchStatus?: EnumMatchStatusWithAggregatesFilter<"Match"> | $Enums.MatchStatus
    createdAt?: DateTimeWithAggregatesFilter<"Match"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Match"> | Date | string
  }

  export type UserSimilarityWhereInput = {
    AND?: UserSimilarityWhereInput | UserSimilarityWhereInput[]
    OR?: UserSimilarityWhereInput[]
    NOT?: UserSimilarityWhereInput | UserSimilarityWhereInput[]
    id?: StringFilter<"UserSimilarity"> | string
    currentUserId?: StringFilter<"UserSimilarity"> | string
    otherUserId?: StringFilter<"UserSimilarity"> | string
    similarityScore?: IntFilter<"UserSimilarity"> | number
    factors?: JsonNullableFilter<"UserSimilarity">
    createdAt?: DateTimeFilter<"UserSimilarity"> | Date | string
    currentUser?: XOR<UserDetailsScalarRelationFilter, UserDetailsWhereInput>
    otherUser?: XOR<UserDetailsScalarRelationFilter, UserDetailsWhereInput>
  }

  export type UserSimilarityOrderByWithRelationInput = {
    id?: SortOrder
    currentUserId?: SortOrder
    otherUserId?: SortOrder
    similarityScore?: SortOrder
    factors?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    currentUser?: UserDetailsOrderByWithRelationInput
    otherUser?: UserDetailsOrderByWithRelationInput
  }

  export type UserSimilarityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    currentUserId_otherUserId?: UserSimilarityCurrentUserIdOtherUserIdCompoundUniqueInput
    AND?: UserSimilarityWhereInput | UserSimilarityWhereInput[]
    OR?: UserSimilarityWhereInput[]
    NOT?: UserSimilarityWhereInput | UserSimilarityWhereInput[]
    currentUserId?: StringFilter<"UserSimilarity"> | string
    otherUserId?: StringFilter<"UserSimilarity"> | string
    similarityScore?: IntFilter<"UserSimilarity"> | number
    factors?: JsonNullableFilter<"UserSimilarity">
    createdAt?: DateTimeFilter<"UserSimilarity"> | Date | string
    currentUser?: XOR<UserDetailsScalarRelationFilter, UserDetailsWhereInput>
    otherUser?: XOR<UserDetailsScalarRelationFilter, UserDetailsWhereInput>
  }, "id" | "currentUserId_otherUserId">

  export type UserSimilarityOrderByWithAggregationInput = {
    id?: SortOrder
    currentUserId?: SortOrder
    otherUserId?: SortOrder
    similarityScore?: SortOrder
    factors?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserSimilarityCountOrderByAggregateInput
    _avg?: UserSimilarityAvgOrderByAggregateInput
    _max?: UserSimilarityMaxOrderByAggregateInput
    _min?: UserSimilarityMinOrderByAggregateInput
    _sum?: UserSimilaritySumOrderByAggregateInput
  }

  export type UserSimilarityScalarWhereWithAggregatesInput = {
    AND?: UserSimilarityScalarWhereWithAggregatesInput | UserSimilarityScalarWhereWithAggregatesInput[]
    OR?: UserSimilarityScalarWhereWithAggregatesInput[]
    NOT?: UserSimilarityScalarWhereWithAggregatesInput | UserSimilarityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSimilarity"> | string
    currentUserId?: StringWithAggregatesFilter<"UserSimilarity"> | string
    otherUserId?: StringWithAggregatesFilter<"UserSimilarity"> | string
    similarityScore?: IntWithAggregatesFilter<"UserSimilarity"> | number
    factors?: JsonNullableWithAggregatesFilter<"UserSimilarity">
    createdAt?: DateTimeWithAggregatesFilter<"UserSimilarity"> | Date | string
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringFilter<"Event"> | string
    location?: StringNullableFilter<"Event"> | string | null
    date?: DateTimeFilter<"Event"> | Date | string
    time?: DateTimeNullableFilter<"Event"> | Date | string | null
    category?: StringNullableFilter<"Event"> | string | null
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    organizers?: UserDetailsListRelationFilter
    attendees?: UserDetailsListRelationFilter
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrderInput | SortOrder
    date?: SortOrder
    time?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizers?: UserDetailsOrderByRelationAggregateInput
    attendees?: UserDetailsOrderByRelationAggregateInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    title_description_location_date_time?: EventTitleDescriptionLocationDateTimeCompoundUniqueInput
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    title?: StringFilter<"Event"> | string
    description?: StringFilter<"Event"> | string
    location?: StringNullableFilter<"Event"> | string | null
    date?: DateTimeFilter<"Event"> | Date | string
    time?: DateTimeNullableFilter<"Event"> | Date | string | null
    category?: StringNullableFilter<"Event"> | string | null
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    organizers?: UserDetailsListRelationFilter
    attendees?: UserDetailsListRelationFilter
  }, "id" | "title_description_location_date_time">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrderInput | SortOrder
    date?: SortOrder
    time?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Event"> | string
    title?: StringWithAggregatesFilter<"Event"> | string
    description?: StringWithAggregatesFilter<"Event"> | string
    location?: StringNullableWithAggregatesFilter<"Event"> | string | null
    date?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    time?: DateTimeNullableWithAggregatesFilter<"Event"> | Date | string | null
    category?: StringNullableWithAggregatesFilter<"Event"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
  }

  export type CoffeeChatWhereInput = {
    AND?: CoffeeChatWhereInput | CoffeeChatWhereInput[]
    OR?: CoffeeChatWhereInput[]
    NOT?: CoffeeChatWhereInput | CoffeeChatWhereInput[]
    id?: StringFilter<"CoffeeChat"> | string
    inviterId?: StringFilter<"CoffeeChat"> | string
    inviteeId?: StringFilter<"CoffeeChat"> | string
    purposeId?: StringFilter<"CoffeeChat"> | string
    venueId?: StringFilter<"CoffeeChat"> | string
    scheduledAt?: DateTimeNullableFilter<"CoffeeChat"> | Date | string | null
    duration?: IntFilter<"CoffeeChat"> | number
    personalMessage?: StringNullableFilter<"CoffeeChat"> | string | null
    status?: EnumCoffeeChatStatusFilter<"CoffeeChat"> | $Enums.CoffeeChatStatus
    createdAt?: DateTimeFilter<"CoffeeChat"> | Date | string
    updatedAt?: DateTimeFilter<"CoffeeChat"> | Date | string
    inviter?: XOR<UserDetailsScalarRelationFilter, UserDetailsWhereInput>
    invitee?: XOR<UserDetailsScalarRelationFilter, UserDetailsWhereInput>
    purpose?: XOR<CoffeeChatPurposeScalarRelationFilter, CoffeeChatPurposeWhereInput>
    venue?: XOR<CoffeeChatVenueScalarRelationFilter, CoffeeChatVenueWhereInput>
  }

  export type CoffeeChatOrderByWithRelationInput = {
    id?: SortOrder
    inviterId?: SortOrder
    inviteeId?: SortOrder
    purposeId?: SortOrder
    venueId?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    duration?: SortOrder
    personalMessage?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inviter?: UserDetailsOrderByWithRelationInput
    invitee?: UserDetailsOrderByWithRelationInput
    purpose?: CoffeeChatPurposeOrderByWithRelationInput
    venue?: CoffeeChatVenueOrderByWithRelationInput
  }

  export type CoffeeChatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CoffeeChatWhereInput | CoffeeChatWhereInput[]
    OR?: CoffeeChatWhereInput[]
    NOT?: CoffeeChatWhereInput | CoffeeChatWhereInput[]
    inviterId?: StringFilter<"CoffeeChat"> | string
    inviteeId?: StringFilter<"CoffeeChat"> | string
    purposeId?: StringFilter<"CoffeeChat"> | string
    venueId?: StringFilter<"CoffeeChat"> | string
    scheduledAt?: DateTimeNullableFilter<"CoffeeChat"> | Date | string | null
    duration?: IntFilter<"CoffeeChat"> | number
    personalMessage?: StringNullableFilter<"CoffeeChat"> | string | null
    status?: EnumCoffeeChatStatusFilter<"CoffeeChat"> | $Enums.CoffeeChatStatus
    createdAt?: DateTimeFilter<"CoffeeChat"> | Date | string
    updatedAt?: DateTimeFilter<"CoffeeChat"> | Date | string
    inviter?: XOR<UserDetailsScalarRelationFilter, UserDetailsWhereInput>
    invitee?: XOR<UserDetailsScalarRelationFilter, UserDetailsWhereInput>
    purpose?: XOR<CoffeeChatPurposeScalarRelationFilter, CoffeeChatPurposeWhereInput>
    venue?: XOR<CoffeeChatVenueScalarRelationFilter, CoffeeChatVenueWhereInput>
  }, "id">

  export type CoffeeChatOrderByWithAggregationInput = {
    id?: SortOrder
    inviterId?: SortOrder
    inviteeId?: SortOrder
    purposeId?: SortOrder
    venueId?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    duration?: SortOrder
    personalMessage?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CoffeeChatCountOrderByAggregateInput
    _avg?: CoffeeChatAvgOrderByAggregateInput
    _max?: CoffeeChatMaxOrderByAggregateInput
    _min?: CoffeeChatMinOrderByAggregateInput
    _sum?: CoffeeChatSumOrderByAggregateInput
  }

  export type CoffeeChatScalarWhereWithAggregatesInput = {
    AND?: CoffeeChatScalarWhereWithAggregatesInput | CoffeeChatScalarWhereWithAggregatesInput[]
    OR?: CoffeeChatScalarWhereWithAggregatesInput[]
    NOT?: CoffeeChatScalarWhereWithAggregatesInput | CoffeeChatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CoffeeChat"> | string
    inviterId?: StringWithAggregatesFilter<"CoffeeChat"> | string
    inviteeId?: StringWithAggregatesFilter<"CoffeeChat"> | string
    purposeId?: StringWithAggregatesFilter<"CoffeeChat"> | string
    venueId?: StringWithAggregatesFilter<"CoffeeChat"> | string
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"CoffeeChat"> | Date | string | null
    duration?: IntWithAggregatesFilter<"CoffeeChat"> | number
    personalMessage?: StringNullableWithAggregatesFilter<"CoffeeChat"> | string | null
    status?: EnumCoffeeChatStatusWithAggregatesFilter<"CoffeeChat"> | $Enums.CoffeeChatStatus
    createdAt?: DateTimeWithAggregatesFilter<"CoffeeChat"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CoffeeChat"> | Date | string
  }

  export type CoffeeChatPurposeWhereInput = {
    AND?: CoffeeChatPurposeWhereInput | CoffeeChatPurposeWhereInput[]
    OR?: CoffeeChatPurposeWhereInput[]
    NOT?: CoffeeChatPurposeWhereInput | CoffeeChatPurposeWhereInput[]
    id?: StringFilter<"CoffeeChatPurpose"> | string
    purposeName?: StringFilter<"CoffeeChatPurpose"> | string
    description?: StringFilter<"CoffeeChatPurpose"> | string
    timeLimit?: IntFilter<"CoffeeChatPurpose"> | number
    coffeeChats?: CoffeeChatListRelationFilter
  }

  export type CoffeeChatPurposeOrderByWithRelationInput = {
    id?: SortOrder
    purposeName?: SortOrder
    description?: SortOrder
    timeLimit?: SortOrder
    coffeeChats?: CoffeeChatOrderByRelationAggregateInput
  }

  export type CoffeeChatPurposeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    purposeName?: string
    AND?: CoffeeChatPurposeWhereInput | CoffeeChatPurposeWhereInput[]
    OR?: CoffeeChatPurposeWhereInput[]
    NOT?: CoffeeChatPurposeWhereInput | CoffeeChatPurposeWhereInput[]
    description?: StringFilter<"CoffeeChatPurpose"> | string
    timeLimit?: IntFilter<"CoffeeChatPurpose"> | number
    coffeeChats?: CoffeeChatListRelationFilter
  }, "id" | "purposeName">

  export type CoffeeChatPurposeOrderByWithAggregationInput = {
    id?: SortOrder
    purposeName?: SortOrder
    description?: SortOrder
    timeLimit?: SortOrder
    _count?: CoffeeChatPurposeCountOrderByAggregateInput
    _avg?: CoffeeChatPurposeAvgOrderByAggregateInput
    _max?: CoffeeChatPurposeMaxOrderByAggregateInput
    _min?: CoffeeChatPurposeMinOrderByAggregateInput
    _sum?: CoffeeChatPurposeSumOrderByAggregateInput
  }

  export type CoffeeChatPurposeScalarWhereWithAggregatesInput = {
    AND?: CoffeeChatPurposeScalarWhereWithAggregatesInput | CoffeeChatPurposeScalarWhereWithAggregatesInput[]
    OR?: CoffeeChatPurposeScalarWhereWithAggregatesInput[]
    NOT?: CoffeeChatPurposeScalarWhereWithAggregatesInput | CoffeeChatPurposeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CoffeeChatPurpose"> | string
    purposeName?: StringWithAggregatesFilter<"CoffeeChatPurpose"> | string
    description?: StringWithAggregatesFilter<"CoffeeChatPurpose"> | string
    timeLimit?: IntWithAggregatesFilter<"CoffeeChatPurpose"> | number
  }

  export type CoffeeChatVenueWhereInput = {
    AND?: CoffeeChatVenueWhereInput | CoffeeChatVenueWhereInput[]
    OR?: CoffeeChatVenueWhereInput[]
    NOT?: CoffeeChatVenueWhereInput | CoffeeChatVenueWhereInput[]
    id?: StringFilter<"CoffeeChatVenue"> | string
    venueName?: StringFilter<"CoffeeChatVenue"> | string
    noiseLevel?: EnumCoffeeChatVenueNoiseLevelFilter<"CoffeeChatVenue"> | $Enums.CoffeeChatVenueNoiseLevel
    description?: StringFilter<"CoffeeChatVenue"> | string
    location?: StringFilter<"CoffeeChatVenue"> | string
    rating?: IntFilter<"CoffeeChatVenue"> | number
    tags?: EnumCoffeeChatVenueTagsNullableListFilter<"CoffeeChatVenue">
    coffeeChats?: CoffeeChatListRelationFilter
  }

  export type CoffeeChatVenueOrderByWithRelationInput = {
    id?: SortOrder
    venueName?: SortOrder
    noiseLevel?: SortOrder
    description?: SortOrder
    location?: SortOrder
    rating?: SortOrder
    tags?: SortOrder
    coffeeChats?: CoffeeChatOrderByRelationAggregateInput
  }

  export type CoffeeChatVenueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    venueName?: string
    AND?: CoffeeChatVenueWhereInput | CoffeeChatVenueWhereInput[]
    OR?: CoffeeChatVenueWhereInput[]
    NOT?: CoffeeChatVenueWhereInput | CoffeeChatVenueWhereInput[]
    noiseLevel?: EnumCoffeeChatVenueNoiseLevelFilter<"CoffeeChatVenue"> | $Enums.CoffeeChatVenueNoiseLevel
    description?: StringFilter<"CoffeeChatVenue"> | string
    location?: StringFilter<"CoffeeChatVenue"> | string
    rating?: IntFilter<"CoffeeChatVenue"> | number
    tags?: EnumCoffeeChatVenueTagsNullableListFilter<"CoffeeChatVenue">
    coffeeChats?: CoffeeChatListRelationFilter
  }, "id" | "venueName">

  export type CoffeeChatVenueOrderByWithAggregationInput = {
    id?: SortOrder
    venueName?: SortOrder
    noiseLevel?: SortOrder
    description?: SortOrder
    location?: SortOrder
    rating?: SortOrder
    tags?: SortOrder
    _count?: CoffeeChatVenueCountOrderByAggregateInput
    _avg?: CoffeeChatVenueAvgOrderByAggregateInput
    _max?: CoffeeChatVenueMaxOrderByAggregateInput
    _min?: CoffeeChatVenueMinOrderByAggregateInput
    _sum?: CoffeeChatVenueSumOrderByAggregateInput
  }

  export type CoffeeChatVenueScalarWhereWithAggregatesInput = {
    AND?: CoffeeChatVenueScalarWhereWithAggregatesInput | CoffeeChatVenueScalarWhereWithAggregatesInput[]
    OR?: CoffeeChatVenueScalarWhereWithAggregatesInput[]
    NOT?: CoffeeChatVenueScalarWhereWithAggregatesInput | CoffeeChatVenueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CoffeeChatVenue"> | string
    venueName?: StringWithAggregatesFilter<"CoffeeChatVenue"> | string
    noiseLevel?: EnumCoffeeChatVenueNoiseLevelWithAggregatesFilter<"CoffeeChatVenue"> | $Enums.CoffeeChatVenueNoiseLevel
    description?: StringWithAggregatesFilter<"CoffeeChatVenue"> | string
    location?: StringWithAggregatesFilter<"CoffeeChatVenue"> | string
    rating?: IntWithAggregatesFilter<"CoffeeChatVenue"> | number
    tags?: EnumCoffeeChatVenueTagsNullableListFilter<"CoffeeChatVenue">
  }

  export type ChatWhereInput = {
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    id?: StringFilter<"Chat"> | string
    user1Id?: StringFilter<"Chat"> | string
    user2Id?: StringFilter<"Chat"> | string
    name?: StringNullableFilter<"Chat"> | string | null
    user1?: XOR<UserDetailsScalarRelationFilter, UserDetailsWhereInput>
    user2?: XOR<UserDetailsScalarRelationFilter, UserDetailsWhereInput>
    messages?: MessageListRelationFilter
  }

  export type ChatOrderByWithRelationInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    name?: SortOrderInput | SortOrder
    user1?: UserDetailsOrderByWithRelationInput
    user2?: UserDetailsOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type ChatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user1Id_user2Id?: ChatUser1IdUser2IdCompoundUniqueInput
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    user1Id?: StringFilter<"Chat"> | string
    user2Id?: StringFilter<"Chat"> | string
    name?: StringNullableFilter<"Chat"> | string | null
    user1?: XOR<UserDetailsScalarRelationFilter, UserDetailsWhereInput>
    user2?: XOR<UserDetailsScalarRelationFilter, UserDetailsWhereInput>
    messages?: MessageListRelationFilter
  }, "id" | "user1Id_user2Id">

  export type ChatOrderByWithAggregationInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    name?: SortOrderInput | SortOrder
    _count?: ChatCountOrderByAggregateInput
    _max?: ChatMaxOrderByAggregateInput
    _min?: ChatMinOrderByAggregateInput
  }

  export type ChatScalarWhereWithAggregatesInput = {
    AND?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    OR?: ChatScalarWhereWithAggregatesInput[]
    NOT?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chat"> | string
    user1Id?: StringWithAggregatesFilter<"Chat"> | string
    user2Id?: StringWithAggregatesFilter<"Chat"> | string
    name?: StringNullableWithAggregatesFilter<"Chat"> | string | null
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    chatId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    chat?: XOR<ChatScalarRelationFilter, ChatWhereInput>
    sender?: XOR<UserDetailsScalarRelationFilter, UserDetailsWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    chat?: ChatOrderByWithRelationInput
    sender?: UserDetailsOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    chatId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    chat?: XOR<ChatScalarRelationFilter, ChatWhereInput>
    sender?: XOR<UserDetailsScalarRelationFilter, UserDetailsWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    chatId?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    username?: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userDetails?: UserDetailsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    username?: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userDetails?: UserDetailsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userDetails?: UserDetailsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userDetails?: UserDetailsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    username?: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDetailsCreateInput = {
    id?: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    user: UserCreateNestedOneWithoutUserDetailsInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserDetailsInput
    interests?: InterestCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatCreateNestedManyWithoutUser2Input
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserDetailsInput
    interests?: InterestUncheckedCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchUncheckedCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchUncheckedCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventUncheckedCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventUncheckedCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatUncheckedCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatUncheckedCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserDetailsNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
  }

  export type UserDetailsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUncheckedUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUncheckedUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUncheckedUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUncheckedUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUncheckedUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUncheckedUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUncheckedUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserDetailsCreateManyInput = {
    id?: string
    userId: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
  }

  export type UserDetailsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserDetailsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostCreateInput = {
    id?: string
    content: string
    commentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserDetailsCreateNestedOneWithoutPostsInput
    reaction?: ReactionCreateNestedOneWithoutPostInput
    postTags?: PostTagCreateNestedManyWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateInput = {
    id?: string
    authorId: string
    content: string
    commentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reaction?: ReactionUncheckedCreateNestedOneWithoutPostInput
    postTags?: PostTagUncheckedCreateNestedManyWithoutPostsInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    commentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserDetailsUpdateOneRequiredWithoutPostsNestedInput
    reaction?: ReactionUpdateOneWithoutPostNestedInput
    postTags?: PostTagUpdateManyWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    commentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reaction?: ReactionUncheckedUpdateOneWithoutPostNestedInput
    postTags?: PostTagUncheckedUpdateManyWithoutPostsNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateManyInput = {
    id?: string
    authorId: string
    content: string
    commentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    commentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    commentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionCreateInput = {
    id?: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    post: PostCreateNestedOneWithoutReactionInput
  }

  export type ReactionUncheckedCreateInput = {
    id?: string
    postId: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutReactionNestedInput
  }

  export type ReactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionCreateManyInput = {
    id?: string
    postId: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    commentContent: string
    createdAt?: Date | string
    updatedAt?: Date | string
    post: PostCreateNestedOneWithoutCommentsInput
    author: UserDetailsCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    postId: string
    authorId: string
    commentContent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserDetailsUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    commentContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyInput = {
    id?: string
    postId: string
    authorId: string
    commentContent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    commentContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostTagCreateInput = {
    id?: string
    tagName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostCreateNestedManyWithoutPostTagsInput
  }

  export type PostTagUncheckedCreateInput = {
    id?: string
    tagName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostUncheckedCreateNestedManyWithoutPostTagsInput
  }

  export type PostTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUpdateManyWithoutPostTagsNestedInput
  }

  export type PostTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUncheckedUpdateManyWithoutPostTagsNestedInput
  }

  export type PostTagCreateManyInput = {
    id?: string
    tagName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    notificationType: $Enums.NotificationType
    notificationData: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userDetails: UserDetailsCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userDetailsId: string
    notificationType: $Enums.NotificationType
    notificationData: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    notificationData?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userDetails?: UserDetailsUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userDetailsId?: StringFieldUpdateOperationsInput | string
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    notificationData?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userDetailsId: string
    notificationType: $Enums.NotificationType
    notificationData: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    notificationData?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userDetailsId?: StringFieldUpdateOperationsInput | string
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    notificationData?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterestCreateInput = {
    id?: string
    interestName: string
    userDetails?: UserDetailsCreateNestedManyWithoutInterestsInput
  }

  export type InterestUncheckedCreateInput = {
    id?: string
    interestName: string
    userDetails?: UserDetailsUncheckedCreateNestedManyWithoutInterestsInput
  }

  export type InterestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    interestName?: StringFieldUpdateOperationsInput | string
    userDetails?: UserDetailsUpdateManyWithoutInterestsNestedInput
  }

  export type InterestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    interestName?: StringFieldUpdateOperationsInput | string
    userDetails?: UserDetailsUncheckedUpdateManyWithoutInterestsNestedInput
  }

  export type InterestCreateManyInput = {
    id?: string
    interestName: string
  }

  export type InterestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    interestName?: StringFieldUpdateOperationsInput | string
  }

  export type InterestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    interestName?: StringFieldUpdateOperationsInput | string
  }

  export type MatchCreateInput = {
    id?: string
    matchScore: number
    matchStatus?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    inviter: UserDetailsCreateNestedOneWithoutMatchesSentInput
    invitee: UserDetailsCreateNestedOneWithoutMatchesReceivedInput
  }

  export type MatchUncheckedCreateInput = {
    id?: string
    inviterId: string
    inviteeId: string
    matchScore: number
    matchStatus?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchScore?: IntFieldUpdateOperationsInput | number
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviter?: UserDetailsUpdateOneRequiredWithoutMatchesSentNestedInput
    invitee?: UserDetailsUpdateOneRequiredWithoutMatchesReceivedNestedInput
  }

  export type MatchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    inviteeId?: StringFieldUpdateOperationsInput | string
    matchScore?: IntFieldUpdateOperationsInput | number
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchCreateManyInput = {
    id?: string
    inviterId: string
    inviteeId: string
    matchScore: number
    matchStatus?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchScore?: IntFieldUpdateOperationsInput | number
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    inviteeId?: StringFieldUpdateOperationsInput | string
    matchScore?: IntFieldUpdateOperationsInput | number
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSimilarityCreateInput = {
    id?: string
    similarityScore: number
    factors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    currentUser: UserDetailsCreateNestedOneWithoutCurrentUserSimilarityInput
    otherUser: UserDetailsCreateNestedOneWithoutOtherUserSimilarityInput
  }

  export type UserSimilarityUncheckedCreateInput = {
    id?: string
    currentUserId: string
    otherUserId: string
    similarityScore: number
    factors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UserSimilarityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    similarityScore?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentUser?: UserDetailsUpdateOneRequiredWithoutCurrentUserSimilarityNestedInput
    otherUser?: UserDetailsUpdateOneRequiredWithoutOtherUserSimilarityNestedInput
  }

  export type UserSimilarityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentUserId?: StringFieldUpdateOperationsInput | string
    otherUserId?: StringFieldUpdateOperationsInput | string
    similarityScore?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSimilarityCreateManyInput = {
    id?: string
    currentUserId: string
    otherUserId: string
    similarityScore: number
    factors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UserSimilarityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    similarityScore?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSimilarityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentUserId?: StringFieldUpdateOperationsInput | string
    otherUserId?: StringFieldUpdateOperationsInput | string
    similarityScore?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateInput = {
    id?: string
    title: string
    description: string
    location?: string | null
    date: Date | string
    time?: Date | string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizers?: UserDetailsCreateNestedManyWithoutAsEventOrganizerInput
    attendees?: UserDetailsCreateNestedManyWithoutAsEventAttendeeInput
  }

  export type EventUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    location?: string | null
    date: Date | string
    time?: Date | string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizers?: UserDetailsUncheckedCreateNestedManyWithoutAsEventOrganizerInput
    attendees?: UserDetailsUncheckedCreateNestedManyWithoutAsEventAttendeeInput
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizers?: UserDetailsUpdateManyWithoutAsEventOrganizerNestedInput
    attendees?: UserDetailsUpdateManyWithoutAsEventAttendeeNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizers?: UserDetailsUncheckedUpdateManyWithoutAsEventOrganizerNestedInput
    attendees?: UserDetailsUncheckedUpdateManyWithoutAsEventAttendeeNestedInput
  }

  export type EventCreateManyInput = {
    id?: string
    title: string
    description: string
    location?: string | null
    date: Date | string
    time?: Date | string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoffeeChatCreateInput = {
    id?: string
    scheduledAt?: Date | string | null
    duration: number
    personalMessage?: string | null
    status?: $Enums.CoffeeChatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    inviter: UserDetailsCreateNestedOneWithoutCoffeeChatsSentInput
    invitee: UserDetailsCreateNestedOneWithoutCoffeeChatsReceivedInput
    purpose: CoffeeChatPurposeCreateNestedOneWithoutCoffeeChatsInput
    venue: CoffeeChatVenueCreateNestedOneWithoutCoffeeChatsInput
  }

  export type CoffeeChatUncheckedCreateInput = {
    id?: string
    inviterId: string
    inviteeId: string
    purposeId: string
    venueId: string
    scheduledAt?: Date | string | null
    duration: number
    personalMessage?: string | null
    status?: $Enums.CoffeeChatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoffeeChatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    personalMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCoffeeChatStatusFieldUpdateOperationsInput | $Enums.CoffeeChatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviter?: UserDetailsUpdateOneRequiredWithoutCoffeeChatsSentNestedInput
    invitee?: UserDetailsUpdateOneRequiredWithoutCoffeeChatsReceivedNestedInput
    purpose?: CoffeeChatPurposeUpdateOneRequiredWithoutCoffeeChatsNestedInput
    venue?: CoffeeChatVenueUpdateOneRequiredWithoutCoffeeChatsNestedInput
  }

  export type CoffeeChatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    inviteeId?: StringFieldUpdateOperationsInput | string
    purposeId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    personalMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCoffeeChatStatusFieldUpdateOperationsInput | $Enums.CoffeeChatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoffeeChatCreateManyInput = {
    id?: string
    inviterId: string
    inviteeId: string
    purposeId: string
    venueId: string
    scheduledAt?: Date | string | null
    duration: number
    personalMessage?: string | null
    status?: $Enums.CoffeeChatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoffeeChatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    personalMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCoffeeChatStatusFieldUpdateOperationsInput | $Enums.CoffeeChatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoffeeChatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    inviteeId?: StringFieldUpdateOperationsInput | string
    purposeId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    personalMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCoffeeChatStatusFieldUpdateOperationsInput | $Enums.CoffeeChatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoffeeChatPurposeCreateInput = {
    id?: string
    purposeName: string
    description: string
    timeLimit: number
    coffeeChats?: CoffeeChatCreateNestedManyWithoutPurposeInput
  }

  export type CoffeeChatPurposeUncheckedCreateInput = {
    id?: string
    purposeName: string
    description: string
    timeLimit: number
    coffeeChats?: CoffeeChatUncheckedCreateNestedManyWithoutPurposeInput
  }

  export type CoffeeChatPurposeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purposeName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    timeLimit?: IntFieldUpdateOperationsInput | number
    coffeeChats?: CoffeeChatUpdateManyWithoutPurposeNestedInput
  }

  export type CoffeeChatPurposeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purposeName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    timeLimit?: IntFieldUpdateOperationsInput | number
    coffeeChats?: CoffeeChatUncheckedUpdateManyWithoutPurposeNestedInput
  }

  export type CoffeeChatPurposeCreateManyInput = {
    id?: string
    purposeName: string
    description: string
    timeLimit: number
  }

  export type CoffeeChatPurposeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    purposeName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    timeLimit?: IntFieldUpdateOperationsInput | number
  }

  export type CoffeeChatPurposeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    purposeName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    timeLimit?: IntFieldUpdateOperationsInput | number
  }

  export type CoffeeChatVenueCreateInput = {
    id?: string
    venueName: string
    noiseLevel: $Enums.CoffeeChatVenueNoiseLevel
    description: string
    location: string
    rating: number
    tags?: CoffeeChatVenueCreatetagsInput | $Enums.CoffeeChatVenueTags[]
    coffeeChats?: CoffeeChatCreateNestedManyWithoutVenueInput
  }

  export type CoffeeChatVenueUncheckedCreateInput = {
    id?: string
    venueName: string
    noiseLevel: $Enums.CoffeeChatVenueNoiseLevel
    description: string
    location: string
    rating: number
    tags?: CoffeeChatVenueCreatetagsInput | $Enums.CoffeeChatVenueTags[]
    coffeeChats?: CoffeeChatUncheckedCreateNestedManyWithoutVenueInput
  }

  export type CoffeeChatVenueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueName?: StringFieldUpdateOperationsInput | string
    noiseLevel?: EnumCoffeeChatVenueNoiseLevelFieldUpdateOperationsInput | $Enums.CoffeeChatVenueNoiseLevel
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    tags?: CoffeeChatVenueUpdatetagsInput | $Enums.CoffeeChatVenueTags[]
    coffeeChats?: CoffeeChatUpdateManyWithoutVenueNestedInput
  }

  export type CoffeeChatVenueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueName?: StringFieldUpdateOperationsInput | string
    noiseLevel?: EnumCoffeeChatVenueNoiseLevelFieldUpdateOperationsInput | $Enums.CoffeeChatVenueNoiseLevel
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    tags?: CoffeeChatVenueUpdatetagsInput | $Enums.CoffeeChatVenueTags[]
    coffeeChats?: CoffeeChatUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type CoffeeChatVenueCreateManyInput = {
    id?: string
    venueName: string
    noiseLevel: $Enums.CoffeeChatVenueNoiseLevel
    description: string
    location: string
    rating: number
    tags?: CoffeeChatVenueCreatetagsInput | $Enums.CoffeeChatVenueTags[]
  }

  export type CoffeeChatVenueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueName?: StringFieldUpdateOperationsInput | string
    noiseLevel?: EnumCoffeeChatVenueNoiseLevelFieldUpdateOperationsInput | $Enums.CoffeeChatVenueNoiseLevel
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    tags?: CoffeeChatVenueUpdatetagsInput | $Enums.CoffeeChatVenueTags[]
  }

  export type CoffeeChatVenueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueName?: StringFieldUpdateOperationsInput | string
    noiseLevel?: EnumCoffeeChatVenueNoiseLevelFieldUpdateOperationsInput | $Enums.CoffeeChatVenueNoiseLevel
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    tags?: CoffeeChatVenueUpdatetagsInput | $Enums.CoffeeChatVenueTags[]
  }

  export type ChatCreateInput = {
    id?: string
    name?: string | null
    user1: UserDetailsCreateNestedOneWithoutChatsAsUser1Input
    user2: UserDetailsCreateNestedOneWithoutChatsAsUser2Input
    messages?: MessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateInput = {
    id?: string
    user1Id: string
    user2Id: string
    name?: string | null
    messages?: MessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    user1?: UserDetailsUpdateOneRequiredWithoutChatsAsUser1NestedInput
    user2?: UserDetailsUpdateOneRequiredWithoutChatsAsUser2NestedInput
    messages?: MessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: MessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatCreateManyInput = {
    id?: string
    user1Id: string
    user2Id: string
    name?: string | null
  }

  export type ChatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    chat: ChatCreateNestedOneWithoutMessagesInput
    sender: UserDetailsCreateNestedOneWithoutMessagesSentInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    chatId: string
    senderId: string
    content: string
    createdAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserDetailsUpdateOneRequiredWithoutMessagesSentNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    chatId: string
    senderId: string
    content: string
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserDetailsNullableScalarRelationFilter = {
    is?: UserDetailsWhereInput | null
    isNot?: UserDetailsWhereInput | null
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type InterestListRelationFilter = {
    every?: InterestWhereInput
    some?: InterestWhereInput
    none?: InterestWhereInput
  }

  export type MatchListRelationFilter = {
    every?: MatchWhereInput
    some?: MatchWhereInput
    none?: MatchWhereInput
  }

  export type UserSimilarityListRelationFilter = {
    every?: UserSimilarityWhereInput
    some?: UserSimilarityWhereInput
    none?: UserSimilarityWhereInput
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type CoffeeChatListRelationFilter = {
    every?: CoffeeChatWhereInput
    some?: CoffeeChatWhereInput
    none?: CoffeeChatWhereInput
  }

  export type ChatListRelationFilter = {
    every?: ChatWhereInput
    some?: ChatWhereInput
    none?: ChatWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InterestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSimilarityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CoffeeChatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    department?: SortOrder
    year?: SortOrder
    profilePicture?: SortOrder
    bio?: SortOrder
    availability?: SortOrder
    reading?: SortOrder
  }

  export type UserDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    department?: SortOrder
    year?: SortOrder
    profilePicture?: SortOrder
    bio?: SortOrder
    availability?: SortOrder
    reading?: SortOrder
  }

  export type UserDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    department?: SortOrder
    year?: SortOrder
    profilePicture?: SortOrder
    bio?: SortOrder
    availability?: SortOrder
    reading?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserDetailsScalarRelationFilter = {
    is?: UserDetailsWhereInput
    isNot?: UserDetailsWhereInput
  }

  export type ReactionNullableScalarRelationFilter = {
    is?: ReactionWhereInput | null
    isNot?: ReactionWhereInput | null
  }

  export type PostTagListRelationFilter = {
    every?: PostTagWhereInput
    some?: PostTagWhereInput
    none?: PostTagWhereInput
  }

  export type PostTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    commentCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    commentCount?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    commentCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    commentCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    commentCount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type PostScalarRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type ReactionCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReactionAvgOrderByAggregateInput = {
    likes?: SortOrder
  }

  export type ReactionMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReactionMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReactionSumOrderByAggregateInput = {
    likes?: SortOrder
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    commentContent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    commentContent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    commentContent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostTagCountOrderByAggregateInput = {
    id?: SortOrder
    tagName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostTagMaxOrderByAggregateInput = {
    id?: SortOrder
    tagName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostTagMinOrderByAggregateInput = {
    id?: SortOrder
    tagName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userDetailsId?: SortOrder
    notificationType?: SortOrder
    notificationData?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userDetailsId?: SortOrder
    notificationType?: SortOrder
    notificationData?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userDetailsId?: SortOrder
    notificationType?: SortOrder
    notificationData?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UserDetailsListRelationFilter = {
    every?: UserDetailsWhereInput
    some?: UserDetailsWhereInput
    none?: UserDetailsWhereInput
  }

  export type UserDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InterestCountOrderByAggregateInput = {
    id?: SortOrder
    interestName?: SortOrder
  }

  export type InterestMaxOrderByAggregateInput = {
    id?: SortOrder
    interestName?: SortOrder
  }

  export type InterestMinOrderByAggregateInput = {
    id?: SortOrder
    interestName?: SortOrder
  }

  export type EnumMatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusFilter<$PrismaModel> | $Enums.MatchStatus
  }

  export type MatchInviterIdInviteeIdCompoundUniqueInput = {
    inviterId: string
    inviteeId: string
  }

  export type MatchCountOrderByAggregateInput = {
    id?: SortOrder
    inviterId?: SortOrder
    inviteeId?: SortOrder
    matchScore?: SortOrder
    matchStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchAvgOrderByAggregateInput = {
    matchScore?: SortOrder
  }

  export type MatchMaxOrderByAggregateInput = {
    id?: SortOrder
    inviterId?: SortOrder
    inviteeId?: SortOrder
    matchScore?: SortOrder
    matchStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchMinOrderByAggregateInput = {
    id?: SortOrder
    inviterId?: SortOrder
    inviteeId?: SortOrder
    matchScore?: SortOrder
    matchStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchSumOrderByAggregateInput = {
    matchScore?: SortOrder
  }

  export type EnumMatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.MatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchStatusFilter<$PrismaModel>
    _max?: NestedEnumMatchStatusFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserSimilarityCurrentUserIdOtherUserIdCompoundUniqueInput = {
    currentUserId: string
    otherUserId: string
  }

  export type UserSimilarityCountOrderByAggregateInput = {
    id?: SortOrder
    currentUserId?: SortOrder
    otherUserId?: SortOrder
    similarityScore?: SortOrder
    factors?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSimilarityAvgOrderByAggregateInput = {
    similarityScore?: SortOrder
  }

  export type UserSimilarityMaxOrderByAggregateInput = {
    id?: SortOrder
    currentUserId?: SortOrder
    otherUserId?: SortOrder
    similarityScore?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSimilarityMinOrderByAggregateInput = {
    id?: SortOrder
    currentUserId?: SortOrder
    otherUserId?: SortOrder
    similarityScore?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSimilaritySumOrderByAggregateInput = {
    similarityScore?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EventTitleDescriptionLocationDateTimeCompoundUniqueInput = {
    title: string
    description: string
    location: string
    date: Date | string
    time: Date | string
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    date?: SortOrder
    time?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    date?: SortOrder
    time?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    date?: SortOrder
    time?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumCoffeeChatStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CoffeeChatStatus | EnumCoffeeChatStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CoffeeChatStatus[] | ListEnumCoffeeChatStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CoffeeChatStatus[] | ListEnumCoffeeChatStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCoffeeChatStatusFilter<$PrismaModel> | $Enums.CoffeeChatStatus
  }

  export type CoffeeChatPurposeScalarRelationFilter = {
    is?: CoffeeChatPurposeWhereInput
    isNot?: CoffeeChatPurposeWhereInput
  }

  export type CoffeeChatVenueScalarRelationFilter = {
    is?: CoffeeChatVenueWhereInput
    isNot?: CoffeeChatVenueWhereInput
  }

  export type CoffeeChatCountOrderByAggregateInput = {
    id?: SortOrder
    inviterId?: SortOrder
    inviteeId?: SortOrder
    purposeId?: SortOrder
    venueId?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    personalMessage?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoffeeChatAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type CoffeeChatMaxOrderByAggregateInput = {
    id?: SortOrder
    inviterId?: SortOrder
    inviteeId?: SortOrder
    purposeId?: SortOrder
    venueId?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    personalMessage?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoffeeChatMinOrderByAggregateInput = {
    id?: SortOrder
    inviterId?: SortOrder
    inviteeId?: SortOrder
    purposeId?: SortOrder
    venueId?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    personalMessage?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoffeeChatSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type EnumCoffeeChatStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CoffeeChatStatus | EnumCoffeeChatStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CoffeeChatStatus[] | ListEnumCoffeeChatStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CoffeeChatStatus[] | ListEnumCoffeeChatStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCoffeeChatStatusWithAggregatesFilter<$PrismaModel> | $Enums.CoffeeChatStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCoffeeChatStatusFilter<$PrismaModel>
    _max?: NestedEnumCoffeeChatStatusFilter<$PrismaModel>
  }

  export type CoffeeChatPurposeCountOrderByAggregateInput = {
    id?: SortOrder
    purposeName?: SortOrder
    description?: SortOrder
    timeLimit?: SortOrder
  }

  export type CoffeeChatPurposeAvgOrderByAggregateInput = {
    timeLimit?: SortOrder
  }

  export type CoffeeChatPurposeMaxOrderByAggregateInput = {
    id?: SortOrder
    purposeName?: SortOrder
    description?: SortOrder
    timeLimit?: SortOrder
  }

  export type CoffeeChatPurposeMinOrderByAggregateInput = {
    id?: SortOrder
    purposeName?: SortOrder
    description?: SortOrder
    timeLimit?: SortOrder
  }

  export type CoffeeChatPurposeSumOrderByAggregateInput = {
    timeLimit?: SortOrder
  }

  export type EnumCoffeeChatVenueNoiseLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.CoffeeChatVenueNoiseLevel | EnumCoffeeChatVenueNoiseLevelFieldRefInput<$PrismaModel>
    in?: $Enums.CoffeeChatVenueNoiseLevel[] | ListEnumCoffeeChatVenueNoiseLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CoffeeChatVenueNoiseLevel[] | ListEnumCoffeeChatVenueNoiseLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumCoffeeChatVenueNoiseLevelFilter<$PrismaModel> | $Enums.CoffeeChatVenueNoiseLevel
  }

  export type EnumCoffeeChatVenueTagsNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.CoffeeChatVenueTags[] | ListEnumCoffeeChatVenueTagsFieldRefInput<$PrismaModel> | null
    has?: $Enums.CoffeeChatVenueTags | EnumCoffeeChatVenueTagsFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.CoffeeChatVenueTags[] | ListEnumCoffeeChatVenueTagsFieldRefInput<$PrismaModel>
    hasSome?: $Enums.CoffeeChatVenueTags[] | ListEnumCoffeeChatVenueTagsFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type CoffeeChatVenueCountOrderByAggregateInput = {
    id?: SortOrder
    venueName?: SortOrder
    noiseLevel?: SortOrder
    description?: SortOrder
    location?: SortOrder
    rating?: SortOrder
    tags?: SortOrder
  }

  export type CoffeeChatVenueAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type CoffeeChatVenueMaxOrderByAggregateInput = {
    id?: SortOrder
    venueName?: SortOrder
    noiseLevel?: SortOrder
    description?: SortOrder
    location?: SortOrder
    rating?: SortOrder
  }

  export type CoffeeChatVenueMinOrderByAggregateInput = {
    id?: SortOrder
    venueName?: SortOrder
    noiseLevel?: SortOrder
    description?: SortOrder
    location?: SortOrder
    rating?: SortOrder
  }

  export type CoffeeChatVenueSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type EnumCoffeeChatVenueNoiseLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CoffeeChatVenueNoiseLevel | EnumCoffeeChatVenueNoiseLevelFieldRefInput<$PrismaModel>
    in?: $Enums.CoffeeChatVenueNoiseLevel[] | ListEnumCoffeeChatVenueNoiseLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CoffeeChatVenueNoiseLevel[] | ListEnumCoffeeChatVenueNoiseLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumCoffeeChatVenueNoiseLevelWithAggregatesFilter<$PrismaModel> | $Enums.CoffeeChatVenueNoiseLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCoffeeChatVenueNoiseLevelFilter<$PrismaModel>
    _max?: NestedEnumCoffeeChatVenueNoiseLevelFilter<$PrismaModel>
  }

  export type ChatUser1IdUser2IdCompoundUniqueInput = {
    user1Id: string
    user2Id: string
  }

  export type ChatCountOrderByAggregateInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    name?: SortOrder
  }

  export type ChatMaxOrderByAggregateInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    name?: SortOrder
  }

  export type ChatMinOrderByAggregateInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    name?: SortOrder
  }

  export type ChatScalarRelationFilter = {
    is?: ChatWhereInput
    isNot?: ChatWhereInput
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type UserDetailsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserDetailsCreateWithoutUserInput, UserDetailsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserDetailsCreateOrConnectWithoutUserInput
    connect?: UserDetailsWhereUniqueInput
  }

  export type UserDetailsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserDetailsCreateWithoutUserInput, UserDetailsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserDetailsCreateOrConnectWithoutUserInput
    connect?: UserDetailsWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserDetailsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserDetailsCreateWithoutUserInput, UserDetailsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserDetailsCreateOrConnectWithoutUserInput
    upsert?: UserDetailsUpsertWithoutUserInput
    disconnect?: UserDetailsWhereInput | boolean
    delete?: UserDetailsWhereInput | boolean
    connect?: UserDetailsWhereUniqueInput
    update?: XOR<XOR<UserDetailsUpdateToOneWithWhereWithoutUserInput, UserDetailsUpdateWithoutUserInput>, UserDetailsUncheckedUpdateWithoutUserInput>
  }

  export type UserDetailsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserDetailsCreateWithoutUserInput, UserDetailsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserDetailsCreateOrConnectWithoutUserInput
    upsert?: UserDetailsUpsertWithoutUserInput
    disconnect?: UserDetailsWhereInput | boolean
    delete?: UserDetailsWhereInput | boolean
    connect?: UserDetailsWhereUniqueInput
    update?: XOR<XOR<UserDetailsUpdateToOneWithWhereWithoutUserInput, UserDetailsUpdateWithoutUserInput>, UserDetailsUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutUserDetailsInput = {
    create?: XOR<UserCreateWithoutUserDetailsInput, UserUncheckedCreateWithoutUserDetailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserDetailsInput
    connect?: UserWhereUniqueInput
  }

  export type PostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserDetailsInput = {
    create?: XOR<NotificationCreateWithoutUserDetailsInput, NotificationUncheckedCreateWithoutUserDetailsInput> | NotificationCreateWithoutUserDetailsInput[] | NotificationUncheckedCreateWithoutUserDetailsInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserDetailsInput | NotificationCreateOrConnectWithoutUserDetailsInput[]
    createMany?: NotificationCreateManyUserDetailsInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type InterestCreateNestedManyWithoutUserDetailsInput = {
    create?: XOR<InterestCreateWithoutUserDetailsInput, InterestUncheckedCreateWithoutUserDetailsInput> | InterestCreateWithoutUserDetailsInput[] | InterestUncheckedCreateWithoutUserDetailsInput[]
    connectOrCreate?: InterestCreateOrConnectWithoutUserDetailsInput | InterestCreateOrConnectWithoutUserDetailsInput[]
    connect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
  }

  export type MatchCreateNestedManyWithoutInviterInput = {
    create?: XOR<MatchCreateWithoutInviterInput, MatchUncheckedCreateWithoutInviterInput> | MatchCreateWithoutInviterInput[] | MatchUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutInviterInput | MatchCreateOrConnectWithoutInviterInput[]
    createMany?: MatchCreateManyInviterInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type MatchCreateNestedManyWithoutInviteeInput = {
    create?: XOR<MatchCreateWithoutInviteeInput, MatchUncheckedCreateWithoutInviteeInput> | MatchCreateWithoutInviteeInput[] | MatchUncheckedCreateWithoutInviteeInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutInviteeInput | MatchCreateOrConnectWithoutInviteeInput[]
    createMany?: MatchCreateManyInviteeInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type UserSimilarityCreateNestedManyWithoutCurrentUserInput = {
    create?: XOR<UserSimilarityCreateWithoutCurrentUserInput, UserSimilarityUncheckedCreateWithoutCurrentUserInput> | UserSimilarityCreateWithoutCurrentUserInput[] | UserSimilarityUncheckedCreateWithoutCurrentUserInput[]
    connectOrCreate?: UserSimilarityCreateOrConnectWithoutCurrentUserInput | UserSimilarityCreateOrConnectWithoutCurrentUserInput[]
    createMany?: UserSimilarityCreateManyCurrentUserInputEnvelope
    connect?: UserSimilarityWhereUniqueInput | UserSimilarityWhereUniqueInput[]
  }

  export type UserSimilarityCreateNestedManyWithoutOtherUserInput = {
    create?: XOR<UserSimilarityCreateWithoutOtherUserInput, UserSimilarityUncheckedCreateWithoutOtherUserInput> | UserSimilarityCreateWithoutOtherUserInput[] | UserSimilarityUncheckedCreateWithoutOtherUserInput[]
    connectOrCreate?: UserSimilarityCreateOrConnectWithoutOtherUserInput | UserSimilarityCreateOrConnectWithoutOtherUserInput[]
    createMany?: UserSimilarityCreateManyOtherUserInputEnvelope
    connect?: UserSimilarityWhereUniqueInput | UserSimilarityWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutAttendeesInput = {
    create?: XOR<EventCreateWithoutAttendeesInput, EventUncheckedCreateWithoutAttendeesInput> | EventCreateWithoutAttendeesInput[] | EventUncheckedCreateWithoutAttendeesInput[]
    connectOrCreate?: EventCreateOrConnectWithoutAttendeesInput | EventCreateOrConnectWithoutAttendeesInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutOrganizersInput = {
    create?: XOR<EventCreateWithoutOrganizersInput, EventUncheckedCreateWithoutOrganizersInput> | EventCreateWithoutOrganizersInput[] | EventUncheckedCreateWithoutOrganizersInput[]
    connectOrCreate?: EventCreateOrConnectWithoutOrganizersInput | EventCreateOrConnectWithoutOrganizersInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type CoffeeChatCreateNestedManyWithoutInviterInput = {
    create?: XOR<CoffeeChatCreateWithoutInviterInput, CoffeeChatUncheckedCreateWithoutInviterInput> | CoffeeChatCreateWithoutInviterInput[] | CoffeeChatUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: CoffeeChatCreateOrConnectWithoutInviterInput | CoffeeChatCreateOrConnectWithoutInviterInput[]
    createMany?: CoffeeChatCreateManyInviterInputEnvelope
    connect?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
  }

  export type CoffeeChatCreateNestedManyWithoutInviteeInput = {
    create?: XOR<CoffeeChatCreateWithoutInviteeInput, CoffeeChatUncheckedCreateWithoutInviteeInput> | CoffeeChatCreateWithoutInviteeInput[] | CoffeeChatUncheckedCreateWithoutInviteeInput[]
    connectOrCreate?: CoffeeChatCreateOrConnectWithoutInviteeInput | CoffeeChatCreateOrConnectWithoutInviteeInput[]
    createMany?: CoffeeChatCreateManyInviteeInputEnvelope
    connect?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
  }

  export type ChatCreateNestedManyWithoutUser1Input = {
    create?: XOR<ChatCreateWithoutUser1Input, ChatUncheckedCreateWithoutUser1Input> | ChatCreateWithoutUser1Input[] | ChatUncheckedCreateWithoutUser1Input[]
    connectOrCreate?: ChatCreateOrConnectWithoutUser1Input | ChatCreateOrConnectWithoutUser1Input[]
    createMany?: ChatCreateManyUser1InputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type ChatCreateNestedManyWithoutUser2Input = {
    create?: XOR<ChatCreateWithoutUser2Input, ChatUncheckedCreateWithoutUser2Input> | ChatCreateWithoutUser2Input[] | ChatUncheckedCreateWithoutUser2Input[]
    connectOrCreate?: ChatCreateOrConnectWithoutUser2Input | ChatCreateOrConnectWithoutUser2Input[]
    createMany?: ChatCreateManyUser2InputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserDetailsInput = {
    create?: XOR<NotificationCreateWithoutUserDetailsInput, NotificationUncheckedCreateWithoutUserDetailsInput> | NotificationCreateWithoutUserDetailsInput[] | NotificationUncheckedCreateWithoutUserDetailsInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserDetailsInput | NotificationCreateOrConnectWithoutUserDetailsInput[]
    createMany?: NotificationCreateManyUserDetailsInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type InterestUncheckedCreateNestedManyWithoutUserDetailsInput = {
    create?: XOR<InterestCreateWithoutUserDetailsInput, InterestUncheckedCreateWithoutUserDetailsInput> | InterestCreateWithoutUserDetailsInput[] | InterestUncheckedCreateWithoutUserDetailsInput[]
    connectOrCreate?: InterestCreateOrConnectWithoutUserDetailsInput | InterestCreateOrConnectWithoutUserDetailsInput[]
    connect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
  }

  export type MatchUncheckedCreateNestedManyWithoutInviterInput = {
    create?: XOR<MatchCreateWithoutInviterInput, MatchUncheckedCreateWithoutInviterInput> | MatchCreateWithoutInviterInput[] | MatchUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutInviterInput | MatchCreateOrConnectWithoutInviterInput[]
    createMany?: MatchCreateManyInviterInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type MatchUncheckedCreateNestedManyWithoutInviteeInput = {
    create?: XOR<MatchCreateWithoutInviteeInput, MatchUncheckedCreateWithoutInviteeInput> | MatchCreateWithoutInviteeInput[] | MatchUncheckedCreateWithoutInviteeInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutInviteeInput | MatchCreateOrConnectWithoutInviteeInput[]
    createMany?: MatchCreateManyInviteeInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type UserSimilarityUncheckedCreateNestedManyWithoutCurrentUserInput = {
    create?: XOR<UserSimilarityCreateWithoutCurrentUserInput, UserSimilarityUncheckedCreateWithoutCurrentUserInput> | UserSimilarityCreateWithoutCurrentUserInput[] | UserSimilarityUncheckedCreateWithoutCurrentUserInput[]
    connectOrCreate?: UserSimilarityCreateOrConnectWithoutCurrentUserInput | UserSimilarityCreateOrConnectWithoutCurrentUserInput[]
    createMany?: UserSimilarityCreateManyCurrentUserInputEnvelope
    connect?: UserSimilarityWhereUniqueInput | UserSimilarityWhereUniqueInput[]
  }

  export type UserSimilarityUncheckedCreateNestedManyWithoutOtherUserInput = {
    create?: XOR<UserSimilarityCreateWithoutOtherUserInput, UserSimilarityUncheckedCreateWithoutOtherUserInput> | UserSimilarityCreateWithoutOtherUserInput[] | UserSimilarityUncheckedCreateWithoutOtherUserInput[]
    connectOrCreate?: UserSimilarityCreateOrConnectWithoutOtherUserInput | UserSimilarityCreateOrConnectWithoutOtherUserInput[]
    createMany?: UserSimilarityCreateManyOtherUserInputEnvelope
    connect?: UserSimilarityWhereUniqueInput | UserSimilarityWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutAttendeesInput = {
    create?: XOR<EventCreateWithoutAttendeesInput, EventUncheckedCreateWithoutAttendeesInput> | EventCreateWithoutAttendeesInput[] | EventUncheckedCreateWithoutAttendeesInput[]
    connectOrCreate?: EventCreateOrConnectWithoutAttendeesInput | EventCreateOrConnectWithoutAttendeesInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutOrganizersInput = {
    create?: XOR<EventCreateWithoutOrganizersInput, EventUncheckedCreateWithoutOrganizersInput> | EventCreateWithoutOrganizersInput[] | EventUncheckedCreateWithoutOrganizersInput[]
    connectOrCreate?: EventCreateOrConnectWithoutOrganizersInput | EventCreateOrConnectWithoutOrganizersInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type CoffeeChatUncheckedCreateNestedManyWithoutInviterInput = {
    create?: XOR<CoffeeChatCreateWithoutInviterInput, CoffeeChatUncheckedCreateWithoutInviterInput> | CoffeeChatCreateWithoutInviterInput[] | CoffeeChatUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: CoffeeChatCreateOrConnectWithoutInviterInput | CoffeeChatCreateOrConnectWithoutInviterInput[]
    createMany?: CoffeeChatCreateManyInviterInputEnvelope
    connect?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
  }

  export type CoffeeChatUncheckedCreateNestedManyWithoutInviteeInput = {
    create?: XOR<CoffeeChatCreateWithoutInviteeInput, CoffeeChatUncheckedCreateWithoutInviteeInput> | CoffeeChatCreateWithoutInviteeInput[] | CoffeeChatUncheckedCreateWithoutInviteeInput[]
    connectOrCreate?: CoffeeChatCreateOrConnectWithoutInviteeInput | CoffeeChatCreateOrConnectWithoutInviteeInput[]
    createMany?: CoffeeChatCreateManyInviteeInputEnvelope
    connect?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
  }

  export type ChatUncheckedCreateNestedManyWithoutUser1Input = {
    create?: XOR<ChatCreateWithoutUser1Input, ChatUncheckedCreateWithoutUser1Input> | ChatCreateWithoutUser1Input[] | ChatUncheckedCreateWithoutUser1Input[]
    connectOrCreate?: ChatCreateOrConnectWithoutUser1Input | ChatCreateOrConnectWithoutUser1Input[]
    createMany?: ChatCreateManyUser1InputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type ChatUncheckedCreateNestedManyWithoutUser2Input = {
    create?: XOR<ChatCreateWithoutUser2Input, ChatUncheckedCreateWithoutUser2Input> | ChatCreateWithoutUser2Input[] | ChatUncheckedCreateWithoutUser2Input[]
    connectOrCreate?: ChatCreateOrConnectWithoutUser2Input | ChatCreateOrConnectWithoutUser2Input[]
    createMany?: ChatCreateManyUser2InputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdateOneRequiredWithoutUserDetailsNestedInput = {
    create?: XOR<UserCreateWithoutUserDetailsInput, UserUncheckedCreateWithoutUserDetailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserDetailsInput
    upsert?: UserUpsertWithoutUserDetailsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserDetailsInput, UserUpdateWithoutUserDetailsInput>, UserUncheckedUpdateWithoutUserDetailsInput>
  }

  export type PostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserDetailsNestedInput = {
    create?: XOR<NotificationCreateWithoutUserDetailsInput, NotificationUncheckedCreateWithoutUserDetailsInput> | NotificationCreateWithoutUserDetailsInput[] | NotificationUncheckedCreateWithoutUserDetailsInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserDetailsInput | NotificationCreateOrConnectWithoutUserDetailsInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserDetailsInput | NotificationUpsertWithWhereUniqueWithoutUserDetailsInput[]
    createMany?: NotificationCreateManyUserDetailsInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserDetailsInput | NotificationUpdateWithWhereUniqueWithoutUserDetailsInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserDetailsInput | NotificationUpdateManyWithWhereWithoutUserDetailsInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type InterestUpdateManyWithoutUserDetailsNestedInput = {
    create?: XOR<InterestCreateWithoutUserDetailsInput, InterestUncheckedCreateWithoutUserDetailsInput> | InterestCreateWithoutUserDetailsInput[] | InterestUncheckedCreateWithoutUserDetailsInput[]
    connectOrCreate?: InterestCreateOrConnectWithoutUserDetailsInput | InterestCreateOrConnectWithoutUserDetailsInput[]
    upsert?: InterestUpsertWithWhereUniqueWithoutUserDetailsInput | InterestUpsertWithWhereUniqueWithoutUserDetailsInput[]
    set?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    disconnect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    delete?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    connect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    update?: InterestUpdateWithWhereUniqueWithoutUserDetailsInput | InterestUpdateWithWhereUniqueWithoutUserDetailsInput[]
    updateMany?: InterestUpdateManyWithWhereWithoutUserDetailsInput | InterestUpdateManyWithWhereWithoutUserDetailsInput[]
    deleteMany?: InterestScalarWhereInput | InterestScalarWhereInput[]
  }

  export type MatchUpdateManyWithoutInviterNestedInput = {
    create?: XOR<MatchCreateWithoutInviterInput, MatchUncheckedCreateWithoutInviterInput> | MatchCreateWithoutInviterInput[] | MatchUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutInviterInput | MatchCreateOrConnectWithoutInviterInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutInviterInput | MatchUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: MatchCreateManyInviterInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutInviterInput | MatchUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutInviterInput | MatchUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type MatchUpdateManyWithoutInviteeNestedInput = {
    create?: XOR<MatchCreateWithoutInviteeInput, MatchUncheckedCreateWithoutInviteeInput> | MatchCreateWithoutInviteeInput[] | MatchUncheckedCreateWithoutInviteeInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutInviteeInput | MatchCreateOrConnectWithoutInviteeInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutInviteeInput | MatchUpsertWithWhereUniqueWithoutInviteeInput[]
    createMany?: MatchCreateManyInviteeInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutInviteeInput | MatchUpdateWithWhereUniqueWithoutInviteeInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutInviteeInput | MatchUpdateManyWithWhereWithoutInviteeInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type UserSimilarityUpdateManyWithoutCurrentUserNestedInput = {
    create?: XOR<UserSimilarityCreateWithoutCurrentUserInput, UserSimilarityUncheckedCreateWithoutCurrentUserInput> | UserSimilarityCreateWithoutCurrentUserInput[] | UserSimilarityUncheckedCreateWithoutCurrentUserInput[]
    connectOrCreate?: UserSimilarityCreateOrConnectWithoutCurrentUserInput | UserSimilarityCreateOrConnectWithoutCurrentUserInput[]
    upsert?: UserSimilarityUpsertWithWhereUniqueWithoutCurrentUserInput | UserSimilarityUpsertWithWhereUniqueWithoutCurrentUserInput[]
    createMany?: UserSimilarityCreateManyCurrentUserInputEnvelope
    set?: UserSimilarityWhereUniqueInput | UserSimilarityWhereUniqueInput[]
    disconnect?: UserSimilarityWhereUniqueInput | UserSimilarityWhereUniqueInput[]
    delete?: UserSimilarityWhereUniqueInput | UserSimilarityWhereUniqueInput[]
    connect?: UserSimilarityWhereUniqueInput | UserSimilarityWhereUniqueInput[]
    update?: UserSimilarityUpdateWithWhereUniqueWithoutCurrentUserInput | UserSimilarityUpdateWithWhereUniqueWithoutCurrentUserInput[]
    updateMany?: UserSimilarityUpdateManyWithWhereWithoutCurrentUserInput | UserSimilarityUpdateManyWithWhereWithoutCurrentUserInput[]
    deleteMany?: UserSimilarityScalarWhereInput | UserSimilarityScalarWhereInput[]
  }

  export type UserSimilarityUpdateManyWithoutOtherUserNestedInput = {
    create?: XOR<UserSimilarityCreateWithoutOtherUserInput, UserSimilarityUncheckedCreateWithoutOtherUserInput> | UserSimilarityCreateWithoutOtherUserInput[] | UserSimilarityUncheckedCreateWithoutOtherUserInput[]
    connectOrCreate?: UserSimilarityCreateOrConnectWithoutOtherUserInput | UserSimilarityCreateOrConnectWithoutOtherUserInput[]
    upsert?: UserSimilarityUpsertWithWhereUniqueWithoutOtherUserInput | UserSimilarityUpsertWithWhereUniqueWithoutOtherUserInput[]
    createMany?: UserSimilarityCreateManyOtherUserInputEnvelope
    set?: UserSimilarityWhereUniqueInput | UserSimilarityWhereUniqueInput[]
    disconnect?: UserSimilarityWhereUniqueInput | UserSimilarityWhereUniqueInput[]
    delete?: UserSimilarityWhereUniqueInput | UserSimilarityWhereUniqueInput[]
    connect?: UserSimilarityWhereUniqueInput | UserSimilarityWhereUniqueInput[]
    update?: UserSimilarityUpdateWithWhereUniqueWithoutOtherUserInput | UserSimilarityUpdateWithWhereUniqueWithoutOtherUserInput[]
    updateMany?: UserSimilarityUpdateManyWithWhereWithoutOtherUserInput | UserSimilarityUpdateManyWithWhereWithoutOtherUserInput[]
    deleteMany?: UserSimilarityScalarWhereInput | UserSimilarityScalarWhereInput[]
  }

  export type EventUpdateManyWithoutAttendeesNestedInput = {
    create?: XOR<EventCreateWithoutAttendeesInput, EventUncheckedCreateWithoutAttendeesInput> | EventCreateWithoutAttendeesInput[] | EventUncheckedCreateWithoutAttendeesInput[]
    connectOrCreate?: EventCreateOrConnectWithoutAttendeesInput | EventCreateOrConnectWithoutAttendeesInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutAttendeesInput | EventUpsertWithWhereUniqueWithoutAttendeesInput[]
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutAttendeesInput | EventUpdateWithWhereUniqueWithoutAttendeesInput[]
    updateMany?: EventUpdateManyWithWhereWithoutAttendeesInput | EventUpdateManyWithWhereWithoutAttendeesInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type EventUpdateManyWithoutOrganizersNestedInput = {
    create?: XOR<EventCreateWithoutOrganizersInput, EventUncheckedCreateWithoutOrganizersInput> | EventCreateWithoutOrganizersInput[] | EventUncheckedCreateWithoutOrganizersInput[]
    connectOrCreate?: EventCreateOrConnectWithoutOrganizersInput | EventCreateOrConnectWithoutOrganizersInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutOrganizersInput | EventUpsertWithWhereUniqueWithoutOrganizersInput[]
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutOrganizersInput | EventUpdateWithWhereUniqueWithoutOrganizersInput[]
    updateMany?: EventUpdateManyWithWhereWithoutOrganizersInput | EventUpdateManyWithWhereWithoutOrganizersInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type CoffeeChatUpdateManyWithoutInviterNestedInput = {
    create?: XOR<CoffeeChatCreateWithoutInviterInput, CoffeeChatUncheckedCreateWithoutInviterInput> | CoffeeChatCreateWithoutInviterInput[] | CoffeeChatUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: CoffeeChatCreateOrConnectWithoutInviterInput | CoffeeChatCreateOrConnectWithoutInviterInput[]
    upsert?: CoffeeChatUpsertWithWhereUniqueWithoutInviterInput | CoffeeChatUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: CoffeeChatCreateManyInviterInputEnvelope
    set?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    disconnect?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    delete?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    connect?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    update?: CoffeeChatUpdateWithWhereUniqueWithoutInviterInput | CoffeeChatUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: CoffeeChatUpdateManyWithWhereWithoutInviterInput | CoffeeChatUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: CoffeeChatScalarWhereInput | CoffeeChatScalarWhereInput[]
  }

  export type CoffeeChatUpdateManyWithoutInviteeNestedInput = {
    create?: XOR<CoffeeChatCreateWithoutInviteeInput, CoffeeChatUncheckedCreateWithoutInviteeInput> | CoffeeChatCreateWithoutInviteeInput[] | CoffeeChatUncheckedCreateWithoutInviteeInput[]
    connectOrCreate?: CoffeeChatCreateOrConnectWithoutInviteeInput | CoffeeChatCreateOrConnectWithoutInviteeInput[]
    upsert?: CoffeeChatUpsertWithWhereUniqueWithoutInviteeInput | CoffeeChatUpsertWithWhereUniqueWithoutInviteeInput[]
    createMany?: CoffeeChatCreateManyInviteeInputEnvelope
    set?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    disconnect?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    delete?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    connect?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    update?: CoffeeChatUpdateWithWhereUniqueWithoutInviteeInput | CoffeeChatUpdateWithWhereUniqueWithoutInviteeInput[]
    updateMany?: CoffeeChatUpdateManyWithWhereWithoutInviteeInput | CoffeeChatUpdateManyWithWhereWithoutInviteeInput[]
    deleteMany?: CoffeeChatScalarWhereInput | CoffeeChatScalarWhereInput[]
  }

  export type ChatUpdateManyWithoutUser1NestedInput = {
    create?: XOR<ChatCreateWithoutUser1Input, ChatUncheckedCreateWithoutUser1Input> | ChatCreateWithoutUser1Input[] | ChatUncheckedCreateWithoutUser1Input[]
    connectOrCreate?: ChatCreateOrConnectWithoutUser1Input | ChatCreateOrConnectWithoutUser1Input[]
    upsert?: ChatUpsertWithWhereUniqueWithoutUser1Input | ChatUpsertWithWhereUniqueWithoutUser1Input[]
    createMany?: ChatCreateManyUser1InputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutUser1Input | ChatUpdateWithWhereUniqueWithoutUser1Input[]
    updateMany?: ChatUpdateManyWithWhereWithoutUser1Input | ChatUpdateManyWithWhereWithoutUser1Input[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type ChatUpdateManyWithoutUser2NestedInput = {
    create?: XOR<ChatCreateWithoutUser2Input, ChatUncheckedCreateWithoutUser2Input> | ChatCreateWithoutUser2Input[] | ChatUncheckedCreateWithoutUser2Input[]
    connectOrCreate?: ChatCreateOrConnectWithoutUser2Input | ChatCreateOrConnectWithoutUser2Input[]
    upsert?: ChatUpsertWithWhereUniqueWithoutUser2Input | ChatUpsertWithWhereUniqueWithoutUser2Input[]
    createMany?: ChatCreateManyUser2InputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutUser2Input | ChatUpdateWithWhereUniqueWithoutUser2Input[]
    updateMany?: ChatUpdateManyWithWhereWithoutUser2Input | ChatUpdateManyWithWhereWithoutUser2Input[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserDetailsNestedInput = {
    create?: XOR<NotificationCreateWithoutUserDetailsInput, NotificationUncheckedCreateWithoutUserDetailsInput> | NotificationCreateWithoutUserDetailsInput[] | NotificationUncheckedCreateWithoutUserDetailsInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserDetailsInput | NotificationCreateOrConnectWithoutUserDetailsInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserDetailsInput | NotificationUpsertWithWhereUniqueWithoutUserDetailsInput[]
    createMany?: NotificationCreateManyUserDetailsInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserDetailsInput | NotificationUpdateWithWhereUniqueWithoutUserDetailsInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserDetailsInput | NotificationUpdateManyWithWhereWithoutUserDetailsInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type InterestUncheckedUpdateManyWithoutUserDetailsNestedInput = {
    create?: XOR<InterestCreateWithoutUserDetailsInput, InterestUncheckedCreateWithoutUserDetailsInput> | InterestCreateWithoutUserDetailsInput[] | InterestUncheckedCreateWithoutUserDetailsInput[]
    connectOrCreate?: InterestCreateOrConnectWithoutUserDetailsInput | InterestCreateOrConnectWithoutUserDetailsInput[]
    upsert?: InterestUpsertWithWhereUniqueWithoutUserDetailsInput | InterestUpsertWithWhereUniqueWithoutUserDetailsInput[]
    set?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    disconnect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    delete?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    connect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    update?: InterestUpdateWithWhereUniqueWithoutUserDetailsInput | InterestUpdateWithWhereUniqueWithoutUserDetailsInput[]
    updateMany?: InterestUpdateManyWithWhereWithoutUserDetailsInput | InterestUpdateManyWithWhereWithoutUserDetailsInput[]
    deleteMany?: InterestScalarWhereInput | InterestScalarWhereInput[]
  }

  export type MatchUncheckedUpdateManyWithoutInviterNestedInput = {
    create?: XOR<MatchCreateWithoutInviterInput, MatchUncheckedCreateWithoutInviterInput> | MatchCreateWithoutInviterInput[] | MatchUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutInviterInput | MatchCreateOrConnectWithoutInviterInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutInviterInput | MatchUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: MatchCreateManyInviterInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutInviterInput | MatchUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutInviterInput | MatchUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type MatchUncheckedUpdateManyWithoutInviteeNestedInput = {
    create?: XOR<MatchCreateWithoutInviteeInput, MatchUncheckedCreateWithoutInviteeInput> | MatchCreateWithoutInviteeInput[] | MatchUncheckedCreateWithoutInviteeInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutInviteeInput | MatchCreateOrConnectWithoutInviteeInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutInviteeInput | MatchUpsertWithWhereUniqueWithoutInviteeInput[]
    createMany?: MatchCreateManyInviteeInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutInviteeInput | MatchUpdateWithWhereUniqueWithoutInviteeInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutInviteeInput | MatchUpdateManyWithWhereWithoutInviteeInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type UserSimilarityUncheckedUpdateManyWithoutCurrentUserNestedInput = {
    create?: XOR<UserSimilarityCreateWithoutCurrentUserInput, UserSimilarityUncheckedCreateWithoutCurrentUserInput> | UserSimilarityCreateWithoutCurrentUserInput[] | UserSimilarityUncheckedCreateWithoutCurrentUserInput[]
    connectOrCreate?: UserSimilarityCreateOrConnectWithoutCurrentUserInput | UserSimilarityCreateOrConnectWithoutCurrentUserInput[]
    upsert?: UserSimilarityUpsertWithWhereUniqueWithoutCurrentUserInput | UserSimilarityUpsertWithWhereUniqueWithoutCurrentUserInput[]
    createMany?: UserSimilarityCreateManyCurrentUserInputEnvelope
    set?: UserSimilarityWhereUniqueInput | UserSimilarityWhereUniqueInput[]
    disconnect?: UserSimilarityWhereUniqueInput | UserSimilarityWhereUniqueInput[]
    delete?: UserSimilarityWhereUniqueInput | UserSimilarityWhereUniqueInput[]
    connect?: UserSimilarityWhereUniqueInput | UserSimilarityWhereUniqueInput[]
    update?: UserSimilarityUpdateWithWhereUniqueWithoutCurrentUserInput | UserSimilarityUpdateWithWhereUniqueWithoutCurrentUserInput[]
    updateMany?: UserSimilarityUpdateManyWithWhereWithoutCurrentUserInput | UserSimilarityUpdateManyWithWhereWithoutCurrentUserInput[]
    deleteMany?: UserSimilarityScalarWhereInput | UserSimilarityScalarWhereInput[]
  }

  export type UserSimilarityUncheckedUpdateManyWithoutOtherUserNestedInput = {
    create?: XOR<UserSimilarityCreateWithoutOtherUserInput, UserSimilarityUncheckedCreateWithoutOtherUserInput> | UserSimilarityCreateWithoutOtherUserInput[] | UserSimilarityUncheckedCreateWithoutOtherUserInput[]
    connectOrCreate?: UserSimilarityCreateOrConnectWithoutOtherUserInput | UserSimilarityCreateOrConnectWithoutOtherUserInput[]
    upsert?: UserSimilarityUpsertWithWhereUniqueWithoutOtherUserInput | UserSimilarityUpsertWithWhereUniqueWithoutOtherUserInput[]
    createMany?: UserSimilarityCreateManyOtherUserInputEnvelope
    set?: UserSimilarityWhereUniqueInput | UserSimilarityWhereUniqueInput[]
    disconnect?: UserSimilarityWhereUniqueInput | UserSimilarityWhereUniqueInput[]
    delete?: UserSimilarityWhereUniqueInput | UserSimilarityWhereUniqueInput[]
    connect?: UserSimilarityWhereUniqueInput | UserSimilarityWhereUniqueInput[]
    update?: UserSimilarityUpdateWithWhereUniqueWithoutOtherUserInput | UserSimilarityUpdateWithWhereUniqueWithoutOtherUserInput[]
    updateMany?: UserSimilarityUpdateManyWithWhereWithoutOtherUserInput | UserSimilarityUpdateManyWithWhereWithoutOtherUserInput[]
    deleteMany?: UserSimilarityScalarWhereInput | UserSimilarityScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutAttendeesNestedInput = {
    create?: XOR<EventCreateWithoutAttendeesInput, EventUncheckedCreateWithoutAttendeesInput> | EventCreateWithoutAttendeesInput[] | EventUncheckedCreateWithoutAttendeesInput[]
    connectOrCreate?: EventCreateOrConnectWithoutAttendeesInput | EventCreateOrConnectWithoutAttendeesInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutAttendeesInput | EventUpsertWithWhereUniqueWithoutAttendeesInput[]
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutAttendeesInput | EventUpdateWithWhereUniqueWithoutAttendeesInput[]
    updateMany?: EventUpdateManyWithWhereWithoutAttendeesInput | EventUpdateManyWithWhereWithoutAttendeesInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutOrganizersNestedInput = {
    create?: XOR<EventCreateWithoutOrganizersInput, EventUncheckedCreateWithoutOrganizersInput> | EventCreateWithoutOrganizersInput[] | EventUncheckedCreateWithoutOrganizersInput[]
    connectOrCreate?: EventCreateOrConnectWithoutOrganizersInput | EventCreateOrConnectWithoutOrganizersInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutOrganizersInput | EventUpsertWithWhereUniqueWithoutOrganizersInput[]
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutOrganizersInput | EventUpdateWithWhereUniqueWithoutOrganizersInput[]
    updateMany?: EventUpdateManyWithWhereWithoutOrganizersInput | EventUpdateManyWithWhereWithoutOrganizersInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type CoffeeChatUncheckedUpdateManyWithoutInviterNestedInput = {
    create?: XOR<CoffeeChatCreateWithoutInviterInput, CoffeeChatUncheckedCreateWithoutInviterInput> | CoffeeChatCreateWithoutInviterInput[] | CoffeeChatUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: CoffeeChatCreateOrConnectWithoutInviterInput | CoffeeChatCreateOrConnectWithoutInviterInput[]
    upsert?: CoffeeChatUpsertWithWhereUniqueWithoutInviterInput | CoffeeChatUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: CoffeeChatCreateManyInviterInputEnvelope
    set?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    disconnect?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    delete?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    connect?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    update?: CoffeeChatUpdateWithWhereUniqueWithoutInviterInput | CoffeeChatUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: CoffeeChatUpdateManyWithWhereWithoutInviterInput | CoffeeChatUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: CoffeeChatScalarWhereInput | CoffeeChatScalarWhereInput[]
  }

  export type CoffeeChatUncheckedUpdateManyWithoutInviteeNestedInput = {
    create?: XOR<CoffeeChatCreateWithoutInviteeInput, CoffeeChatUncheckedCreateWithoutInviteeInput> | CoffeeChatCreateWithoutInviteeInput[] | CoffeeChatUncheckedCreateWithoutInviteeInput[]
    connectOrCreate?: CoffeeChatCreateOrConnectWithoutInviteeInput | CoffeeChatCreateOrConnectWithoutInviteeInput[]
    upsert?: CoffeeChatUpsertWithWhereUniqueWithoutInviteeInput | CoffeeChatUpsertWithWhereUniqueWithoutInviteeInput[]
    createMany?: CoffeeChatCreateManyInviteeInputEnvelope
    set?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    disconnect?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    delete?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    connect?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    update?: CoffeeChatUpdateWithWhereUniqueWithoutInviteeInput | CoffeeChatUpdateWithWhereUniqueWithoutInviteeInput[]
    updateMany?: CoffeeChatUpdateManyWithWhereWithoutInviteeInput | CoffeeChatUpdateManyWithWhereWithoutInviteeInput[]
    deleteMany?: CoffeeChatScalarWhereInput | CoffeeChatScalarWhereInput[]
  }

  export type ChatUncheckedUpdateManyWithoutUser1NestedInput = {
    create?: XOR<ChatCreateWithoutUser1Input, ChatUncheckedCreateWithoutUser1Input> | ChatCreateWithoutUser1Input[] | ChatUncheckedCreateWithoutUser1Input[]
    connectOrCreate?: ChatCreateOrConnectWithoutUser1Input | ChatCreateOrConnectWithoutUser1Input[]
    upsert?: ChatUpsertWithWhereUniqueWithoutUser1Input | ChatUpsertWithWhereUniqueWithoutUser1Input[]
    createMany?: ChatCreateManyUser1InputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutUser1Input | ChatUpdateWithWhereUniqueWithoutUser1Input[]
    updateMany?: ChatUpdateManyWithWhereWithoutUser1Input | ChatUpdateManyWithWhereWithoutUser1Input[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type ChatUncheckedUpdateManyWithoutUser2NestedInput = {
    create?: XOR<ChatCreateWithoutUser2Input, ChatUncheckedCreateWithoutUser2Input> | ChatCreateWithoutUser2Input[] | ChatUncheckedCreateWithoutUser2Input[]
    connectOrCreate?: ChatCreateOrConnectWithoutUser2Input | ChatCreateOrConnectWithoutUser2Input[]
    upsert?: ChatUpsertWithWhereUniqueWithoutUser2Input | ChatUpsertWithWhereUniqueWithoutUser2Input[]
    createMany?: ChatCreateManyUser2InputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutUser2Input | ChatUpdateWithWhereUniqueWithoutUser2Input[]
    updateMany?: ChatUpdateManyWithWhereWithoutUser2Input | ChatUpdateManyWithWhereWithoutUser2Input[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type UserDetailsCreateNestedOneWithoutPostsInput = {
    create?: XOR<UserDetailsCreateWithoutPostsInput, UserDetailsUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserDetailsCreateOrConnectWithoutPostsInput
    connect?: UserDetailsWhereUniqueInput
  }

  export type ReactionCreateNestedOneWithoutPostInput = {
    create?: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput>
    connectOrCreate?: ReactionCreateOrConnectWithoutPostInput
    connect?: ReactionWhereUniqueInput
  }

  export type PostTagCreateNestedManyWithoutPostsInput = {
    create?: XOR<PostTagCreateWithoutPostsInput, PostTagUncheckedCreateWithoutPostsInput> | PostTagCreateWithoutPostsInput[] | PostTagUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutPostsInput | PostTagCreateOrConnectWithoutPostsInput[]
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ReactionUncheckedCreateNestedOneWithoutPostInput = {
    create?: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput>
    connectOrCreate?: ReactionCreateOrConnectWithoutPostInput
    connect?: ReactionWhereUniqueInput
  }

  export type PostTagUncheckedCreateNestedManyWithoutPostsInput = {
    create?: XOR<PostTagCreateWithoutPostsInput, PostTagUncheckedCreateWithoutPostsInput> | PostTagCreateWithoutPostsInput[] | PostTagUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutPostsInput | PostTagCreateOrConnectWithoutPostsInput[]
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserDetailsUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<UserDetailsCreateWithoutPostsInput, UserDetailsUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserDetailsCreateOrConnectWithoutPostsInput
    upsert?: UserDetailsUpsertWithoutPostsInput
    connect?: UserDetailsWhereUniqueInput
    update?: XOR<XOR<UserDetailsUpdateToOneWithWhereWithoutPostsInput, UserDetailsUpdateWithoutPostsInput>, UserDetailsUncheckedUpdateWithoutPostsInput>
  }

  export type ReactionUpdateOneWithoutPostNestedInput = {
    create?: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput>
    connectOrCreate?: ReactionCreateOrConnectWithoutPostInput
    upsert?: ReactionUpsertWithoutPostInput
    disconnect?: ReactionWhereInput | boolean
    delete?: ReactionWhereInput | boolean
    connect?: ReactionWhereUniqueInput
    update?: XOR<XOR<ReactionUpdateToOneWithWhereWithoutPostInput, ReactionUpdateWithoutPostInput>, ReactionUncheckedUpdateWithoutPostInput>
  }

  export type PostTagUpdateManyWithoutPostsNestedInput = {
    create?: XOR<PostTagCreateWithoutPostsInput, PostTagUncheckedCreateWithoutPostsInput> | PostTagCreateWithoutPostsInput[] | PostTagUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutPostsInput | PostTagCreateOrConnectWithoutPostsInput[]
    upsert?: PostTagUpsertWithWhereUniqueWithoutPostsInput | PostTagUpsertWithWhereUniqueWithoutPostsInput[]
    set?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    disconnect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    delete?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    update?: PostTagUpdateWithWhereUniqueWithoutPostsInput | PostTagUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: PostTagUpdateManyWithWhereWithoutPostsInput | PostTagUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ReactionUncheckedUpdateOneWithoutPostNestedInput = {
    create?: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput>
    connectOrCreate?: ReactionCreateOrConnectWithoutPostInput
    upsert?: ReactionUpsertWithoutPostInput
    disconnect?: ReactionWhereInput | boolean
    delete?: ReactionWhereInput | boolean
    connect?: ReactionWhereUniqueInput
    update?: XOR<XOR<ReactionUpdateToOneWithWhereWithoutPostInput, ReactionUpdateWithoutPostInput>, ReactionUncheckedUpdateWithoutPostInput>
  }

  export type PostTagUncheckedUpdateManyWithoutPostsNestedInput = {
    create?: XOR<PostTagCreateWithoutPostsInput, PostTagUncheckedCreateWithoutPostsInput> | PostTagCreateWithoutPostsInput[] | PostTagUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutPostsInput | PostTagCreateOrConnectWithoutPostsInput[]
    upsert?: PostTagUpsertWithWhereUniqueWithoutPostsInput | PostTagUpsertWithWhereUniqueWithoutPostsInput[]
    set?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    disconnect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    delete?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    update?: PostTagUpdateWithWhereUniqueWithoutPostsInput | PostTagUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: PostTagUpdateManyWithWhereWithoutPostsInput | PostTagUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutReactionInput = {
    create?: XOR<PostCreateWithoutReactionInput, PostUncheckedCreateWithoutReactionInput>
    connectOrCreate?: PostCreateOrConnectWithoutReactionInput
    connect?: PostWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutReactionNestedInput = {
    create?: XOR<PostCreateWithoutReactionInput, PostUncheckedCreateWithoutReactionInput>
    connectOrCreate?: PostCreateOrConnectWithoutReactionInput
    upsert?: PostUpsertWithoutReactionInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutReactionInput, PostUpdateWithoutReactionInput>, PostUncheckedUpdateWithoutReactionInput>
  }

  export type PostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    connect?: PostWhereUniqueInput
  }

  export type UserDetailsCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserDetailsCreateWithoutCommentsInput, UserDetailsUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserDetailsCreateOrConnectWithoutCommentsInput
    connect?: UserDetailsWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    upsert?: PostUpsertWithoutCommentsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutCommentsInput, PostUpdateWithoutCommentsInput>, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type UserDetailsUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserDetailsCreateWithoutCommentsInput, UserDetailsUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserDetailsCreateOrConnectWithoutCommentsInput
    upsert?: UserDetailsUpsertWithoutCommentsInput
    connect?: UserDetailsWhereUniqueInput
    update?: XOR<XOR<UserDetailsUpdateToOneWithWhereWithoutCommentsInput, UserDetailsUpdateWithoutCommentsInput>, UserDetailsUncheckedUpdateWithoutCommentsInput>
  }

  export type PostCreateNestedManyWithoutPostTagsInput = {
    create?: XOR<PostCreateWithoutPostTagsInput, PostUncheckedCreateWithoutPostTagsInput> | PostCreateWithoutPostTagsInput[] | PostUncheckedCreateWithoutPostTagsInput[]
    connectOrCreate?: PostCreateOrConnectWithoutPostTagsInput | PostCreateOrConnectWithoutPostTagsInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutPostTagsInput = {
    create?: XOR<PostCreateWithoutPostTagsInput, PostUncheckedCreateWithoutPostTagsInput> | PostCreateWithoutPostTagsInput[] | PostUncheckedCreateWithoutPostTagsInput[]
    connectOrCreate?: PostCreateOrConnectWithoutPostTagsInput | PostCreateOrConnectWithoutPostTagsInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type PostUpdateManyWithoutPostTagsNestedInput = {
    create?: XOR<PostCreateWithoutPostTagsInput, PostUncheckedCreateWithoutPostTagsInput> | PostCreateWithoutPostTagsInput[] | PostUncheckedCreateWithoutPostTagsInput[]
    connectOrCreate?: PostCreateOrConnectWithoutPostTagsInput | PostCreateOrConnectWithoutPostTagsInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutPostTagsInput | PostUpsertWithWhereUniqueWithoutPostTagsInput[]
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutPostTagsInput | PostUpdateWithWhereUniqueWithoutPostTagsInput[]
    updateMany?: PostUpdateManyWithWhereWithoutPostTagsInput | PostUpdateManyWithWhereWithoutPostTagsInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutPostTagsNestedInput = {
    create?: XOR<PostCreateWithoutPostTagsInput, PostUncheckedCreateWithoutPostTagsInput> | PostCreateWithoutPostTagsInput[] | PostUncheckedCreateWithoutPostTagsInput[]
    connectOrCreate?: PostCreateOrConnectWithoutPostTagsInput | PostCreateOrConnectWithoutPostTagsInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutPostTagsInput | PostUpsertWithWhereUniqueWithoutPostTagsInput[]
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutPostTagsInput | PostUpdateWithWhereUniqueWithoutPostTagsInput[]
    updateMany?: PostUpdateManyWithWhereWithoutPostTagsInput | PostUpdateManyWithWhereWithoutPostTagsInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type UserDetailsCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserDetailsCreateWithoutNotificationsInput, UserDetailsUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserDetailsCreateOrConnectWithoutNotificationsInput
    connect?: UserDetailsWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserDetailsUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserDetailsCreateWithoutNotificationsInput, UserDetailsUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserDetailsCreateOrConnectWithoutNotificationsInput
    upsert?: UserDetailsUpsertWithoutNotificationsInput
    connect?: UserDetailsWhereUniqueInput
    update?: XOR<XOR<UserDetailsUpdateToOneWithWhereWithoutNotificationsInput, UserDetailsUpdateWithoutNotificationsInput>, UserDetailsUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserDetailsCreateNestedManyWithoutInterestsInput = {
    create?: XOR<UserDetailsCreateWithoutInterestsInput, UserDetailsUncheckedCreateWithoutInterestsInput> | UserDetailsCreateWithoutInterestsInput[] | UserDetailsUncheckedCreateWithoutInterestsInput[]
    connectOrCreate?: UserDetailsCreateOrConnectWithoutInterestsInput | UserDetailsCreateOrConnectWithoutInterestsInput[]
    connect?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
  }

  export type UserDetailsUncheckedCreateNestedManyWithoutInterestsInput = {
    create?: XOR<UserDetailsCreateWithoutInterestsInput, UserDetailsUncheckedCreateWithoutInterestsInput> | UserDetailsCreateWithoutInterestsInput[] | UserDetailsUncheckedCreateWithoutInterestsInput[]
    connectOrCreate?: UserDetailsCreateOrConnectWithoutInterestsInput | UserDetailsCreateOrConnectWithoutInterestsInput[]
    connect?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
  }

  export type UserDetailsUpdateManyWithoutInterestsNestedInput = {
    create?: XOR<UserDetailsCreateWithoutInterestsInput, UserDetailsUncheckedCreateWithoutInterestsInput> | UserDetailsCreateWithoutInterestsInput[] | UserDetailsUncheckedCreateWithoutInterestsInput[]
    connectOrCreate?: UserDetailsCreateOrConnectWithoutInterestsInput | UserDetailsCreateOrConnectWithoutInterestsInput[]
    upsert?: UserDetailsUpsertWithWhereUniqueWithoutInterestsInput | UserDetailsUpsertWithWhereUniqueWithoutInterestsInput[]
    set?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
    disconnect?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
    delete?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
    connect?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
    update?: UserDetailsUpdateWithWhereUniqueWithoutInterestsInput | UserDetailsUpdateWithWhereUniqueWithoutInterestsInput[]
    updateMany?: UserDetailsUpdateManyWithWhereWithoutInterestsInput | UserDetailsUpdateManyWithWhereWithoutInterestsInput[]
    deleteMany?: UserDetailsScalarWhereInput | UserDetailsScalarWhereInput[]
  }

  export type UserDetailsUncheckedUpdateManyWithoutInterestsNestedInput = {
    create?: XOR<UserDetailsCreateWithoutInterestsInput, UserDetailsUncheckedCreateWithoutInterestsInput> | UserDetailsCreateWithoutInterestsInput[] | UserDetailsUncheckedCreateWithoutInterestsInput[]
    connectOrCreate?: UserDetailsCreateOrConnectWithoutInterestsInput | UserDetailsCreateOrConnectWithoutInterestsInput[]
    upsert?: UserDetailsUpsertWithWhereUniqueWithoutInterestsInput | UserDetailsUpsertWithWhereUniqueWithoutInterestsInput[]
    set?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
    disconnect?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
    delete?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
    connect?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
    update?: UserDetailsUpdateWithWhereUniqueWithoutInterestsInput | UserDetailsUpdateWithWhereUniqueWithoutInterestsInput[]
    updateMany?: UserDetailsUpdateManyWithWhereWithoutInterestsInput | UserDetailsUpdateManyWithWhereWithoutInterestsInput[]
    deleteMany?: UserDetailsScalarWhereInput | UserDetailsScalarWhereInput[]
  }

  export type UserDetailsCreateNestedOneWithoutMatchesSentInput = {
    create?: XOR<UserDetailsCreateWithoutMatchesSentInput, UserDetailsUncheckedCreateWithoutMatchesSentInput>
    connectOrCreate?: UserDetailsCreateOrConnectWithoutMatchesSentInput
    connect?: UserDetailsWhereUniqueInput
  }

  export type UserDetailsCreateNestedOneWithoutMatchesReceivedInput = {
    create?: XOR<UserDetailsCreateWithoutMatchesReceivedInput, UserDetailsUncheckedCreateWithoutMatchesReceivedInput>
    connectOrCreate?: UserDetailsCreateOrConnectWithoutMatchesReceivedInput
    connect?: UserDetailsWhereUniqueInput
  }

  export type EnumMatchStatusFieldUpdateOperationsInput = {
    set?: $Enums.MatchStatus
  }

  export type UserDetailsUpdateOneRequiredWithoutMatchesSentNestedInput = {
    create?: XOR<UserDetailsCreateWithoutMatchesSentInput, UserDetailsUncheckedCreateWithoutMatchesSentInput>
    connectOrCreate?: UserDetailsCreateOrConnectWithoutMatchesSentInput
    upsert?: UserDetailsUpsertWithoutMatchesSentInput
    connect?: UserDetailsWhereUniqueInput
    update?: XOR<XOR<UserDetailsUpdateToOneWithWhereWithoutMatchesSentInput, UserDetailsUpdateWithoutMatchesSentInput>, UserDetailsUncheckedUpdateWithoutMatchesSentInput>
  }

  export type UserDetailsUpdateOneRequiredWithoutMatchesReceivedNestedInput = {
    create?: XOR<UserDetailsCreateWithoutMatchesReceivedInput, UserDetailsUncheckedCreateWithoutMatchesReceivedInput>
    connectOrCreate?: UserDetailsCreateOrConnectWithoutMatchesReceivedInput
    upsert?: UserDetailsUpsertWithoutMatchesReceivedInput
    connect?: UserDetailsWhereUniqueInput
    update?: XOR<XOR<UserDetailsUpdateToOneWithWhereWithoutMatchesReceivedInput, UserDetailsUpdateWithoutMatchesReceivedInput>, UserDetailsUncheckedUpdateWithoutMatchesReceivedInput>
  }

  export type UserDetailsCreateNestedOneWithoutCurrentUserSimilarityInput = {
    create?: XOR<UserDetailsCreateWithoutCurrentUserSimilarityInput, UserDetailsUncheckedCreateWithoutCurrentUserSimilarityInput>
    connectOrCreate?: UserDetailsCreateOrConnectWithoutCurrentUserSimilarityInput
    connect?: UserDetailsWhereUniqueInput
  }

  export type UserDetailsCreateNestedOneWithoutOtherUserSimilarityInput = {
    create?: XOR<UserDetailsCreateWithoutOtherUserSimilarityInput, UserDetailsUncheckedCreateWithoutOtherUserSimilarityInput>
    connectOrCreate?: UserDetailsCreateOrConnectWithoutOtherUserSimilarityInput
    connect?: UserDetailsWhereUniqueInput
  }

  export type UserDetailsUpdateOneRequiredWithoutCurrentUserSimilarityNestedInput = {
    create?: XOR<UserDetailsCreateWithoutCurrentUserSimilarityInput, UserDetailsUncheckedCreateWithoutCurrentUserSimilarityInput>
    connectOrCreate?: UserDetailsCreateOrConnectWithoutCurrentUserSimilarityInput
    upsert?: UserDetailsUpsertWithoutCurrentUserSimilarityInput
    connect?: UserDetailsWhereUniqueInput
    update?: XOR<XOR<UserDetailsUpdateToOneWithWhereWithoutCurrentUserSimilarityInput, UserDetailsUpdateWithoutCurrentUserSimilarityInput>, UserDetailsUncheckedUpdateWithoutCurrentUserSimilarityInput>
  }

  export type UserDetailsUpdateOneRequiredWithoutOtherUserSimilarityNestedInput = {
    create?: XOR<UserDetailsCreateWithoutOtherUserSimilarityInput, UserDetailsUncheckedCreateWithoutOtherUserSimilarityInput>
    connectOrCreate?: UserDetailsCreateOrConnectWithoutOtherUserSimilarityInput
    upsert?: UserDetailsUpsertWithoutOtherUserSimilarityInput
    connect?: UserDetailsWhereUniqueInput
    update?: XOR<XOR<UserDetailsUpdateToOneWithWhereWithoutOtherUserSimilarityInput, UserDetailsUpdateWithoutOtherUserSimilarityInput>, UserDetailsUncheckedUpdateWithoutOtherUserSimilarityInput>
  }

  export type UserDetailsCreateNestedManyWithoutAsEventOrganizerInput = {
    create?: XOR<UserDetailsCreateWithoutAsEventOrganizerInput, UserDetailsUncheckedCreateWithoutAsEventOrganizerInput> | UserDetailsCreateWithoutAsEventOrganizerInput[] | UserDetailsUncheckedCreateWithoutAsEventOrganizerInput[]
    connectOrCreate?: UserDetailsCreateOrConnectWithoutAsEventOrganizerInput | UserDetailsCreateOrConnectWithoutAsEventOrganizerInput[]
    connect?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
  }

  export type UserDetailsCreateNestedManyWithoutAsEventAttendeeInput = {
    create?: XOR<UserDetailsCreateWithoutAsEventAttendeeInput, UserDetailsUncheckedCreateWithoutAsEventAttendeeInput> | UserDetailsCreateWithoutAsEventAttendeeInput[] | UserDetailsUncheckedCreateWithoutAsEventAttendeeInput[]
    connectOrCreate?: UserDetailsCreateOrConnectWithoutAsEventAttendeeInput | UserDetailsCreateOrConnectWithoutAsEventAttendeeInput[]
    connect?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
  }

  export type UserDetailsUncheckedCreateNestedManyWithoutAsEventOrganizerInput = {
    create?: XOR<UserDetailsCreateWithoutAsEventOrganizerInput, UserDetailsUncheckedCreateWithoutAsEventOrganizerInput> | UserDetailsCreateWithoutAsEventOrganizerInput[] | UserDetailsUncheckedCreateWithoutAsEventOrganizerInput[]
    connectOrCreate?: UserDetailsCreateOrConnectWithoutAsEventOrganizerInput | UserDetailsCreateOrConnectWithoutAsEventOrganizerInput[]
    connect?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
  }

  export type UserDetailsUncheckedCreateNestedManyWithoutAsEventAttendeeInput = {
    create?: XOR<UserDetailsCreateWithoutAsEventAttendeeInput, UserDetailsUncheckedCreateWithoutAsEventAttendeeInput> | UserDetailsCreateWithoutAsEventAttendeeInput[] | UserDetailsUncheckedCreateWithoutAsEventAttendeeInput[]
    connectOrCreate?: UserDetailsCreateOrConnectWithoutAsEventAttendeeInput | UserDetailsCreateOrConnectWithoutAsEventAttendeeInput[]
    connect?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserDetailsUpdateManyWithoutAsEventOrganizerNestedInput = {
    create?: XOR<UserDetailsCreateWithoutAsEventOrganizerInput, UserDetailsUncheckedCreateWithoutAsEventOrganizerInput> | UserDetailsCreateWithoutAsEventOrganizerInput[] | UserDetailsUncheckedCreateWithoutAsEventOrganizerInput[]
    connectOrCreate?: UserDetailsCreateOrConnectWithoutAsEventOrganizerInput | UserDetailsCreateOrConnectWithoutAsEventOrganizerInput[]
    upsert?: UserDetailsUpsertWithWhereUniqueWithoutAsEventOrganizerInput | UserDetailsUpsertWithWhereUniqueWithoutAsEventOrganizerInput[]
    set?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
    disconnect?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
    delete?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
    connect?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
    update?: UserDetailsUpdateWithWhereUniqueWithoutAsEventOrganizerInput | UserDetailsUpdateWithWhereUniqueWithoutAsEventOrganizerInput[]
    updateMany?: UserDetailsUpdateManyWithWhereWithoutAsEventOrganizerInput | UserDetailsUpdateManyWithWhereWithoutAsEventOrganizerInput[]
    deleteMany?: UserDetailsScalarWhereInput | UserDetailsScalarWhereInput[]
  }

  export type UserDetailsUpdateManyWithoutAsEventAttendeeNestedInput = {
    create?: XOR<UserDetailsCreateWithoutAsEventAttendeeInput, UserDetailsUncheckedCreateWithoutAsEventAttendeeInput> | UserDetailsCreateWithoutAsEventAttendeeInput[] | UserDetailsUncheckedCreateWithoutAsEventAttendeeInput[]
    connectOrCreate?: UserDetailsCreateOrConnectWithoutAsEventAttendeeInput | UserDetailsCreateOrConnectWithoutAsEventAttendeeInput[]
    upsert?: UserDetailsUpsertWithWhereUniqueWithoutAsEventAttendeeInput | UserDetailsUpsertWithWhereUniqueWithoutAsEventAttendeeInput[]
    set?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
    disconnect?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
    delete?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
    connect?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
    update?: UserDetailsUpdateWithWhereUniqueWithoutAsEventAttendeeInput | UserDetailsUpdateWithWhereUniqueWithoutAsEventAttendeeInput[]
    updateMany?: UserDetailsUpdateManyWithWhereWithoutAsEventAttendeeInput | UserDetailsUpdateManyWithWhereWithoutAsEventAttendeeInput[]
    deleteMany?: UserDetailsScalarWhereInput | UserDetailsScalarWhereInput[]
  }

  export type UserDetailsUncheckedUpdateManyWithoutAsEventOrganizerNestedInput = {
    create?: XOR<UserDetailsCreateWithoutAsEventOrganizerInput, UserDetailsUncheckedCreateWithoutAsEventOrganizerInput> | UserDetailsCreateWithoutAsEventOrganizerInput[] | UserDetailsUncheckedCreateWithoutAsEventOrganizerInput[]
    connectOrCreate?: UserDetailsCreateOrConnectWithoutAsEventOrganizerInput | UserDetailsCreateOrConnectWithoutAsEventOrganizerInput[]
    upsert?: UserDetailsUpsertWithWhereUniqueWithoutAsEventOrganizerInput | UserDetailsUpsertWithWhereUniqueWithoutAsEventOrganizerInput[]
    set?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
    disconnect?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
    delete?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
    connect?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
    update?: UserDetailsUpdateWithWhereUniqueWithoutAsEventOrganizerInput | UserDetailsUpdateWithWhereUniqueWithoutAsEventOrganizerInput[]
    updateMany?: UserDetailsUpdateManyWithWhereWithoutAsEventOrganizerInput | UserDetailsUpdateManyWithWhereWithoutAsEventOrganizerInput[]
    deleteMany?: UserDetailsScalarWhereInput | UserDetailsScalarWhereInput[]
  }

  export type UserDetailsUncheckedUpdateManyWithoutAsEventAttendeeNestedInput = {
    create?: XOR<UserDetailsCreateWithoutAsEventAttendeeInput, UserDetailsUncheckedCreateWithoutAsEventAttendeeInput> | UserDetailsCreateWithoutAsEventAttendeeInput[] | UserDetailsUncheckedCreateWithoutAsEventAttendeeInput[]
    connectOrCreate?: UserDetailsCreateOrConnectWithoutAsEventAttendeeInput | UserDetailsCreateOrConnectWithoutAsEventAttendeeInput[]
    upsert?: UserDetailsUpsertWithWhereUniqueWithoutAsEventAttendeeInput | UserDetailsUpsertWithWhereUniqueWithoutAsEventAttendeeInput[]
    set?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
    disconnect?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
    delete?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
    connect?: UserDetailsWhereUniqueInput | UserDetailsWhereUniqueInput[]
    update?: UserDetailsUpdateWithWhereUniqueWithoutAsEventAttendeeInput | UserDetailsUpdateWithWhereUniqueWithoutAsEventAttendeeInput[]
    updateMany?: UserDetailsUpdateManyWithWhereWithoutAsEventAttendeeInput | UserDetailsUpdateManyWithWhereWithoutAsEventAttendeeInput[]
    deleteMany?: UserDetailsScalarWhereInput | UserDetailsScalarWhereInput[]
  }

  export type UserDetailsCreateNestedOneWithoutCoffeeChatsSentInput = {
    create?: XOR<UserDetailsCreateWithoutCoffeeChatsSentInput, UserDetailsUncheckedCreateWithoutCoffeeChatsSentInput>
    connectOrCreate?: UserDetailsCreateOrConnectWithoutCoffeeChatsSentInput
    connect?: UserDetailsWhereUniqueInput
  }

  export type UserDetailsCreateNestedOneWithoutCoffeeChatsReceivedInput = {
    create?: XOR<UserDetailsCreateWithoutCoffeeChatsReceivedInput, UserDetailsUncheckedCreateWithoutCoffeeChatsReceivedInput>
    connectOrCreate?: UserDetailsCreateOrConnectWithoutCoffeeChatsReceivedInput
    connect?: UserDetailsWhereUniqueInput
  }

  export type CoffeeChatPurposeCreateNestedOneWithoutCoffeeChatsInput = {
    create?: XOR<CoffeeChatPurposeCreateWithoutCoffeeChatsInput, CoffeeChatPurposeUncheckedCreateWithoutCoffeeChatsInput>
    connectOrCreate?: CoffeeChatPurposeCreateOrConnectWithoutCoffeeChatsInput
    connect?: CoffeeChatPurposeWhereUniqueInput
  }

  export type CoffeeChatVenueCreateNestedOneWithoutCoffeeChatsInput = {
    create?: XOR<CoffeeChatVenueCreateWithoutCoffeeChatsInput, CoffeeChatVenueUncheckedCreateWithoutCoffeeChatsInput>
    connectOrCreate?: CoffeeChatVenueCreateOrConnectWithoutCoffeeChatsInput
    connect?: CoffeeChatVenueWhereUniqueInput
  }

  export type EnumCoffeeChatStatusFieldUpdateOperationsInput = {
    set?: $Enums.CoffeeChatStatus
  }

  export type UserDetailsUpdateOneRequiredWithoutCoffeeChatsSentNestedInput = {
    create?: XOR<UserDetailsCreateWithoutCoffeeChatsSentInput, UserDetailsUncheckedCreateWithoutCoffeeChatsSentInput>
    connectOrCreate?: UserDetailsCreateOrConnectWithoutCoffeeChatsSentInput
    upsert?: UserDetailsUpsertWithoutCoffeeChatsSentInput
    connect?: UserDetailsWhereUniqueInput
    update?: XOR<XOR<UserDetailsUpdateToOneWithWhereWithoutCoffeeChatsSentInput, UserDetailsUpdateWithoutCoffeeChatsSentInput>, UserDetailsUncheckedUpdateWithoutCoffeeChatsSentInput>
  }

  export type UserDetailsUpdateOneRequiredWithoutCoffeeChatsReceivedNestedInput = {
    create?: XOR<UserDetailsCreateWithoutCoffeeChatsReceivedInput, UserDetailsUncheckedCreateWithoutCoffeeChatsReceivedInput>
    connectOrCreate?: UserDetailsCreateOrConnectWithoutCoffeeChatsReceivedInput
    upsert?: UserDetailsUpsertWithoutCoffeeChatsReceivedInput
    connect?: UserDetailsWhereUniqueInput
    update?: XOR<XOR<UserDetailsUpdateToOneWithWhereWithoutCoffeeChatsReceivedInput, UserDetailsUpdateWithoutCoffeeChatsReceivedInput>, UserDetailsUncheckedUpdateWithoutCoffeeChatsReceivedInput>
  }

  export type CoffeeChatPurposeUpdateOneRequiredWithoutCoffeeChatsNestedInput = {
    create?: XOR<CoffeeChatPurposeCreateWithoutCoffeeChatsInput, CoffeeChatPurposeUncheckedCreateWithoutCoffeeChatsInput>
    connectOrCreate?: CoffeeChatPurposeCreateOrConnectWithoutCoffeeChatsInput
    upsert?: CoffeeChatPurposeUpsertWithoutCoffeeChatsInput
    connect?: CoffeeChatPurposeWhereUniqueInput
    update?: XOR<XOR<CoffeeChatPurposeUpdateToOneWithWhereWithoutCoffeeChatsInput, CoffeeChatPurposeUpdateWithoutCoffeeChatsInput>, CoffeeChatPurposeUncheckedUpdateWithoutCoffeeChatsInput>
  }

  export type CoffeeChatVenueUpdateOneRequiredWithoutCoffeeChatsNestedInput = {
    create?: XOR<CoffeeChatVenueCreateWithoutCoffeeChatsInput, CoffeeChatVenueUncheckedCreateWithoutCoffeeChatsInput>
    connectOrCreate?: CoffeeChatVenueCreateOrConnectWithoutCoffeeChatsInput
    upsert?: CoffeeChatVenueUpsertWithoutCoffeeChatsInput
    connect?: CoffeeChatVenueWhereUniqueInput
    update?: XOR<XOR<CoffeeChatVenueUpdateToOneWithWhereWithoutCoffeeChatsInput, CoffeeChatVenueUpdateWithoutCoffeeChatsInput>, CoffeeChatVenueUncheckedUpdateWithoutCoffeeChatsInput>
  }

  export type CoffeeChatCreateNestedManyWithoutPurposeInput = {
    create?: XOR<CoffeeChatCreateWithoutPurposeInput, CoffeeChatUncheckedCreateWithoutPurposeInput> | CoffeeChatCreateWithoutPurposeInput[] | CoffeeChatUncheckedCreateWithoutPurposeInput[]
    connectOrCreate?: CoffeeChatCreateOrConnectWithoutPurposeInput | CoffeeChatCreateOrConnectWithoutPurposeInput[]
    createMany?: CoffeeChatCreateManyPurposeInputEnvelope
    connect?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
  }

  export type CoffeeChatUncheckedCreateNestedManyWithoutPurposeInput = {
    create?: XOR<CoffeeChatCreateWithoutPurposeInput, CoffeeChatUncheckedCreateWithoutPurposeInput> | CoffeeChatCreateWithoutPurposeInput[] | CoffeeChatUncheckedCreateWithoutPurposeInput[]
    connectOrCreate?: CoffeeChatCreateOrConnectWithoutPurposeInput | CoffeeChatCreateOrConnectWithoutPurposeInput[]
    createMany?: CoffeeChatCreateManyPurposeInputEnvelope
    connect?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
  }

  export type CoffeeChatUpdateManyWithoutPurposeNestedInput = {
    create?: XOR<CoffeeChatCreateWithoutPurposeInput, CoffeeChatUncheckedCreateWithoutPurposeInput> | CoffeeChatCreateWithoutPurposeInput[] | CoffeeChatUncheckedCreateWithoutPurposeInput[]
    connectOrCreate?: CoffeeChatCreateOrConnectWithoutPurposeInput | CoffeeChatCreateOrConnectWithoutPurposeInput[]
    upsert?: CoffeeChatUpsertWithWhereUniqueWithoutPurposeInput | CoffeeChatUpsertWithWhereUniqueWithoutPurposeInput[]
    createMany?: CoffeeChatCreateManyPurposeInputEnvelope
    set?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    disconnect?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    delete?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    connect?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    update?: CoffeeChatUpdateWithWhereUniqueWithoutPurposeInput | CoffeeChatUpdateWithWhereUniqueWithoutPurposeInput[]
    updateMany?: CoffeeChatUpdateManyWithWhereWithoutPurposeInput | CoffeeChatUpdateManyWithWhereWithoutPurposeInput[]
    deleteMany?: CoffeeChatScalarWhereInput | CoffeeChatScalarWhereInput[]
  }

  export type CoffeeChatUncheckedUpdateManyWithoutPurposeNestedInput = {
    create?: XOR<CoffeeChatCreateWithoutPurposeInput, CoffeeChatUncheckedCreateWithoutPurposeInput> | CoffeeChatCreateWithoutPurposeInput[] | CoffeeChatUncheckedCreateWithoutPurposeInput[]
    connectOrCreate?: CoffeeChatCreateOrConnectWithoutPurposeInput | CoffeeChatCreateOrConnectWithoutPurposeInput[]
    upsert?: CoffeeChatUpsertWithWhereUniqueWithoutPurposeInput | CoffeeChatUpsertWithWhereUniqueWithoutPurposeInput[]
    createMany?: CoffeeChatCreateManyPurposeInputEnvelope
    set?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    disconnect?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    delete?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    connect?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    update?: CoffeeChatUpdateWithWhereUniqueWithoutPurposeInput | CoffeeChatUpdateWithWhereUniqueWithoutPurposeInput[]
    updateMany?: CoffeeChatUpdateManyWithWhereWithoutPurposeInput | CoffeeChatUpdateManyWithWhereWithoutPurposeInput[]
    deleteMany?: CoffeeChatScalarWhereInput | CoffeeChatScalarWhereInput[]
  }

  export type CoffeeChatVenueCreatetagsInput = {
    set: $Enums.CoffeeChatVenueTags[]
  }

  export type CoffeeChatCreateNestedManyWithoutVenueInput = {
    create?: XOR<CoffeeChatCreateWithoutVenueInput, CoffeeChatUncheckedCreateWithoutVenueInput> | CoffeeChatCreateWithoutVenueInput[] | CoffeeChatUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: CoffeeChatCreateOrConnectWithoutVenueInput | CoffeeChatCreateOrConnectWithoutVenueInput[]
    createMany?: CoffeeChatCreateManyVenueInputEnvelope
    connect?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
  }

  export type CoffeeChatUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<CoffeeChatCreateWithoutVenueInput, CoffeeChatUncheckedCreateWithoutVenueInput> | CoffeeChatCreateWithoutVenueInput[] | CoffeeChatUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: CoffeeChatCreateOrConnectWithoutVenueInput | CoffeeChatCreateOrConnectWithoutVenueInput[]
    createMany?: CoffeeChatCreateManyVenueInputEnvelope
    connect?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
  }

  export type EnumCoffeeChatVenueNoiseLevelFieldUpdateOperationsInput = {
    set?: $Enums.CoffeeChatVenueNoiseLevel
  }

  export type CoffeeChatVenueUpdatetagsInput = {
    set?: $Enums.CoffeeChatVenueTags[]
    push?: $Enums.CoffeeChatVenueTags | $Enums.CoffeeChatVenueTags[]
  }

  export type CoffeeChatUpdateManyWithoutVenueNestedInput = {
    create?: XOR<CoffeeChatCreateWithoutVenueInput, CoffeeChatUncheckedCreateWithoutVenueInput> | CoffeeChatCreateWithoutVenueInput[] | CoffeeChatUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: CoffeeChatCreateOrConnectWithoutVenueInput | CoffeeChatCreateOrConnectWithoutVenueInput[]
    upsert?: CoffeeChatUpsertWithWhereUniqueWithoutVenueInput | CoffeeChatUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: CoffeeChatCreateManyVenueInputEnvelope
    set?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    disconnect?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    delete?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    connect?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    update?: CoffeeChatUpdateWithWhereUniqueWithoutVenueInput | CoffeeChatUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: CoffeeChatUpdateManyWithWhereWithoutVenueInput | CoffeeChatUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: CoffeeChatScalarWhereInput | CoffeeChatScalarWhereInput[]
  }

  export type CoffeeChatUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<CoffeeChatCreateWithoutVenueInput, CoffeeChatUncheckedCreateWithoutVenueInput> | CoffeeChatCreateWithoutVenueInput[] | CoffeeChatUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: CoffeeChatCreateOrConnectWithoutVenueInput | CoffeeChatCreateOrConnectWithoutVenueInput[]
    upsert?: CoffeeChatUpsertWithWhereUniqueWithoutVenueInput | CoffeeChatUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: CoffeeChatCreateManyVenueInputEnvelope
    set?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    disconnect?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    delete?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    connect?: CoffeeChatWhereUniqueInput | CoffeeChatWhereUniqueInput[]
    update?: CoffeeChatUpdateWithWhereUniqueWithoutVenueInput | CoffeeChatUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: CoffeeChatUpdateManyWithWhereWithoutVenueInput | CoffeeChatUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: CoffeeChatScalarWhereInput | CoffeeChatScalarWhereInput[]
  }

  export type UserDetailsCreateNestedOneWithoutChatsAsUser1Input = {
    create?: XOR<UserDetailsCreateWithoutChatsAsUser1Input, UserDetailsUncheckedCreateWithoutChatsAsUser1Input>
    connectOrCreate?: UserDetailsCreateOrConnectWithoutChatsAsUser1Input
    connect?: UserDetailsWhereUniqueInput
  }

  export type UserDetailsCreateNestedOneWithoutChatsAsUser2Input = {
    create?: XOR<UserDetailsCreateWithoutChatsAsUser2Input, UserDetailsUncheckedCreateWithoutChatsAsUser2Input>
    connectOrCreate?: UserDetailsCreateOrConnectWithoutChatsAsUser2Input
    connect?: UserDetailsWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutChatInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutChatInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type UserDetailsUpdateOneRequiredWithoutChatsAsUser1NestedInput = {
    create?: XOR<UserDetailsCreateWithoutChatsAsUser1Input, UserDetailsUncheckedCreateWithoutChatsAsUser1Input>
    connectOrCreate?: UserDetailsCreateOrConnectWithoutChatsAsUser1Input
    upsert?: UserDetailsUpsertWithoutChatsAsUser1Input
    connect?: UserDetailsWhereUniqueInput
    update?: XOR<XOR<UserDetailsUpdateToOneWithWhereWithoutChatsAsUser1Input, UserDetailsUpdateWithoutChatsAsUser1Input>, UserDetailsUncheckedUpdateWithoutChatsAsUser1Input>
  }

  export type UserDetailsUpdateOneRequiredWithoutChatsAsUser2NestedInput = {
    create?: XOR<UserDetailsCreateWithoutChatsAsUser2Input, UserDetailsUncheckedCreateWithoutChatsAsUser2Input>
    connectOrCreate?: UserDetailsCreateOrConnectWithoutChatsAsUser2Input
    upsert?: UserDetailsUpsertWithoutChatsAsUser2Input
    connect?: UserDetailsWhereUniqueInput
    update?: XOR<XOR<UserDetailsUpdateToOneWithWhereWithoutChatsAsUser2Input, UserDetailsUpdateWithoutChatsAsUser2Input>, UserDetailsUncheckedUpdateWithoutChatsAsUser2Input>
  }

  export type MessageUpdateManyWithoutChatNestedInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutChatInput | MessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutChatInput | MessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutChatInput | MessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutChatNestedInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutChatInput | MessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutChatInput | MessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutChatInput | MessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ChatCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    connect?: ChatWhereUniqueInput
  }

  export type UserDetailsCreateNestedOneWithoutMessagesSentInput = {
    create?: XOR<UserDetailsCreateWithoutMessagesSentInput, UserDetailsUncheckedCreateWithoutMessagesSentInput>
    connectOrCreate?: UserDetailsCreateOrConnectWithoutMessagesSentInput
    connect?: UserDetailsWhereUniqueInput
  }

  export type ChatUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    upsert?: ChatUpsertWithoutMessagesInput
    connect?: ChatWhereUniqueInput
    update?: XOR<XOR<ChatUpdateToOneWithWhereWithoutMessagesInput, ChatUpdateWithoutMessagesInput>, ChatUncheckedUpdateWithoutMessagesInput>
  }

  export type UserDetailsUpdateOneRequiredWithoutMessagesSentNestedInput = {
    create?: XOR<UserDetailsCreateWithoutMessagesSentInput, UserDetailsUncheckedCreateWithoutMessagesSentInput>
    connectOrCreate?: UserDetailsCreateOrConnectWithoutMessagesSentInput
    upsert?: UserDetailsUpsertWithoutMessagesSentInput
    connect?: UserDetailsWhereUniqueInput
    update?: XOR<XOR<UserDetailsUpdateToOneWithWhereWithoutMessagesSentInput, UserDetailsUpdateWithoutMessagesSentInput>, UserDetailsUncheckedUpdateWithoutMessagesSentInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumMatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusFilter<$PrismaModel> | $Enums.MatchStatus
  }

  export type NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.MatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchStatusFilter<$PrismaModel>
    _max?: NestedEnumMatchStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumCoffeeChatStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CoffeeChatStatus | EnumCoffeeChatStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CoffeeChatStatus[] | ListEnumCoffeeChatStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CoffeeChatStatus[] | ListEnumCoffeeChatStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCoffeeChatStatusFilter<$PrismaModel> | $Enums.CoffeeChatStatus
  }

  export type NestedEnumCoffeeChatStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CoffeeChatStatus | EnumCoffeeChatStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CoffeeChatStatus[] | ListEnumCoffeeChatStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CoffeeChatStatus[] | ListEnumCoffeeChatStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCoffeeChatStatusWithAggregatesFilter<$PrismaModel> | $Enums.CoffeeChatStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCoffeeChatStatusFilter<$PrismaModel>
    _max?: NestedEnumCoffeeChatStatusFilter<$PrismaModel>
  }

  export type NestedEnumCoffeeChatVenueNoiseLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.CoffeeChatVenueNoiseLevel | EnumCoffeeChatVenueNoiseLevelFieldRefInput<$PrismaModel>
    in?: $Enums.CoffeeChatVenueNoiseLevel[] | ListEnumCoffeeChatVenueNoiseLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CoffeeChatVenueNoiseLevel[] | ListEnumCoffeeChatVenueNoiseLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumCoffeeChatVenueNoiseLevelFilter<$PrismaModel> | $Enums.CoffeeChatVenueNoiseLevel
  }

  export type NestedEnumCoffeeChatVenueNoiseLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CoffeeChatVenueNoiseLevel | EnumCoffeeChatVenueNoiseLevelFieldRefInput<$PrismaModel>
    in?: $Enums.CoffeeChatVenueNoiseLevel[] | ListEnumCoffeeChatVenueNoiseLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CoffeeChatVenueNoiseLevel[] | ListEnumCoffeeChatVenueNoiseLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumCoffeeChatVenueNoiseLevelWithAggregatesFilter<$PrismaModel> | $Enums.CoffeeChatVenueNoiseLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCoffeeChatVenueNoiseLevelFilter<$PrismaModel>
    _max?: NestedEnumCoffeeChatVenueNoiseLevelFilter<$PrismaModel>
  }

  export type UserDetailsCreateWithoutUserInput = {
    id?: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserDetailsInput
    interests?: InterestCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatCreateNestedManyWithoutUser2Input
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserDetailsInput
    interests?: InterestUncheckedCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchUncheckedCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchUncheckedCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventUncheckedCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventUncheckedCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatUncheckedCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatUncheckedCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsCreateOrConnectWithoutUserInput = {
    where: UserDetailsWhereUniqueInput
    create: XOR<UserDetailsCreateWithoutUserInput, UserDetailsUncheckedCreateWithoutUserInput>
  }

  export type UserDetailsUpsertWithoutUserInput = {
    update: XOR<UserDetailsUpdateWithoutUserInput, UserDetailsUncheckedUpdateWithoutUserInput>
    create: XOR<UserDetailsCreateWithoutUserInput, UserDetailsUncheckedCreateWithoutUserInput>
    where?: UserDetailsWhereInput
  }

  export type UserDetailsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserDetailsWhereInput
    data: XOR<UserDetailsUpdateWithoutUserInput, UserDetailsUncheckedUpdateWithoutUserInput>
  }

  export type UserDetailsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
  }

  export type UserDetailsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUncheckedUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUncheckedUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUncheckedUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUncheckedUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUncheckedUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUncheckedUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUncheckedUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateWithoutUserDetailsInput = {
    id?: string
    email: string
    username?: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutUserDetailsInput = {
    id?: string
    email: string
    username?: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutUserDetailsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserDetailsInput, UserUncheckedCreateWithoutUserDetailsInput>
  }

  export type PostCreateWithoutAuthorInput = {
    id?: string
    content: string
    commentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reaction?: ReactionCreateNestedOneWithoutPostInput
    postTags?: PostTagCreateNestedManyWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutAuthorInput = {
    id?: string
    content: string
    commentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reaction?: ReactionUncheckedCreateNestedOneWithoutPostInput
    postTags?: PostTagUncheckedCreateNestedManyWithoutPostsInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutAuthorInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostCreateManyAuthorInputEnvelope = {
    data: PostCreateManyAuthorInput | PostCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutAuthorInput = {
    id?: string
    commentContent: string
    createdAt?: Date | string
    updatedAt?: Date | string
    post: PostCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutAuthorInput = {
    id?: string
    postId: string
    commentContent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentCreateManyAuthorInputEnvelope = {
    data: CommentCreateManyAuthorInput | CommentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserDetailsInput = {
    id?: string
    notificationType: $Enums.NotificationType
    notificationData: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserDetailsInput = {
    id?: string
    notificationType: $Enums.NotificationType
    notificationData: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserDetailsInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserDetailsInput, NotificationUncheckedCreateWithoutUserDetailsInput>
  }

  export type NotificationCreateManyUserDetailsInputEnvelope = {
    data: NotificationCreateManyUserDetailsInput | NotificationCreateManyUserDetailsInput[]
    skipDuplicates?: boolean
  }

  export type InterestCreateWithoutUserDetailsInput = {
    id?: string
    interestName: string
  }

  export type InterestUncheckedCreateWithoutUserDetailsInput = {
    id?: string
    interestName: string
  }

  export type InterestCreateOrConnectWithoutUserDetailsInput = {
    where: InterestWhereUniqueInput
    create: XOR<InterestCreateWithoutUserDetailsInput, InterestUncheckedCreateWithoutUserDetailsInput>
  }

  export type MatchCreateWithoutInviterInput = {
    id?: string
    matchScore: number
    matchStatus?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    invitee: UserDetailsCreateNestedOneWithoutMatchesReceivedInput
  }

  export type MatchUncheckedCreateWithoutInviterInput = {
    id?: string
    inviteeId: string
    matchScore: number
    matchStatus?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchCreateOrConnectWithoutInviterInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutInviterInput, MatchUncheckedCreateWithoutInviterInput>
  }

  export type MatchCreateManyInviterInputEnvelope = {
    data: MatchCreateManyInviterInput | MatchCreateManyInviterInput[]
    skipDuplicates?: boolean
  }

  export type MatchCreateWithoutInviteeInput = {
    id?: string
    matchScore: number
    matchStatus?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    inviter: UserDetailsCreateNestedOneWithoutMatchesSentInput
  }

  export type MatchUncheckedCreateWithoutInviteeInput = {
    id?: string
    inviterId: string
    matchScore: number
    matchStatus?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchCreateOrConnectWithoutInviteeInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutInviteeInput, MatchUncheckedCreateWithoutInviteeInput>
  }

  export type MatchCreateManyInviteeInputEnvelope = {
    data: MatchCreateManyInviteeInput | MatchCreateManyInviteeInput[]
    skipDuplicates?: boolean
  }

  export type UserSimilarityCreateWithoutCurrentUserInput = {
    id?: string
    similarityScore: number
    factors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    otherUser: UserDetailsCreateNestedOneWithoutOtherUserSimilarityInput
  }

  export type UserSimilarityUncheckedCreateWithoutCurrentUserInput = {
    id?: string
    otherUserId: string
    similarityScore: number
    factors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UserSimilarityCreateOrConnectWithoutCurrentUserInput = {
    where: UserSimilarityWhereUniqueInput
    create: XOR<UserSimilarityCreateWithoutCurrentUserInput, UserSimilarityUncheckedCreateWithoutCurrentUserInput>
  }

  export type UserSimilarityCreateManyCurrentUserInputEnvelope = {
    data: UserSimilarityCreateManyCurrentUserInput | UserSimilarityCreateManyCurrentUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSimilarityCreateWithoutOtherUserInput = {
    id?: string
    similarityScore: number
    factors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    currentUser: UserDetailsCreateNestedOneWithoutCurrentUserSimilarityInput
  }

  export type UserSimilarityUncheckedCreateWithoutOtherUserInput = {
    id?: string
    currentUserId: string
    similarityScore: number
    factors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UserSimilarityCreateOrConnectWithoutOtherUserInput = {
    where: UserSimilarityWhereUniqueInput
    create: XOR<UserSimilarityCreateWithoutOtherUserInput, UserSimilarityUncheckedCreateWithoutOtherUserInput>
  }

  export type UserSimilarityCreateManyOtherUserInputEnvelope = {
    data: UserSimilarityCreateManyOtherUserInput | UserSimilarityCreateManyOtherUserInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutAttendeesInput = {
    id?: string
    title: string
    description: string
    location?: string | null
    date: Date | string
    time?: Date | string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizers?: UserDetailsCreateNestedManyWithoutAsEventOrganizerInput
  }

  export type EventUncheckedCreateWithoutAttendeesInput = {
    id?: string
    title: string
    description: string
    location?: string | null
    date: Date | string
    time?: Date | string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizers?: UserDetailsUncheckedCreateNestedManyWithoutAsEventOrganizerInput
  }

  export type EventCreateOrConnectWithoutAttendeesInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutAttendeesInput, EventUncheckedCreateWithoutAttendeesInput>
  }

  export type EventCreateWithoutOrganizersInput = {
    id?: string
    title: string
    description: string
    location?: string | null
    date: Date | string
    time?: Date | string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendees?: UserDetailsCreateNestedManyWithoutAsEventAttendeeInput
  }

  export type EventUncheckedCreateWithoutOrganizersInput = {
    id?: string
    title: string
    description: string
    location?: string | null
    date: Date | string
    time?: Date | string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendees?: UserDetailsUncheckedCreateNestedManyWithoutAsEventAttendeeInput
  }

  export type EventCreateOrConnectWithoutOrganizersInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutOrganizersInput, EventUncheckedCreateWithoutOrganizersInput>
  }

  export type CoffeeChatCreateWithoutInviterInput = {
    id?: string
    scheduledAt?: Date | string | null
    duration: number
    personalMessage?: string | null
    status?: $Enums.CoffeeChatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    invitee: UserDetailsCreateNestedOneWithoutCoffeeChatsReceivedInput
    purpose: CoffeeChatPurposeCreateNestedOneWithoutCoffeeChatsInput
    venue: CoffeeChatVenueCreateNestedOneWithoutCoffeeChatsInput
  }

  export type CoffeeChatUncheckedCreateWithoutInviterInput = {
    id?: string
    inviteeId: string
    purposeId: string
    venueId: string
    scheduledAt?: Date | string | null
    duration: number
    personalMessage?: string | null
    status?: $Enums.CoffeeChatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoffeeChatCreateOrConnectWithoutInviterInput = {
    where: CoffeeChatWhereUniqueInput
    create: XOR<CoffeeChatCreateWithoutInviterInput, CoffeeChatUncheckedCreateWithoutInviterInput>
  }

  export type CoffeeChatCreateManyInviterInputEnvelope = {
    data: CoffeeChatCreateManyInviterInput | CoffeeChatCreateManyInviterInput[]
    skipDuplicates?: boolean
  }

  export type CoffeeChatCreateWithoutInviteeInput = {
    id?: string
    scheduledAt?: Date | string | null
    duration: number
    personalMessage?: string | null
    status?: $Enums.CoffeeChatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    inviter: UserDetailsCreateNestedOneWithoutCoffeeChatsSentInput
    purpose: CoffeeChatPurposeCreateNestedOneWithoutCoffeeChatsInput
    venue: CoffeeChatVenueCreateNestedOneWithoutCoffeeChatsInput
  }

  export type CoffeeChatUncheckedCreateWithoutInviteeInput = {
    id?: string
    inviterId: string
    purposeId: string
    venueId: string
    scheduledAt?: Date | string | null
    duration: number
    personalMessage?: string | null
    status?: $Enums.CoffeeChatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoffeeChatCreateOrConnectWithoutInviteeInput = {
    where: CoffeeChatWhereUniqueInput
    create: XOR<CoffeeChatCreateWithoutInviteeInput, CoffeeChatUncheckedCreateWithoutInviteeInput>
  }

  export type CoffeeChatCreateManyInviteeInputEnvelope = {
    data: CoffeeChatCreateManyInviteeInput | CoffeeChatCreateManyInviteeInput[]
    skipDuplicates?: boolean
  }

  export type ChatCreateWithoutUser1Input = {
    id?: string
    name?: string | null
    user2: UserDetailsCreateNestedOneWithoutChatsAsUser2Input
    messages?: MessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutUser1Input = {
    id?: string
    user2Id: string
    name?: string | null
    messages?: MessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutUser1Input = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutUser1Input, ChatUncheckedCreateWithoutUser1Input>
  }

  export type ChatCreateManyUser1InputEnvelope = {
    data: ChatCreateManyUser1Input | ChatCreateManyUser1Input[]
    skipDuplicates?: boolean
  }

  export type ChatCreateWithoutUser2Input = {
    id?: string
    name?: string | null
    user1: UserDetailsCreateNestedOneWithoutChatsAsUser1Input
    messages?: MessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutUser2Input = {
    id?: string
    user1Id: string
    name?: string | null
    messages?: MessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutUser2Input = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutUser2Input, ChatUncheckedCreateWithoutUser2Input>
  }

  export type ChatCreateManyUser2InputEnvelope = {
    data: ChatCreateManyUser2Input | ChatCreateManyUser2Input[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    content: string
    createdAt?: Date | string
    chat: ChatCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    chatId: string
    content: string
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutUserDetailsInput = {
    update: XOR<UserUpdateWithoutUserDetailsInput, UserUncheckedUpdateWithoutUserDetailsInput>
    create: XOR<UserCreateWithoutUserDetailsInput, UserUncheckedCreateWithoutUserDetailsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserDetailsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserDetailsInput, UserUncheckedUpdateWithoutUserDetailsInput>
  }

  export type UserUpdateWithoutUserDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutUserDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
  }

  export type PostUpdateManyWithWhereWithoutAuthorInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: StringFilter<"Post"> | string
    authorId?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    commentCount?: IntFilter<"Post"> | number
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
  }

  export type CommentUpdateManyWithWhereWithoutAuthorInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    commentContent?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserDetailsInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserDetailsInput, NotificationUncheckedUpdateWithoutUserDetailsInput>
    create: XOR<NotificationCreateWithoutUserDetailsInput, NotificationUncheckedCreateWithoutUserDetailsInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserDetailsInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserDetailsInput, NotificationUncheckedUpdateWithoutUserDetailsInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserDetailsInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserDetailsInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userDetailsId?: StringFilter<"Notification"> | string
    notificationType?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    notificationData?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type InterestUpsertWithWhereUniqueWithoutUserDetailsInput = {
    where: InterestWhereUniqueInput
    update: XOR<InterestUpdateWithoutUserDetailsInput, InterestUncheckedUpdateWithoutUserDetailsInput>
    create: XOR<InterestCreateWithoutUserDetailsInput, InterestUncheckedCreateWithoutUserDetailsInput>
  }

  export type InterestUpdateWithWhereUniqueWithoutUserDetailsInput = {
    where: InterestWhereUniqueInput
    data: XOR<InterestUpdateWithoutUserDetailsInput, InterestUncheckedUpdateWithoutUserDetailsInput>
  }

  export type InterestUpdateManyWithWhereWithoutUserDetailsInput = {
    where: InterestScalarWhereInput
    data: XOR<InterestUpdateManyMutationInput, InterestUncheckedUpdateManyWithoutUserDetailsInput>
  }

  export type InterestScalarWhereInput = {
    AND?: InterestScalarWhereInput | InterestScalarWhereInput[]
    OR?: InterestScalarWhereInput[]
    NOT?: InterestScalarWhereInput | InterestScalarWhereInput[]
    id?: StringFilter<"Interest"> | string
    interestName?: StringFilter<"Interest"> | string
  }

  export type MatchUpsertWithWhereUniqueWithoutInviterInput = {
    where: MatchWhereUniqueInput
    update: XOR<MatchUpdateWithoutInviterInput, MatchUncheckedUpdateWithoutInviterInput>
    create: XOR<MatchCreateWithoutInviterInput, MatchUncheckedCreateWithoutInviterInput>
  }

  export type MatchUpdateWithWhereUniqueWithoutInviterInput = {
    where: MatchWhereUniqueInput
    data: XOR<MatchUpdateWithoutInviterInput, MatchUncheckedUpdateWithoutInviterInput>
  }

  export type MatchUpdateManyWithWhereWithoutInviterInput = {
    where: MatchScalarWhereInput
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyWithoutInviterInput>
  }

  export type MatchScalarWhereInput = {
    AND?: MatchScalarWhereInput | MatchScalarWhereInput[]
    OR?: MatchScalarWhereInput[]
    NOT?: MatchScalarWhereInput | MatchScalarWhereInput[]
    id?: StringFilter<"Match"> | string
    inviterId?: StringFilter<"Match"> | string
    inviteeId?: StringFilter<"Match"> | string
    matchScore?: IntFilter<"Match"> | number
    matchStatus?: EnumMatchStatusFilter<"Match"> | $Enums.MatchStatus
    createdAt?: DateTimeFilter<"Match"> | Date | string
    updatedAt?: DateTimeFilter<"Match"> | Date | string
  }

  export type MatchUpsertWithWhereUniqueWithoutInviteeInput = {
    where: MatchWhereUniqueInput
    update: XOR<MatchUpdateWithoutInviteeInput, MatchUncheckedUpdateWithoutInviteeInput>
    create: XOR<MatchCreateWithoutInviteeInput, MatchUncheckedCreateWithoutInviteeInput>
  }

  export type MatchUpdateWithWhereUniqueWithoutInviteeInput = {
    where: MatchWhereUniqueInput
    data: XOR<MatchUpdateWithoutInviteeInput, MatchUncheckedUpdateWithoutInviteeInput>
  }

  export type MatchUpdateManyWithWhereWithoutInviteeInput = {
    where: MatchScalarWhereInput
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyWithoutInviteeInput>
  }

  export type UserSimilarityUpsertWithWhereUniqueWithoutCurrentUserInput = {
    where: UserSimilarityWhereUniqueInput
    update: XOR<UserSimilarityUpdateWithoutCurrentUserInput, UserSimilarityUncheckedUpdateWithoutCurrentUserInput>
    create: XOR<UserSimilarityCreateWithoutCurrentUserInput, UserSimilarityUncheckedCreateWithoutCurrentUserInput>
  }

  export type UserSimilarityUpdateWithWhereUniqueWithoutCurrentUserInput = {
    where: UserSimilarityWhereUniqueInput
    data: XOR<UserSimilarityUpdateWithoutCurrentUserInput, UserSimilarityUncheckedUpdateWithoutCurrentUserInput>
  }

  export type UserSimilarityUpdateManyWithWhereWithoutCurrentUserInput = {
    where: UserSimilarityScalarWhereInput
    data: XOR<UserSimilarityUpdateManyMutationInput, UserSimilarityUncheckedUpdateManyWithoutCurrentUserInput>
  }

  export type UserSimilarityScalarWhereInput = {
    AND?: UserSimilarityScalarWhereInput | UserSimilarityScalarWhereInput[]
    OR?: UserSimilarityScalarWhereInput[]
    NOT?: UserSimilarityScalarWhereInput | UserSimilarityScalarWhereInput[]
    id?: StringFilter<"UserSimilarity"> | string
    currentUserId?: StringFilter<"UserSimilarity"> | string
    otherUserId?: StringFilter<"UserSimilarity"> | string
    similarityScore?: IntFilter<"UserSimilarity"> | number
    factors?: JsonNullableFilter<"UserSimilarity">
    createdAt?: DateTimeFilter<"UserSimilarity"> | Date | string
  }

  export type UserSimilarityUpsertWithWhereUniqueWithoutOtherUserInput = {
    where: UserSimilarityWhereUniqueInput
    update: XOR<UserSimilarityUpdateWithoutOtherUserInput, UserSimilarityUncheckedUpdateWithoutOtherUserInput>
    create: XOR<UserSimilarityCreateWithoutOtherUserInput, UserSimilarityUncheckedCreateWithoutOtherUserInput>
  }

  export type UserSimilarityUpdateWithWhereUniqueWithoutOtherUserInput = {
    where: UserSimilarityWhereUniqueInput
    data: XOR<UserSimilarityUpdateWithoutOtherUserInput, UserSimilarityUncheckedUpdateWithoutOtherUserInput>
  }

  export type UserSimilarityUpdateManyWithWhereWithoutOtherUserInput = {
    where: UserSimilarityScalarWhereInput
    data: XOR<UserSimilarityUpdateManyMutationInput, UserSimilarityUncheckedUpdateManyWithoutOtherUserInput>
  }

  export type EventUpsertWithWhereUniqueWithoutAttendeesInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutAttendeesInput, EventUncheckedUpdateWithoutAttendeesInput>
    create: XOR<EventCreateWithoutAttendeesInput, EventUncheckedCreateWithoutAttendeesInput>
  }

  export type EventUpdateWithWhereUniqueWithoutAttendeesInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutAttendeesInput, EventUncheckedUpdateWithoutAttendeesInput>
  }

  export type EventUpdateManyWithWhereWithoutAttendeesInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutAttendeesInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringFilter<"Event"> | string
    location?: StringNullableFilter<"Event"> | string | null
    date?: DateTimeFilter<"Event"> | Date | string
    time?: DateTimeNullableFilter<"Event"> | Date | string | null
    category?: StringNullableFilter<"Event"> | string | null
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
  }

  export type EventUpsertWithWhereUniqueWithoutOrganizersInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutOrganizersInput, EventUncheckedUpdateWithoutOrganizersInput>
    create: XOR<EventCreateWithoutOrganizersInput, EventUncheckedCreateWithoutOrganizersInput>
  }

  export type EventUpdateWithWhereUniqueWithoutOrganizersInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutOrganizersInput, EventUncheckedUpdateWithoutOrganizersInput>
  }

  export type EventUpdateManyWithWhereWithoutOrganizersInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutOrganizersInput>
  }

  export type CoffeeChatUpsertWithWhereUniqueWithoutInviterInput = {
    where: CoffeeChatWhereUniqueInput
    update: XOR<CoffeeChatUpdateWithoutInviterInput, CoffeeChatUncheckedUpdateWithoutInviterInput>
    create: XOR<CoffeeChatCreateWithoutInviterInput, CoffeeChatUncheckedCreateWithoutInviterInput>
  }

  export type CoffeeChatUpdateWithWhereUniqueWithoutInviterInput = {
    where: CoffeeChatWhereUniqueInput
    data: XOR<CoffeeChatUpdateWithoutInviterInput, CoffeeChatUncheckedUpdateWithoutInviterInput>
  }

  export type CoffeeChatUpdateManyWithWhereWithoutInviterInput = {
    where: CoffeeChatScalarWhereInput
    data: XOR<CoffeeChatUpdateManyMutationInput, CoffeeChatUncheckedUpdateManyWithoutInviterInput>
  }

  export type CoffeeChatScalarWhereInput = {
    AND?: CoffeeChatScalarWhereInput | CoffeeChatScalarWhereInput[]
    OR?: CoffeeChatScalarWhereInput[]
    NOT?: CoffeeChatScalarWhereInput | CoffeeChatScalarWhereInput[]
    id?: StringFilter<"CoffeeChat"> | string
    inviterId?: StringFilter<"CoffeeChat"> | string
    inviteeId?: StringFilter<"CoffeeChat"> | string
    purposeId?: StringFilter<"CoffeeChat"> | string
    venueId?: StringFilter<"CoffeeChat"> | string
    scheduledAt?: DateTimeNullableFilter<"CoffeeChat"> | Date | string | null
    duration?: IntFilter<"CoffeeChat"> | number
    personalMessage?: StringNullableFilter<"CoffeeChat"> | string | null
    status?: EnumCoffeeChatStatusFilter<"CoffeeChat"> | $Enums.CoffeeChatStatus
    createdAt?: DateTimeFilter<"CoffeeChat"> | Date | string
    updatedAt?: DateTimeFilter<"CoffeeChat"> | Date | string
  }

  export type CoffeeChatUpsertWithWhereUniqueWithoutInviteeInput = {
    where: CoffeeChatWhereUniqueInput
    update: XOR<CoffeeChatUpdateWithoutInviteeInput, CoffeeChatUncheckedUpdateWithoutInviteeInput>
    create: XOR<CoffeeChatCreateWithoutInviteeInput, CoffeeChatUncheckedCreateWithoutInviteeInput>
  }

  export type CoffeeChatUpdateWithWhereUniqueWithoutInviteeInput = {
    where: CoffeeChatWhereUniqueInput
    data: XOR<CoffeeChatUpdateWithoutInviteeInput, CoffeeChatUncheckedUpdateWithoutInviteeInput>
  }

  export type CoffeeChatUpdateManyWithWhereWithoutInviteeInput = {
    where: CoffeeChatScalarWhereInput
    data: XOR<CoffeeChatUpdateManyMutationInput, CoffeeChatUncheckedUpdateManyWithoutInviteeInput>
  }

  export type ChatUpsertWithWhereUniqueWithoutUser1Input = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutUser1Input, ChatUncheckedUpdateWithoutUser1Input>
    create: XOR<ChatCreateWithoutUser1Input, ChatUncheckedCreateWithoutUser1Input>
  }

  export type ChatUpdateWithWhereUniqueWithoutUser1Input = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutUser1Input, ChatUncheckedUpdateWithoutUser1Input>
  }

  export type ChatUpdateManyWithWhereWithoutUser1Input = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutUser1Input>
  }

  export type ChatScalarWhereInput = {
    AND?: ChatScalarWhereInput | ChatScalarWhereInput[]
    OR?: ChatScalarWhereInput[]
    NOT?: ChatScalarWhereInput | ChatScalarWhereInput[]
    id?: StringFilter<"Chat"> | string
    user1Id?: StringFilter<"Chat"> | string
    user2Id?: StringFilter<"Chat"> | string
    name?: StringNullableFilter<"Chat"> | string | null
  }

  export type ChatUpsertWithWhereUniqueWithoutUser2Input = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutUser2Input, ChatUncheckedUpdateWithoutUser2Input>
    create: XOR<ChatCreateWithoutUser2Input, ChatUncheckedCreateWithoutUser2Input>
  }

  export type ChatUpdateWithWhereUniqueWithoutUser2Input = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutUser2Input, ChatUncheckedUpdateWithoutUser2Input>
  }

  export type ChatUpdateManyWithWhereWithoutUser2Input = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutUser2Input>
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    chatId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type UserDetailsCreateWithoutPostsInput = {
    id?: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    user: UserCreateNestedOneWithoutUserDetailsInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserDetailsInput
    interests?: InterestCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatCreateNestedManyWithoutUser2Input
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsUncheckedCreateWithoutPostsInput = {
    id?: string
    userId: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserDetailsInput
    interests?: InterestUncheckedCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchUncheckedCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchUncheckedCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventUncheckedCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventUncheckedCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatUncheckedCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatUncheckedCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsCreateOrConnectWithoutPostsInput = {
    where: UserDetailsWhereUniqueInput
    create: XOR<UserDetailsCreateWithoutPostsInput, UserDetailsUncheckedCreateWithoutPostsInput>
  }

  export type ReactionCreateWithoutPostInput = {
    id?: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReactionUncheckedCreateWithoutPostInput = {
    id?: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReactionCreateOrConnectWithoutPostInput = {
    where: ReactionWhereUniqueInput
    create: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput>
  }

  export type PostTagCreateWithoutPostsInput = {
    id?: string
    tagName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostTagUncheckedCreateWithoutPostsInput = {
    id?: string
    tagName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostTagCreateOrConnectWithoutPostsInput = {
    where: PostTagWhereUniqueInput
    create: XOR<PostTagCreateWithoutPostsInput, PostTagUncheckedCreateWithoutPostsInput>
  }

  export type CommentCreateWithoutPostInput = {
    id?: string
    commentContent: string
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserDetailsCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutPostInput = {
    id?: string
    authorId: string
    commentContent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentCreateManyPostInputEnvelope = {
    data: CommentCreateManyPostInput | CommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type UserDetailsUpsertWithoutPostsInput = {
    update: XOR<UserDetailsUpdateWithoutPostsInput, UserDetailsUncheckedUpdateWithoutPostsInput>
    create: XOR<UserDetailsCreateWithoutPostsInput, UserDetailsUncheckedCreateWithoutPostsInput>
    where?: UserDetailsWhereInput
  }

  export type UserDetailsUpdateToOneWithWhereWithoutPostsInput = {
    where?: UserDetailsWhereInput
    data: XOR<UserDetailsUpdateWithoutPostsInput, UserDetailsUncheckedUpdateWithoutPostsInput>
  }

  export type UserDetailsUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserDetailsNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
  }

  export type UserDetailsUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUncheckedUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUncheckedUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUncheckedUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUncheckedUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUncheckedUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUncheckedUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUncheckedUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type ReactionUpsertWithoutPostInput = {
    update: XOR<ReactionUpdateWithoutPostInput, ReactionUncheckedUpdateWithoutPostInput>
    create: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput>
    where?: ReactionWhereInput
  }

  export type ReactionUpdateToOneWithWhereWithoutPostInput = {
    where?: ReactionWhereInput
    data: XOR<ReactionUpdateWithoutPostInput, ReactionUncheckedUpdateWithoutPostInput>
  }

  export type ReactionUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostTagUpsertWithWhereUniqueWithoutPostsInput = {
    where: PostTagWhereUniqueInput
    update: XOR<PostTagUpdateWithoutPostsInput, PostTagUncheckedUpdateWithoutPostsInput>
    create: XOR<PostTagCreateWithoutPostsInput, PostTagUncheckedCreateWithoutPostsInput>
  }

  export type PostTagUpdateWithWhereUniqueWithoutPostsInput = {
    where: PostTagWhereUniqueInput
    data: XOR<PostTagUpdateWithoutPostsInput, PostTagUncheckedUpdateWithoutPostsInput>
  }

  export type PostTagUpdateManyWithWhereWithoutPostsInput = {
    where: PostTagScalarWhereInput
    data: XOR<PostTagUpdateManyMutationInput, PostTagUncheckedUpdateManyWithoutPostsInput>
  }

  export type PostTagScalarWhereInput = {
    AND?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
    OR?: PostTagScalarWhereInput[]
    NOT?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
    id?: StringFilter<"PostTag"> | string
    tagName?: StringFilter<"PostTag"> | string
    createdAt?: DateTimeFilter<"PostTag"> | Date | string
    updatedAt?: DateTimeFilter<"PostTag"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPostInput>
  }

  export type PostCreateWithoutReactionInput = {
    id?: string
    content: string
    commentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserDetailsCreateNestedOneWithoutPostsInput
    postTags?: PostTagCreateNestedManyWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutReactionInput = {
    id?: string
    authorId: string
    content: string
    commentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    postTags?: PostTagUncheckedCreateNestedManyWithoutPostsInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutReactionInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutReactionInput, PostUncheckedCreateWithoutReactionInput>
  }

  export type PostUpsertWithoutReactionInput = {
    update: XOR<PostUpdateWithoutReactionInput, PostUncheckedUpdateWithoutReactionInput>
    create: XOR<PostCreateWithoutReactionInput, PostUncheckedCreateWithoutReactionInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutReactionInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutReactionInput, PostUncheckedUpdateWithoutReactionInput>
  }

  export type PostUpdateWithoutReactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    commentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserDetailsUpdateOneRequiredWithoutPostsNestedInput
    postTags?: PostTagUpdateManyWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutReactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    commentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postTags?: PostTagUncheckedUpdateManyWithoutPostsNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateWithoutCommentsInput = {
    id?: string
    content: string
    commentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserDetailsCreateNestedOneWithoutPostsInput
    reaction?: ReactionCreateNestedOneWithoutPostInput
    postTags?: PostTagCreateNestedManyWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutCommentsInput = {
    id?: string
    authorId: string
    content: string
    commentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reaction?: ReactionUncheckedCreateNestedOneWithoutPostInput
    postTags?: PostTagUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostCreateOrConnectWithoutCommentsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
  }

  export type UserDetailsCreateWithoutCommentsInput = {
    id?: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    user: UserCreateNestedOneWithoutUserDetailsInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserDetailsInput
    interests?: InterestCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatCreateNestedManyWithoutUser2Input
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsUncheckedCreateWithoutCommentsInput = {
    id?: string
    userId: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserDetailsInput
    interests?: InterestUncheckedCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchUncheckedCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchUncheckedCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventUncheckedCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventUncheckedCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatUncheckedCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatUncheckedCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsCreateOrConnectWithoutCommentsInput = {
    where: UserDetailsWhereUniqueInput
    create: XOR<UserDetailsCreateWithoutCommentsInput, UserDetailsUncheckedCreateWithoutCommentsInput>
  }

  export type PostUpsertWithoutCommentsInput = {
    update: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type PostUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    commentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserDetailsUpdateOneRequiredWithoutPostsNestedInput
    reaction?: ReactionUpdateOneWithoutPostNestedInput
    postTags?: PostTagUpdateManyWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    commentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reaction?: ReactionUncheckedUpdateOneWithoutPostNestedInput
    postTags?: PostTagUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type UserDetailsUpsertWithoutCommentsInput = {
    update: XOR<UserDetailsUpdateWithoutCommentsInput, UserDetailsUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserDetailsCreateWithoutCommentsInput, UserDetailsUncheckedCreateWithoutCommentsInput>
    where?: UserDetailsWhereInput
  }

  export type UserDetailsUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserDetailsWhereInput
    data: XOR<UserDetailsUpdateWithoutCommentsInput, UserDetailsUncheckedUpdateWithoutCommentsInput>
  }

  export type UserDetailsUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserDetailsNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
  }

  export type UserDetailsUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUncheckedUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUncheckedUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUncheckedUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUncheckedUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUncheckedUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUncheckedUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUncheckedUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type PostCreateWithoutPostTagsInput = {
    id?: string
    content: string
    commentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserDetailsCreateNestedOneWithoutPostsInput
    reaction?: ReactionCreateNestedOneWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutPostTagsInput = {
    id?: string
    authorId: string
    content: string
    commentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reaction?: ReactionUncheckedCreateNestedOneWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutPostTagsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutPostTagsInput, PostUncheckedCreateWithoutPostTagsInput>
  }

  export type PostUpsertWithWhereUniqueWithoutPostTagsInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutPostTagsInput, PostUncheckedUpdateWithoutPostTagsInput>
    create: XOR<PostCreateWithoutPostTagsInput, PostUncheckedCreateWithoutPostTagsInput>
  }

  export type PostUpdateWithWhereUniqueWithoutPostTagsInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutPostTagsInput, PostUncheckedUpdateWithoutPostTagsInput>
  }

  export type PostUpdateManyWithWhereWithoutPostTagsInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutPostTagsInput>
  }

  export type UserDetailsCreateWithoutNotificationsInput = {
    id?: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    user: UserCreateNestedOneWithoutUserDetailsInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    interests?: InterestCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatCreateNestedManyWithoutUser2Input
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsUncheckedCreateWithoutNotificationsInput = {
    id?: string
    userId: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    interests?: InterestUncheckedCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchUncheckedCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchUncheckedCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventUncheckedCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventUncheckedCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatUncheckedCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatUncheckedCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsCreateOrConnectWithoutNotificationsInput = {
    where: UserDetailsWhereUniqueInput
    create: XOR<UserDetailsCreateWithoutNotificationsInput, UserDetailsUncheckedCreateWithoutNotificationsInput>
  }

  export type UserDetailsUpsertWithoutNotificationsInput = {
    update: XOR<UserDetailsUpdateWithoutNotificationsInput, UserDetailsUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserDetailsCreateWithoutNotificationsInput, UserDetailsUncheckedCreateWithoutNotificationsInput>
    where?: UserDetailsWhereInput
  }

  export type UserDetailsUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserDetailsWhereInput
    data: XOR<UserDetailsUpdateWithoutNotificationsInput, UserDetailsUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserDetailsUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserDetailsNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    interests?: InterestUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
  }

  export type UserDetailsUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    interests?: InterestUncheckedUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUncheckedUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUncheckedUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUncheckedUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUncheckedUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUncheckedUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUncheckedUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserDetailsCreateWithoutInterestsInput = {
    id?: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    user: UserCreateNestedOneWithoutUserDetailsInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatCreateNestedManyWithoutUser2Input
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsUncheckedCreateWithoutInterestsInput = {
    id?: string
    userId: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchUncheckedCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchUncheckedCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventUncheckedCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventUncheckedCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatUncheckedCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatUncheckedCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsCreateOrConnectWithoutInterestsInput = {
    where: UserDetailsWhereUniqueInput
    create: XOR<UserDetailsCreateWithoutInterestsInput, UserDetailsUncheckedCreateWithoutInterestsInput>
  }

  export type UserDetailsUpsertWithWhereUniqueWithoutInterestsInput = {
    where: UserDetailsWhereUniqueInput
    update: XOR<UserDetailsUpdateWithoutInterestsInput, UserDetailsUncheckedUpdateWithoutInterestsInput>
    create: XOR<UserDetailsCreateWithoutInterestsInput, UserDetailsUncheckedCreateWithoutInterestsInput>
  }

  export type UserDetailsUpdateWithWhereUniqueWithoutInterestsInput = {
    where: UserDetailsWhereUniqueInput
    data: XOR<UserDetailsUpdateWithoutInterestsInput, UserDetailsUncheckedUpdateWithoutInterestsInput>
  }

  export type UserDetailsUpdateManyWithWhereWithoutInterestsInput = {
    where: UserDetailsScalarWhereInput
    data: XOR<UserDetailsUpdateManyMutationInput, UserDetailsUncheckedUpdateManyWithoutInterestsInput>
  }

  export type UserDetailsScalarWhereInput = {
    AND?: UserDetailsScalarWhereInput | UserDetailsScalarWhereInput[]
    OR?: UserDetailsScalarWhereInput[]
    NOT?: UserDetailsScalarWhereInput | UserDetailsScalarWhereInput[]
    id?: StringFilter<"UserDetails"> | string
    userId?: StringFilter<"UserDetails"> | string
    name?: StringFilter<"UserDetails"> | string
    department?: StringNullableFilter<"UserDetails"> | string | null
    year?: StringNullableFilter<"UserDetails"> | string | null
    profilePicture?: StringNullableFilter<"UserDetails"> | string | null
    bio?: StringNullableFilter<"UserDetails"> | string | null
    availability?: StringNullableFilter<"UserDetails"> | string | null
    reading?: StringNullableFilter<"UserDetails"> | string | null
  }

  export type UserDetailsCreateWithoutMatchesSentInput = {
    id?: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    user: UserCreateNestedOneWithoutUserDetailsInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserDetailsInput
    interests?: InterestCreateNestedManyWithoutUserDetailsInput
    matchesReceived?: MatchCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatCreateNestedManyWithoutUser2Input
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsUncheckedCreateWithoutMatchesSentInput = {
    id?: string
    userId: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserDetailsInput
    interests?: InterestUncheckedCreateNestedManyWithoutUserDetailsInput
    matchesReceived?: MatchUncheckedCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventUncheckedCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventUncheckedCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatUncheckedCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatUncheckedCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsCreateOrConnectWithoutMatchesSentInput = {
    where: UserDetailsWhereUniqueInput
    create: XOR<UserDetailsCreateWithoutMatchesSentInput, UserDetailsUncheckedCreateWithoutMatchesSentInput>
  }

  export type UserDetailsCreateWithoutMatchesReceivedInput = {
    id?: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    user: UserCreateNestedOneWithoutUserDetailsInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserDetailsInput
    interests?: InterestCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchCreateNestedManyWithoutInviterInput
    currentUserSimilarity?: UserSimilarityCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatCreateNestedManyWithoutUser2Input
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsUncheckedCreateWithoutMatchesReceivedInput = {
    id?: string
    userId: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserDetailsInput
    interests?: InterestUncheckedCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchUncheckedCreateNestedManyWithoutInviterInput
    currentUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventUncheckedCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventUncheckedCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatUncheckedCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatUncheckedCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsCreateOrConnectWithoutMatchesReceivedInput = {
    where: UserDetailsWhereUniqueInput
    create: XOR<UserDetailsCreateWithoutMatchesReceivedInput, UserDetailsUncheckedCreateWithoutMatchesReceivedInput>
  }

  export type UserDetailsUpsertWithoutMatchesSentInput = {
    update: XOR<UserDetailsUpdateWithoutMatchesSentInput, UserDetailsUncheckedUpdateWithoutMatchesSentInput>
    create: XOR<UserDetailsCreateWithoutMatchesSentInput, UserDetailsUncheckedCreateWithoutMatchesSentInput>
    where?: UserDetailsWhereInput
  }

  export type UserDetailsUpdateToOneWithWhereWithoutMatchesSentInput = {
    where?: UserDetailsWhereInput
    data: XOR<UserDetailsUpdateWithoutMatchesSentInput, UserDetailsUncheckedUpdateWithoutMatchesSentInput>
  }

  export type UserDetailsUpdateWithoutMatchesSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserDetailsNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUpdateManyWithoutUserDetailsNestedInput
    matchesReceived?: MatchUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
  }

  export type UserDetailsUncheckedUpdateWithoutMatchesSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUncheckedUpdateManyWithoutUserDetailsNestedInput
    matchesReceived?: MatchUncheckedUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUncheckedUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUncheckedUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUncheckedUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUncheckedUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserDetailsUpsertWithoutMatchesReceivedInput = {
    update: XOR<UserDetailsUpdateWithoutMatchesReceivedInput, UserDetailsUncheckedUpdateWithoutMatchesReceivedInput>
    create: XOR<UserDetailsCreateWithoutMatchesReceivedInput, UserDetailsUncheckedCreateWithoutMatchesReceivedInput>
    where?: UserDetailsWhereInput
  }

  export type UserDetailsUpdateToOneWithWhereWithoutMatchesReceivedInput = {
    where?: UserDetailsWhereInput
    data: XOR<UserDetailsUpdateWithoutMatchesReceivedInput, UserDetailsUncheckedUpdateWithoutMatchesReceivedInput>
  }

  export type UserDetailsUpdateWithoutMatchesReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserDetailsNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUpdateManyWithoutInviterNestedInput
    currentUserSimilarity?: UserSimilarityUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
  }

  export type UserDetailsUncheckedUpdateWithoutMatchesReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUncheckedUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUncheckedUpdateManyWithoutInviterNestedInput
    currentUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUncheckedUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUncheckedUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUncheckedUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUncheckedUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserDetailsCreateWithoutCurrentUserSimilarityInput = {
    id?: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    user: UserCreateNestedOneWithoutUserDetailsInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserDetailsInput
    interests?: InterestCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchCreateNestedManyWithoutInviteeInput
    otherUserSimilarity?: UserSimilarityCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatCreateNestedManyWithoutUser2Input
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsUncheckedCreateWithoutCurrentUserSimilarityInput = {
    id?: string
    userId: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserDetailsInput
    interests?: InterestUncheckedCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchUncheckedCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchUncheckedCreateNestedManyWithoutInviteeInput
    otherUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventUncheckedCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventUncheckedCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatUncheckedCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatUncheckedCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsCreateOrConnectWithoutCurrentUserSimilarityInput = {
    where: UserDetailsWhereUniqueInput
    create: XOR<UserDetailsCreateWithoutCurrentUserSimilarityInput, UserDetailsUncheckedCreateWithoutCurrentUserSimilarityInput>
  }

  export type UserDetailsCreateWithoutOtherUserSimilarityInput = {
    id?: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    user: UserCreateNestedOneWithoutUserDetailsInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserDetailsInput
    interests?: InterestCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityCreateNestedManyWithoutCurrentUserInput
    asEventAttendee?: EventCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatCreateNestedManyWithoutUser2Input
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsUncheckedCreateWithoutOtherUserSimilarityInput = {
    id?: string
    userId: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserDetailsInput
    interests?: InterestUncheckedCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchUncheckedCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchUncheckedCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutCurrentUserInput
    asEventAttendee?: EventUncheckedCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventUncheckedCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatUncheckedCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatUncheckedCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsCreateOrConnectWithoutOtherUserSimilarityInput = {
    where: UserDetailsWhereUniqueInput
    create: XOR<UserDetailsCreateWithoutOtherUserSimilarityInput, UserDetailsUncheckedCreateWithoutOtherUserSimilarityInput>
  }

  export type UserDetailsUpsertWithoutCurrentUserSimilarityInput = {
    update: XOR<UserDetailsUpdateWithoutCurrentUserSimilarityInput, UserDetailsUncheckedUpdateWithoutCurrentUserSimilarityInput>
    create: XOR<UserDetailsCreateWithoutCurrentUserSimilarityInput, UserDetailsUncheckedCreateWithoutCurrentUserSimilarityInput>
    where?: UserDetailsWhereInput
  }

  export type UserDetailsUpdateToOneWithWhereWithoutCurrentUserSimilarityInput = {
    where?: UserDetailsWhereInput
    data: XOR<UserDetailsUpdateWithoutCurrentUserSimilarityInput, UserDetailsUncheckedUpdateWithoutCurrentUserSimilarityInput>
  }

  export type UserDetailsUpdateWithoutCurrentUserSimilarityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserDetailsNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUpdateManyWithoutInviteeNestedInput
    otherUserSimilarity?: UserSimilarityUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
  }

  export type UserDetailsUncheckedUpdateWithoutCurrentUserSimilarityInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUncheckedUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUncheckedUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUncheckedUpdateManyWithoutInviteeNestedInput
    otherUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUncheckedUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUncheckedUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUncheckedUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUncheckedUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserDetailsUpsertWithoutOtherUserSimilarityInput = {
    update: XOR<UserDetailsUpdateWithoutOtherUserSimilarityInput, UserDetailsUncheckedUpdateWithoutOtherUserSimilarityInput>
    create: XOR<UserDetailsCreateWithoutOtherUserSimilarityInput, UserDetailsUncheckedCreateWithoutOtherUserSimilarityInput>
    where?: UserDetailsWhereInput
  }

  export type UserDetailsUpdateToOneWithWhereWithoutOtherUserSimilarityInput = {
    where?: UserDetailsWhereInput
    data: XOR<UserDetailsUpdateWithoutOtherUserSimilarityInput, UserDetailsUncheckedUpdateWithoutOtherUserSimilarityInput>
  }

  export type UserDetailsUpdateWithoutOtherUserSimilarityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserDetailsNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUpdateManyWithoutCurrentUserNestedInput
    asEventAttendee?: EventUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
  }

  export type UserDetailsUncheckedUpdateWithoutOtherUserSimilarityInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUncheckedUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUncheckedUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUncheckedUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutCurrentUserNestedInput
    asEventAttendee?: EventUncheckedUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUncheckedUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUncheckedUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUncheckedUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserDetailsCreateWithoutAsEventOrganizerInput = {
    id?: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    user: UserCreateNestedOneWithoutUserDetailsInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserDetailsInput
    interests?: InterestCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventCreateNestedManyWithoutAttendeesInput
    coffeeChatsSent?: CoffeeChatCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatCreateNestedManyWithoutUser2Input
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsUncheckedCreateWithoutAsEventOrganizerInput = {
    id?: string
    userId: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserDetailsInput
    interests?: InterestUncheckedCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchUncheckedCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchUncheckedCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventUncheckedCreateNestedManyWithoutAttendeesInput
    coffeeChatsSent?: CoffeeChatUncheckedCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatUncheckedCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsCreateOrConnectWithoutAsEventOrganizerInput = {
    where: UserDetailsWhereUniqueInput
    create: XOR<UserDetailsCreateWithoutAsEventOrganizerInput, UserDetailsUncheckedCreateWithoutAsEventOrganizerInput>
  }

  export type UserDetailsCreateWithoutAsEventAttendeeInput = {
    id?: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    user: UserCreateNestedOneWithoutUserDetailsInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserDetailsInput
    interests?: InterestCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityCreateNestedManyWithoutOtherUserInput
    asEventOrganizer?: EventCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatCreateNestedManyWithoutUser2Input
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsUncheckedCreateWithoutAsEventAttendeeInput = {
    id?: string
    userId: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserDetailsInput
    interests?: InterestUncheckedCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchUncheckedCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchUncheckedCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutOtherUserInput
    asEventOrganizer?: EventUncheckedCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatUncheckedCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatUncheckedCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsCreateOrConnectWithoutAsEventAttendeeInput = {
    where: UserDetailsWhereUniqueInput
    create: XOR<UserDetailsCreateWithoutAsEventAttendeeInput, UserDetailsUncheckedCreateWithoutAsEventAttendeeInput>
  }

  export type UserDetailsUpsertWithWhereUniqueWithoutAsEventOrganizerInput = {
    where: UserDetailsWhereUniqueInput
    update: XOR<UserDetailsUpdateWithoutAsEventOrganizerInput, UserDetailsUncheckedUpdateWithoutAsEventOrganizerInput>
    create: XOR<UserDetailsCreateWithoutAsEventOrganizerInput, UserDetailsUncheckedCreateWithoutAsEventOrganizerInput>
  }

  export type UserDetailsUpdateWithWhereUniqueWithoutAsEventOrganizerInput = {
    where: UserDetailsWhereUniqueInput
    data: XOR<UserDetailsUpdateWithoutAsEventOrganizerInput, UserDetailsUncheckedUpdateWithoutAsEventOrganizerInput>
  }

  export type UserDetailsUpdateManyWithWhereWithoutAsEventOrganizerInput = {
    where: UserDetailsScalarWhereInput
    data: XOR<UserDetailsUpdateManyMutationInput, UserDetailsUncheckedUpdateManyWithoutAsEventOrganizerInput>
  }

  export type UserDetailsUpsertWithWhereUniqueWithoutAsEventAttendeeInput = {
    where: UserDetailsWhereUniqueInput
    update: XOR<UserDetailsUpdateWithoutAsEventAttendeeInput, UserDetailsUncheckedUpdateWithoutAsEventAttendeeInput>
    create: XOR<UserDetailsCreateWithoutAsEventAttendeeInput, UserDetailsUncheckedCreateWithoutAsEventAttendeeInput>
  }

  export type UserDetailsUpdateWithWhereUniqueWithoutAsEventAttendeeInput = {
    where: UserDetailsWhereUniqueInput
    data: XOR<UserDetailsUpdateWithoutAsEventAttendeeInput, UserDetailsUncheckedUpdateWithoutAsEventAttendeeInput>
  }

  export type UserDetailsUpdateManyWithWhereWithoutAsEventAttendeeInput = {
    where: UserDetailsScalarWhereInput
    data: XOR<UserDetailsUpdateManyMutationInput, UserDetailsUncheckedUpdateManyWithoutAsEventAttendeeInput>
  }

  export type UserDetailsCreateWithoutCoffeeChatsSentInput = {
    id?: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    user: UserCreateNestedOneWithoutUserDetailsInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserDetailsInput
    interests?: InterestCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventCreateNestedManyWithoutOrganizersInput
    coffeeChatsReceived?: CoffeeChatCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatCreateNestedManyWithoutUser2Input
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsUncheckedCreateWithoutCoffeeChatsSentInput = {
    id?: string
    userId: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserDetailsInput
    interests?: InterestUncheckedCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchUncheckedCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchUncheckedCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventUncheckedCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventUncheckedCreateNestedManyWithoutOrganizersInput
    coffeeChatsReceived?: CoffeeChatUncheckedCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsCreateOrConnectWithoutCoffeeChatsSentInput = {
    where: UserDetailsWhereUniqueInput
    create: XOR<UserDetailsCreateWithoutCoffeeChatsSentInput, UserDetailsUncheckedCreateWithoutCoffeeChatsSentInput>
  }

  export type UserDetailsCreateWithoutCoffeeChatsReceivedInput = {
    id?: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    user: UserCreateNestedOneWithoutUserDetailsInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserDetailsInput
    interests?: InterestCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatCreateNestedManyWithoutInviterInput
    chatsAsUser1?: ChatCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatCreateNestedManyWithoutUser2Input
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsUncheckedCreateWithoutCoffeeChatsReceivedInput = {
    id?: string
    userId: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserDetailsInput
    interests?: InterestUncheckedCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchUncheckedCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchUncheckedCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventUncheckedCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventUncheckedCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatUncheckedCreateNestedManyWithoutInviterInput
    chatsAsUser1?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsCreateOrConnectWithoutCoffeeChatsReceivedInput = {
    where: UserDetailsWhereUniqueInput
    create: XOR<UserDetailsCreateWithoutCoffeeChatsReceivedInput, UserDetailsUncheckedCreateWithoutCoffeeChatsReceivedInput>
  }

  export type CoffeeChatPurposeCreateWithoutCoffeeChatsInput = {
    id?: string
    purposeName: string
    description: string
    timeLimit: number
  }

  export type CoffeeChatPurposeUncheckedCreateWithoutCoffeeChatsInput = {
    id?: string
    purposeName: string
    description: string
    timeLimit: number
  }

  export type CoffeeChatPurposeCreateOrConnectWithoutCoffeeChatsInput = {
    where: CoffeeChatPurposeWhereUniqueInput
    create: XOR<CoffeeChatPurposeCreateWithoutCoffeeChatsInput, CoffeeChatPurposeUncheckedCreateWithoutCoffeeChatsInput>
  }

  export type CoffeeChatVenueCreateWithoutCoffeeChatsInput = {
    id?: string
    venueName: string
    noiseLevel: $Enums.CoffeeChatVenueNoiseLevel
    description: string
    location: string
    rating: number
    tags?: CoffeeChatVenueCreatetagsInput | $Enums.CoffeeChatVenueTags[]
  }

  export type CoffeeChatVenueUncheckedCreateWithoutCoffeeChatsInput = {
    id?: string
    venueName: string
    noiseLevel: $Enums.CoffeeChatVenueNoiseLevel
    description: string
    location: string
    rating: number
    tags?: CoffeeChatVenueCreatetagsInput | $Enums.CoffeeChatVenueTags[]
  }

  export type CoffeeChatVenueCreateOrConnectWithoutCoffeeChatsInput = {
    where: CoffeeChatVenueWhereUniqueInput
    create: XOR<CoffeeChatVenueCreateWithoutCoffeeChatsInput, CoffeeChatVenueUncheckedCreateWithoutCoffeeChatsInput>
  }

  export type UserDetailsUpsertWithoutCoffeeChatsSentInput = {
    update: XOR<UserDetailsUpdateWithoutCoffeeChatsSentInput, UserDetailsUncheckedUpdateWithoutCoffeeChatsSentInput>
    create: XOR<UserDetailsCreateWithoutCoffeeChatsSentInput, UserDetailsUncheckedCreateWithoutCoffeeChatsSentInput>
    where?: UserDetailsWhereInput
  }

  export type UserDetailsUpdateToOneWithWhereWithoutCoffeeChatsSentInput = {
    where?: UserDetailsWhereInput
    data: XOR<UserDetailsUpdateWithoutCoffeeChatsSentInput, UserDetailsUncheckedUpdateWithoutCoffeeChatsSentInput>
  }

  export type UserDetailsUpdateWithoutCoffeeChatsSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserDetailsNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUpdateManyWithoutOrganizersNestedInput
    coffeeChatsReceived?: CoffeeChatUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
  }

  export type UserDetailsUncheckedUpdateWithoutCoffeeChatsSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUncheckedUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUncheckedUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUncheckedUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUncheckedUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUncheckedUpdateManyWithoutOrganizersNestedInput
    coffeeChatsReceived?: CoffeeChatUncheckedUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserDetailsUpsertWithoutCoffeeChatsReceivedInput = {
    update: XOR<UserDetailsUpdateWithoutCoffeeChatsReceivedInput, UserDetailsUncheckedUpdateWithoutCoffeeChatsReceivedInput>
    create: XOR<UserDetailsCreateWithoutCoffeeChatsReceivedInput, UserDetailsUncheckedCreateWithoutCoffeeChatsReceivedInput>
    where?: UserDetailsWhereInput
  }

  export type UserDetailsUpdateToOneWithWhereWithoutCoffeeChatsReceivedInput = {
    where?: UserDetailsWhereInput
    data: XOR<UserDetailsUpdateWithoutCoffeeChatsReceivedInput, UserDetailsUncheckedUpdateWithoutCoffeeChatsReceivedInput>
  }

  export type UserDetailsUpdateWithoutCoffeeChatsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserDetailsNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUpdateManyWithoutInviterNestedInput
    chatsAsUser1?: ChatUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
  }

  export type UserDetailsUncheckedUpdateWithoutCoffeeChatsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUncheckedUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUncheckedUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUncheckedUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUncheckedUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUncheckedUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUncheckedUpdateManyWithoutInviterNestedInput
    chatsAsUser1?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type CoffeeChatPurposeUpsertWithoutCoffeeChatsInput = {
    update: XOR<CoffeeChatPurposeUpdateWithoutCoffeeChatsInput, CoffeeChatPurposeUncheckedUpdateWithoutCoffeeChatsInput>
    create: XOR<CoffeeChatPurposeCreateWithoutCoffeeChatsInput, CoffeeChatPurposeUncheckedCreateWithoutCoffeeChatsInput>
    where?: CoffeeChatPurposeWhereInput
  }

  export type CoffeeChatPurposeUpdateToOneWithWhereWithoutCoffeeChatsInput = {
    where?: CoffeeChatPurposeWhereInput
    data: XOR<CoffeeChatPurposeUpdateWithoutCoffeeChatsInput, CoffeeChatPurposeUncheckedUpdateWithoutCoffeeChatsInput>
  }

  export type CoffeeChatPurposeUpdateWithoutCoffeeChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    purposeName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    timeLimit?: IntFieldUpdateOperationsInput | number
  }

  export type CoffeeChatPurposeUncheckedUpdateWithoutCoffeeChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    purposeName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    timeLimit?: IntFieldUpdateOperationsInput | number
  }

  export type CoffeeChatVenueUpsertWithoutCoffeeChatsInput = {
    update: XOR<CoffeeChatVenueUpdateWithoutCoffeeChatsInput, CoffeeChatVenueUncheckedUpdateWithoutCoffeeChatsInput>
    create: XOR<CoffeeChatVenueCreateWithoutCoffeeChatsInput, CoffeeChatVenueUncheckedCreateWithoutCoffeeChatsInput>
    where?: CoffeeChatVenueWhereInput
  }

  export type CoffeeChatVenueUpdateToOneWithWhereWithoutCoffeeChatsInput = {
    where?: CoffeeChatVenueWhereInput
    data: XOR<CoffeeChatVenueUpdateWithoutCoffeeChatsInput, CoffeeChatVenueUncheckedUpdateWithoutCoffeeChatsInput>
  }

  export type CoffeeChatVenueUpdateWithoutCoffeeChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueName?: StringFieldUpdateOperationsInput | string
    noiseLevel?: EnumCoffeeChatVenueNoiseLevelFieldUpdateOperationsInput | $Enums.CoffeeChatVenueNoiseLevel
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    tags?: CoffeeChatVenueUpdatetagsInput | $Enums.CoffeeChatVenueTags[]
  }

  export type CoffeeChatVenueUncheckedUpdateWithoutCoffeeChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueName?: StringFieldUpdateOperationsInput | string
    noiseLevel?: EnumCoffeeChatVenueNoiseLevelFieldUpdateOperationsInput | $Enums.CoffeeChatVenueNoiseLevel
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    tags?: CoffeeChatVenueUpdatetagsInput | $Enums.CoffeeChatVenueTags[]
  }

  export type CoffeeChatCreateWithoutPurposeInput = {
    id?: string
    scheduledAt?: Date | string | null
    duration: number
    personalMessage?: string | null
    status?: $Enums.CoffeeChatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    inviter: UserDetailsCreateNestedOneWithoutCoffeeChatsSentInput
    invitee: UserDetailsCreateNestedOneWithoutCoffeeChatsReceivedInput
    venue: CoffeeChatVenueCreateNestedOneWithoutCoffeeChatsInput
  }

  export type CoffeeChatUncheckedCreateWithoutPurposeInput = {
    id?: string
    inviterId: string
    inviteeId: string
    venueId: string
    scheduledAt?: Date | string | null
    duration: number
    personalMessage?: string | null
    status?: $Enums.CoffeeChatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoffeeChatCreateOrConnectWithoutPurposeInput = {
    where: CoffeeChatWhereUniqueInput
    create: XOR<CoffeeChatCreateWithoutPurposeInput, CoffeeChatUncheckedCreateWithoutPurposeInput>
  }

  export type CoffeeChatCreateManyPurposeInputEnvelope = {
    data: CoffeeChatCreateManyPurposeInput | CoffeeChatCreateManyPurposeInput[]
    skipDuplicates?: boolean
  }

  export type CoffeeChatUpsertWithWhereUniqueWithoutPurposeInput = {
    where: CoffeeChatWhereUniqueInput
    update: XOR<CoffeeChatUpdateWithoutPurposeInput, CoffeeChatUncheckedUpdateWithoutPurposeInput>
    create: XOR<CoffeeChatCreateWithoutPurposeInput, CoffeeChatUncheckedCreateWithoutPurposeInput>
  }

  export type CoffeeChatUpdateWithWhereUniqueWithoutPurposeInput = {
    where: CoffeeChatWhereUniqueInput
    data: XOR<CoffeeChatUpdateWithoutPurposeInput, CoffeeChatUncheckedUpdateWithoutPurposeInput>
  }

  export type CoffeeChatUpdateManyWithWhereWithoutPurposeInput = {
    where: CoffeeChatScalarWhereInput
    data: XOR<CoffeeChatUpdateManyMutationInput, CoffeeChatUncheckedUpdateManyWithoutPurposeInput>
  }

  export type CoffeeChatCreateWithoutVenueInput = {
    id?: string
    scheduledAt?: Date | string | null
    duration: number
    personalMessage?: string | null
    status?: $Enums.CoffeeChatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    inviter: UserDetailsCreateNestedOneWithoutCoffeeChatsSentInput
    invitee: UserDetailsCreateNestedOneWithoutCoffeeChatsReceivedInput
    purpose: CoffeeChatPurposeCreateNestedOneWithoutCoffeeChatsInput
  }

  export type CoffeeChatUncheckedCreateWithoutVenueInput = {
    id?: string
    inviterId: string
    inviteeId: string
    purposeId: string
    scheduledAt?: Date | string | null
    duration: number
    personalMessage?: string | null
    status?: $Enums.CoffeeChatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoffeeChatCreateOrConnectWithoutVenueInput = {
    where: CoffeeChatWhereUniqueInput
    create: XOR<CoffeeChatCreateWithoutVenueInput, CoffeeChatUncheckedCreateWithoutVenueInput>
  }

  export type CoffeeChatCreateManyVenueInputEnvelope = {
    data: CoffeeChatCreateManyVenueInput | CoffeeChatCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type CoffeeChatUpsertWithWhereUniqueWithoutVenueInput = {
    where: CoffeeChatWhereUniqueInput
    update: XOR<CoffeeChatUpdateWithoutVenueInput, CoffeeChatUncheckedUpdateWithoutVenueInput>
    create: XOR<CoffeeChatCreateWithoutVenueInput, CoffeeChatUncheckedCreateWithoutVenueInput>
  }

  export type CoffeeChatUpdateWithWhereUniqueWithoutVenueInput = {
    where: CoffeeChatWhereUniqueInput
    data: XOR<CoffeeChatUpdateWithoutVenueInput, CoffeeChatUncheckedUpdateWithoutVenueInput>
  }

  export type CoffeeChatUpdateManyWithWhereWithoutVenueInput = {
    where: CoffeeChatScalarWhereInput
    data: XOR<CoffeeChatUpdateManyMutationInput, CoffeeChatUncheckedUpdateManyWithoutVenueInput>
  }

  export type UserDetailsCreateWithoutChatsAsUser1Input = {
    id?: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    user: UserCreateNestedOneWithoutUserDetailsInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserDetailsInput
    interests?: InterestCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatCreateNestedManyWithoutInviteeInput
    chatsAsUser2?: ChatCreateNestedManyWithoutUser2Input
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsUncheckedCreateWithoutChatsAsUser1Input = {
    id?: string
    userId: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserDetailsInput
    interests?: InterestUncheckedCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchUncheckedCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchUncheckedCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventUncheckedCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventUncheckedCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatUncheckedCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatUncheckedCreateNestedManyWithoutInviteeInput
    chatsAsUser2?: ChatUncheckedCreateNestedManyWithoutUser2Input
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsCreateOrConnectWithoutChatsAsUser1Input = {
    where: UserDetailsWhereUniqueInput
    create: XOR<UserDetailsCreateWithoutChatsAsUser1Input, UserDetailsUncheckedCreateWithoutChatsAsUser1Input>
  }

  export type UserDetailsCreateWithoutChatsAsUser2Input = {
    id?: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    user: UserCreateNestedOneWithoutUserDetailsInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserDetailsInput
    interests?: InterestCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatCreateNestedManyWithoutUser1Input
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsUncheckedCreateWithoutChatsAsUser2Input = {
    id?: string
    userId: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserDetailsInput
    interests?: InterestUncheckedCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchUncheckedCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchUncheckedCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventUncheckedCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventUncheckedCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatUncheckedCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatUncheckedCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatUncheckedCreateNestedManyWithoutUser1Input
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserDetailsCreateOrConnectWithoutChatsAsUser2Input = {
    where: UserDetailsWhereUniqueInput
    create: XOR<UserDetailsCreateWithoutChatsAsUser2Input, UserDetailsUncheckedCreateWithoutChatsAsUser2Input>
  }

  export type MessageCreateWithoutChatInput = {
    id?: string
    content: string
    createdAt?: Date | string
    sender: UserDetailsCreateNestedOneWithoutMessagesSentInput
  }

  export type MessageUncheckedCreateWithoutChatInput = {
    id?: string
    senderId: string
    content: string
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutChatInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput>
  }

  export type MessageCreateManyChatInputEnvelope = {
    data: MessageCreateManyChatInput | MessageCreateManyChatInput[]
    skipDuplicates?: boolean
  }

  export type UserDetailsUpsertWithoutChatsAsUser1Input = {
    update: XOR<UserDetailsUpdateWithoutChatsAsUser1Input, UserDetailsUncheckedUpdateWithoutChatsAsUser1Input>
    create: XOR<UserDetailsCreateWithoutChatsAsUser1Input, UserDetailsUncheckedCreateWithoutChatsAsUser1Input>
    where?: UserDetailsWhereInput
  }

  export type UserDetailsUpdateToOneWithWhereWithoutChatsAsUser1Input = {
    where?: UserDetailsWhereInput
    data: XOR<UserDetailsUpdateWithoutChatsAsUser1Input, UserDetailsUncheckedUpdateWithoutChatsAsUser1Input>
  }

  export type UserDetailsUpdateWithoutChatsAsUser1Input = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserDetailsNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUpdateManyWithoutInviteeNestedInput
    chatsAsUser2?: ChatUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
  }

  export type UserDetailsUncheckedUpdateWithoutChatsAsUser1Input = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUncheckedUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUncheckedUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUncheckedUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUncheckedUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUncheckedUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUncheckedUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUncheckedUpdateManyWithoutInviteeNestedInput
    chatsAsUser2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserDetailsUpsertWithoutChatsAsUser2Input = {
    update: XOR<UserDetailsUpdateWithoutChatsAsUser2Input, UserDetailsUncheckedUpdateWithoutChatsAsUser2Input>
    create: XOR<UserDetailsCreateWithoutChatsAsUser2Input, UserDetailsUncheckedCreateWithoutChatsAsUser2Input>
    where?: UserDetailsWhereInput
  }

  export type UserDetailsUpdateToOneWithWhereWithoutChatsAsUser2Input = {
    where?: UserDetailsWhereInput
    data: XOR<UserDetailsUpdateWithoutChatsAsUser2Input, UserDetailsUncheckedUpdateWithoutChatsAsUser2Input>
  }

  export type UserDetailsUpdateWithoutChatsAsUser2Input = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserDetailsNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUpdateManyWithoutUser1NestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
  }

  export type UserDetailsUncheckedUpdateWithoutChatsAsUser2Input = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUncheckedUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUncheckedUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUncheckedUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUncheckedUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUncheckedUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUncheckedUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUncheckedUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutChatInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutChatInput, MessageUncheckedUpdateWithoutChatInput>
    create: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutChatInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutChatInput, MessageUncheckedUpdateWithoutChatInput>
  }

  export type MessageUpdateManyWithWhereWithoutChatInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutChatInput>
  }

  export type ChatCreateWithoutMessagesInput = {
    id?: string
    name?: string | null
    user1: UserDetailsCreateNestedOneWithoutChatsAsUser1Input
    user2: UserDetailsCreateNestedOneWithoutChatsAsUser2Input
  }

  export type ChatUncheckedCreateWithoutMessagesInput = {
    id?: string
    user1Id: string
    user2Id: string
    name?: string | null
  }

  export type ChatCreateOrConnectWithoutMessagesInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
  }

  export type UserDetailsCreateWithoutMessagesSentInput = {
    id?: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    user: UserCreateNestedOneWithoutUserDetailsInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserDetailsInput
    interests?: InterestCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatCreateNestedManyWithoutUser2Input
  }

  export type UserDetailsUncheckedCreateWithoutMessagesSentInput = {
    id?: string
    userId: string
    name: string
    department?: string | null
    year?: string | null
    profilePicture?: string | null
    bio?: string | null
    availability?: string | null
    reading?: string | null
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserDetailsInput
    interests?: InterestUncheckedCreateNestedManyWithoutUserDetailsInput
    matchesSent?: MatchUncheckedCreateNestedManyWithoutInviterInput
    matchesReceived?: MatchUncheckedCreateNestedManyWithoutInviteeInput
    currentUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutCurrentUserInput
    otherUserSimilarity?: UserSimilarityUncheckedCreateNestedManyWithoutOtherUserInput
    asEventAttendee?: EventUncheckedCreateNestedManyWithoutAttendeesInput
    asEventOrganizer?: EventUncheckedCreateNestedManyWithoutOrganizersInput
    coffeeChatsSent?: CoffeeChatUncheckedCreateNestedManyWithoutInviterInput
    coffeeChatsReceived?: CoffeeChatUncheckedCreateNestedManyWithoutInviteeInput
    chatsAsUser1?: ChatUncheckedCreateNestedManyWithoutUser1Input
    chatsAsUser2?: ChatUncheckedCreateNestedManyWithoutUser2Input
  }

  export type UserDetailsCreateOrConnectWithoutMessagesSentInput = {
    where: UserDetailsWhereUniqueInput
    create: XOR<UserDetailsCreateWithoutMessagesSentInput, UserDetailsUncheckedCreateWithoutMessagesSentInput>
  }

  export type ChatUpsertWithoutMessagesInput = {
    update: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    where?: ChatWhereInput
  }

  export type ChatUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChatWhereInput
    data: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    user1?: UserDetailsUpdateOneRequiredWithoutChatsAsUser1NestedInput
    user2?: UserDetailsUpdateOneRequiredWithoutChatsAsUser2NestedInput
  }

  export type ChatUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserDetailsUpsertWithoutMessagesSentInput = {
    update: XOR<UserDetailsUpdateWithoutMessagesSentInput, UserDetailsUncheckedUpdateWithoutMessagesSentInput>
    create: XOR<UserDetailsCreateWithoutMessagesSentInput, UserDetailsUncheckedCreateWithoutMessagesSentInput>
    where?: UserDetailsWhereInput
  }

  export type UserDetailsUpdateToOneWithWhereWithoutMessagesSentInput = {
    where?: UserDetailsWhereInput
    data: XOR<UserDetailsUpdateWithoutMessagesSentInput, UserDetailsUncheckedUpdateWithoutMessagesSentInput>
  }

  export type UserDetailsUpdateWithoutMessagesSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserDetailsNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUpdateManyWithoutUser2NestedInput
  }

  export type UserDetailsUncheckedUpdateWithoutMessagesSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUncheckedUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUncheckedUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUncheckedUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUncheckedUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUncheckedUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUncheckedUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUncheckedUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
  }

  export type PostCreateManyAuthorInput = {
    id?: string
    content: string
    commentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyAuthorInput = {
    id?: string
    postId: string
    commentContent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserDetailsInput = {
    id?: string
    notificationType: $Enums.NotificationType
    notificationData: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchCreateManyInviterInput = {
    id?: string
    inviteeId: string
    matchScore: number
    matchStatus?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchCreateManyInviteeInput = {
    id?: string
    inviterId: string
    matchScore: number
    matchStatus?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSimilarityCreateManyCurrentUserInput = {
    id?: string
    otherUserId: string
    similarityScore: number
    factors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UserSimilarityCreateManyOtherUserInput = {
    id?: string
    currentUserId: string
    similarityScore: number
    factors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CoffeeChatCreateManyInviterInput = {
    id?: string
    inviteeId: string
    purposeId: string
    venueId: string
    scheduledAt?: Date | string | null
    duration: number
    personalMessage?: string | null
    status?: $Enums.CoffeeChatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoffeeChatCreateManyInviteeInput = {
    id?: string
    inviterId: string
    purposeId: string
    venueId: string
    scheduledAt?: Date | string | null
    duration: number
    personalMessage?: string | null
    status?: $Enums.CoffeeChatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatCreateManyUser1Input = {
    id?: string
    user2Id: string
    name?: string | null
  }

  export type ChatCreateManyUser2Input = {
    id?: string
    user1Id: string
    name?: string | null
  }

  export type MessageCreateManySenderInput = {
    id?: string
    chatId: string
    content: string
    createdAt?: Date | string
  }

  export type PostUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    commentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reaction?: ReactionUpdateOneWithoutPostNestedInput
    postTags?: PostTagUpdateManyWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    commentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reaction?: ReactionUncheckedUpdateOneWithoutPostNestedInput
    postTags?: PostTagUncheckedUpdateManyWithoutPostsNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    commentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    commentContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    commentContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    notificationData?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    notificationData?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    notificationData?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterestUpdateWithoutUserDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    interestName?: StringFieldUpdateOperationsInput | string
  }

  export type InterestUncheckedUpdateWithoutUserDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    interestName?: StringFieldUpdateOperationsInput | string
  }

  export type InterestUncheckedUpdateManyWithoutUserDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    interestName?: StringFieldUpdateOperationsInput | string
  }

  export type MatchUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchScore?: IntFieldUpdateOperationsInput | number
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitee?: UserDetailsUpdateOneRequiredWithoutMatchesReceivedNestedInput
  }

  export type MatchUncheckedUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteeId?: StringFieldUpdateOperationsInput | string
    matchScore?: IntFieldUpdateOperationsInput | number
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchUncheckedUpdateManyWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteeId?: StringFieldUpdateOperationsInput | string
    matchScore?: IntFieldUpdateOperationsInput | number
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchUpdateWithoutInviteeInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchScore?: IntFieldUpdateOperationsInput | number
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviter?: UserDetailsUpdateOneRequiredWithoutMatchesSentNestedInput
  }

  export type MatchUncheckedUpdateWithoutInviteeInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    matchScore?: IntFieldUpdateOperationsInput | number
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchUncheckedUpdateManyWithoutInviteeInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    matchScore?: IntFieldUpdateOperationsInput | number
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSimilarityUpdateWithoutCurrentUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    similarityScore?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otherUser?: UserDetailsUpdateOneRequiredWithoutOtherUserSimilarityNestedInput
  }

  export type UserSimilarityUncheckedUpdateWithoutCurrentUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    otherUserId?: StringFieldUpdateOperationsInput | string
    similarityScore?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSimilarityUncheckedUpdateManyWithoutCurrentUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    otherUserId?: StringFieldUpdateOperationsInput | string
    similarityScore?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSimilarityUpdateWithoutOtherUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    similarityScore?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentUser?: UserDetailsUpdateOneRequiredWithoutCurrentUserSimilarityNestedInput
  }

  export type UserSimilarityUncheckedUpdateWithoutOtherUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentUserId?: StringFieldUpdateOperationsInput | string
    similarityScore?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSimilarityUncheckedUpdateManyWithoutOtherUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentUserId?: StringFieldUpdateOperationsInput | string
    similarityScore?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutAttendeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizers?: UserDetailsUpdateManyWithoutAsEventOrganizerNestedInput
  }

  export type EventUncheckedUpdateWithoutAttendeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizers?: UserDetailsUncheckedUpdateManyWithoutAsEventOrganizerNestedInput
  }

  export type EventUncheckedUpdateManyWithoutAttendeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutOrganizersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendees?: UserDetailsUpdateManyWithoutAsEventAttendeeNestedInput
  }

  export type EventUncheckedUpdateWithoutOrganizersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendees?: UserDetailsUncheckedUpdateManyWithoutAsEventAttendeeNestedInput
  }

  export type EventUncheckedUpdateManyWithoutOrganizersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoffeeChatUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    personalMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCoffeeChatStatusFieldUpdateOperationsInput | $Enums.CoffeeChatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitee?: UserDetailsUpdateOneRequiredWithoutCoffeeChatsReceivedNestedInput
    purpose?: CoffeeChatPurposeUpdateOneRequiredWithoutCoffeeChatsNestedInput
    venue?: CoffeeChatVenueUpdateOneRequiredWithoutCoffeeChatsNestedInput
  }

  export type CoffeeChatUncheckedUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteeId?: StringFieldUpdateOperationsInput | string
    purposeId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    personalMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCoffeeChatStatusFieldUpdateOperationsInput | $Enums.CoffeeChatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoffeeChatUncheckedUpdateManyWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteeId?: StringFieldUpdateOperationsInput | string
    purposeId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    personalMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCoffeeChatStatusFieldUpdateOperationsInput | $Enums.CoffeeChatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoffeeChatUpdateWithoutInviteeInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    personalMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCoffeeChatStatusFieldUpdateOperationsInput | $Enums.CoffeeChatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviter?: UserDetailsUpdateOneRequiredWithoutCoffeeChatsSentNestedInput
    purpose?: CoffeeChatPurposeUpdateOneRequiredWithoutCoffeeChatsNestedInput
    venue?: CoffeeChatVenueUpdateOneRequiredWithoutCoffeeChatsNestedInput
  }

  export type CoffeeChatUncheckedUpdateWithoutInviteeInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    purposeId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    personalMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCoffeeChatStatusFieldUpdateOperationsInput | $Enums.CoffeeChatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoffeeChatUncheckedUpdateManyWithoutInviteeInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    purposeId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    personalMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCoffeeChatStatusFieldUpdateOperationsInput | $Enums.CoffeeChatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUpdateWithoutUser1Input = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    user2?: UserDetailsUpdateOneRequiredWithoutChatsAsUser2NestedInput
    messages?: MessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutUser1Input = {
    id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: MessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateManyWithoutUser1Input = {
    id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChatUpdateWithoutUser2Input = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    user1?: UserDetailsUpdateOneRequiredWithoutChatsAsUser1NestedInput
    messages?: MessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutUser2Input = {
    id?: StringFieldUpdateOperationsInput | string
    user1Id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: MessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateManyWithoutUser2Input = {
    id?: StringFieldUpdateOperationsInput | string
    user1Id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyPostInput = {
    id?: string
    authorId: string
    commentContent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostTagUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostTagUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostTagUncheckedUpdateManyWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserDetailsUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    commentContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    commentContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpdateWithoutPostTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    commentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserDetailsUpdateOneRequiredWithoutPostsNestedInput
    reaction?: ReactionUpdateOneWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutPostTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    commentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reaction?: ReactionUncheckedUpdateOneWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutPostTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    commentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDetailsUpdateWithoutInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserDetailsNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
  }

  export type UserDetailsUncheckedUpdateWithoutInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUncheckedUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUncheckedUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUncheckedUpdateManyWithoutAttendeesNestedInput
    asEventOrganizer?: EventUncheckedUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUncheckedUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUncheckedUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserDetailsUncheckedUpdateManyWithoutInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserDetailsUpdateWithoutAsEventOrganizerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserDetailsNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUpdateManyWithoutAttendeesNestedInput
    coffeeChatsSent?: CoffeeChatUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
  }

  export type UserDetailsUncheckedUpdateWithoutAsEventOrganizerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUncheckedUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUncheckedUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUncheckedUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutOtherUserNestedInput
    asEventAttendee?: EventUncheckedUpdateManyWithoutAttendeesNestedInput
    coffeeChatsSent?: CoffeeChatUncheckedUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUncheckedUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserDetailsUncheckedUpdateManyWithoutAsEventOrganizerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserDetailsUpdateWithoutAsEventAttendeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserDetailsNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUpdateManyWithoutOtherUserNestedInput
    asEventOrganizer?: EventUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
  }

  export type UserDetailsUncheckedUpdateWithoutAsEventAttendeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserDetailsNestedInput
    interests?: InterestUncheckedUpdateManyWithoutUserDetailsNestedInput
    matchesSent?: MatchUncheckedUpdateManyWithoutInviterNestedInput
    matchesReceived?: MatchUncheckedUpdateManyWithoutInviteeNestedInput
    currentUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutCurrentUserNestedInput
    otherUserSimilarity?: UserSimilarityUncheckedUpdateManyWithoutOtherUserNestedInput
    asEventOrganizer?: EventUncheckedUpdateManyWithoutOrganizersNestedInput
    coffeeChatsSent?: CoffeeChatUncheckedUpdateManyWithoutInviterNestedInput
    coffeeChatsReceived?: CoffeeChatUncheckedUpdateManyWithoutInviteeNestedInput
    chatsAsUser1?: ChatUncheckedUpdateManyWithoutUser1NestedInput
    chatsAsUser2?: ChatUncheckedUpdateManyWithoutUser2NestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserDetailsUncheckedUpdateManyWithoutAsEventAttendeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    reading?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CoffeeChatCreateManyPurposeInput = {
    id?: string
    inviterId: string
    inviteeId: string
    venueId: string
    scheduledAt?: Date | string | null
    duration: number
    personalMessage?: string | null
    status?: $Enums.CoffeeChatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoffeeChatUpdateWithoutPurposeInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    personalMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCoffeeChatStatusFieldUpdateOperationsInput | $Enums.CoffeeChatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviter?: UserDetailsUpdateOneRequiredWithoutCoffeeChatsSentNestedInput
    invitee?: UserDetailsUpdateOneRequiredWithoutCoffeeChatsReceivedNestedInput
    venue?: CoffeeChatVenueUpdateOneRequiredWithoutCoffeeChatsNestedInput
  }

  export type CoffeeChatUncheckedUpdateWithoutPurposeInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    inviteeId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    personalMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCoffeeChatStatusFieldUpdateOperationsInput | $Enums.CoffeeChatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoffeeChatUncheckedUpdateManyWithoutPurposeInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    inviteeId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    personalMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCoffeeChatStatusFieldUpdateOperationsInput | $Enums.CoffeeChatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoffeeChatCreateManyVenueInput = {
    id?: string
    inviterId: string
    inviteeId: string
    purposeId: string
    scheduledAt?: Date | string | null
    duration: number
    personalMessage?: string | null
    status?: $Enums.CoffeeChatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoffeeChatUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    personalMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCoffeeChatStatusFieldUpdateOperationsInput | $Enums.CoffeeChatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviter?: UserDetailsUpdateOneRequiredWithoutCoffeeChatsSentNestedInput
    invitee?: UserDetailsUpdateOneRequiredWithoutCoffeeChatsReceivedNestedInput
    purpose?: CoffeeChatPurposeUpdateOneRequiredWithoutCoffeeChatsNestedInput
  }

  export type CoffeeChatUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    inviteeId?: StringFieldUpdateOperationsInput | string
    purposeId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    personalMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCoffeeChatStatusFieldUpdateOperationsInput | $Enums.CoffeeChatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoffeeChatUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    inviteeId?: StringFieldUpdateOperationsInput | string
    purposeId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    personalMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCoffeeChatStatusFieldUpdateOperationsInput | $Enums.CoffeeChatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyChatInput = {
    id?: string
    senderId: string
    content: string
    createdAt?: Date | string
  }

  export type MessageUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserDetailsUpdateOneRequiredWithoutMessagesSentNestedInput
  }

  export type MessageUncheckedUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}